---
.title = "#frame",
.description = "Frame execution with pass ordering",
.author = "PNGine Team",
.date = @date("2024-12-30"),
.layout = "docs.shtml",
---

Defines a frame that orchestrates the execution of passes and queue operations.

## Syntax

```
#frame name {
  init=[initPass1 initPass2]
  perform=[pass1 pass2 pass3]
}
```

## Attributes

| Attribute | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `perform` | array | Yes | - | Passes to run every frame |
| `init` | array | No | `[]` | Passes to run once (first frame only) |

### perform

**Type:** `array` of references

The main sequence of passes to execute each frame. Order matters - passes execute left to right.

```
perform=[writeUniforms computePass renderPass]
```

Can reference:
- `#renderPass` - Render passes
- `#computePass` - Compute passes
- `#queue` - Queue operations (buffer writes)

### init

**Type:** `array` of references

Passes to run once on the first frame only. Used for one-time initialization like resetting particle buffers or loading initial data.

```
init=[resetParticles loadInitialData]
```

The `init=` passes use the `execPassOnce` opcode, which runs only on the first frame and skips on subsequent frames.

## Examples

### Simple Frame

```
#frame main {
  perform=[renderPass]
}
```

### With Uniform Updates

Include `#queue` operations in `perform=` to update uniforms each frame:

```
#buffer uniforms {
  size=16
  usage=[UNIFORM COPY_DST]
}

#queue writeTime {
  writeBuffer={
    buffer=uniforms
    bufferOffset=0
    data=pngineInputs
  }
}

#renderPass render {
  pipeline=mainPipeline
  bindGroups=[uniformGroup]
  draw=3
}

#frame main {
  perform=[writeTime render]
}
```

### With Initialization

Use `init=` for one-time setup that runs before the first frame:

```
#computePass resetParticles {
  pipeline=initPipeline
  dispatchWorkgroups=[64 1 1]
}

#computePass updateParticles {
  pipeline=simPipeline
  dispatchWorkgroups=[64 1 1]
}

#renderPass drawParticles {
  pipeline=renderPipeline
  draw=2048
}

#frame particles {
  init=[resetParticles]
  perform=[updateParticles drawParticles]
}
```

### Multi-Pass Rendering

```
#frame deferred {
  perform=[
    geometryPass
    lightingPass
    postProcess
  ]
}
```

### Compute + Render

```
#frame simulation {
  init=[initBuffers]
  perform=[
    writeUniforms
    physicsCompute
    renderParticles
  ]
}
```

### Scene-Based Animation

Multiple frames for different scenes:

```
#frame sceneA {
  init=[setupSceneA]
  perform=[renderSceneA]
}

#frame sceneB {
  init=[setupSceneB]
  perform=[renderSceneB]
}

#animation demo {
  duration=60.0
  scenes=[
    { id="intro" frame=sceneA start=0.0 end=10.0 }
    { id="main" frame=sceneB start=10.0 end=50.0 }
    { id="outro" frame=sceneA start=50.0 end=60.0 }
  ]
  endBehavior=loop
}
```

Each frame's `init=` runs once when that scene becomes active.

## Execution Order

Each frame execution follows this order:

1. `init` passes (first frame only, uses `execPassOnce`)
2. `perform` passes (every frame, uses `execPass`)

## Ping-Pong Pattern

For double-buffered compute simulations:

```
#buffer particles {
  size=32768
  usage=[VERTEX STORAGE]
  pool=2
}

#computePass simulate {
  pipeline=simPipeline
  bindGroups=[simGroup]
  bindGroupsPoolOffsets=[0]
  dispatchWorkgroups=[64 1 1]
}

#renderPass draw {
  pipeline=renderPipeline
  vertexBuffers=[particles]
  vertexBuffersPoolOffsets=[0]
  draw=2048
}

#frame boids {
  perform=[simulate draw]
}
```

The runtime automatically alternates pool offsets each frame.

## Validation Rules

| Rule | Error |
|------|-------|
| Name must be unique | `duplicate_definition` |
| `perform` required | `missing_required_property` |
| Referenced passes must exist | `undefined_reference` |

## WebGPU Mapping

Each frame creates a command encoder and submits to queue:

```javascript
const encoder = device.createCommandEncoder();

// Execute init passes (first frame only)
if (isFirstFrame) {
  for (const pass of frame.init) {
    executePass(pass, encoder);
  }
}

// Execute perform passes (every frame)
for (const pass of frame.perform) {
  executePass(pass, encoder);
}

device.queue.submit([encoder.finish()]);
```

## Related

- [`#renderPass`](/docs/dsl/render-pass/) - Render passes
- [`#computePass`](/docs/dsl/compute-pass/) - Compute passes
- [`#queue`](/docs/dsl/queue/) - Buffer writes with pngineInputs
- [`#animation`](/docs/dsl/animation/) - Scene-based animation
