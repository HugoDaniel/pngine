---
.title = "#queue",
.description = "Queue operations for buffer and texture updates",
.author = "PNGine Team",
.date = @date("2024-12-30"),
.layout = "docs.shtml",
---

Defines queue operations for writing data to buffers and copying images to textures.

## Syntax

```
#queue name {
  writeBuffer={
    buffer=bufferName
    bufferOffset=0
    data=dataName
  }
}

#queue name {
  copyExternalImageToTexture={
    source={ source=imageBitmapName }
    destination={ texture=textureName }
    copySize=[512 512]
  }
}
```

## Attributes

| Attribute | Type | Required | Description |
|-----------|------|----------|-------------|
| `writeBuffer` | object | * | Write data to buffer |
| `copyExternalImageToTexture` | object | * | Copy image to texture |
| `copyTextureToTexture` | object | * | Copy between textures |
| `copyBufferToBuffer` | object | * | Copy between buffers |

*At least one operation required.

### writeBuffer

**Type:** `object`

Writes data to a GPU buffer.

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `buffer` | reference | Yes | Target buffer |
| `bufferOffset` | number | No | Byte offset (default: 0) |
| `data` | reference/identifier | Yes | Data source |
| `dataOffset` | number | No | Source data offset |
| `size` | number | No | Bytes to write |

**Data sources:**

Static data reference (from `#data`):
```
data=vertexData
```

Runtime uniform data (built-in):
```
data=pngineInputs
```

The `pngineInputs` identifier provides 16 bytes of runtime data that the executor writes each frame.

### copyExternalImageToTexture

**Type:** `object`

Copies an image bitmap to a texture.

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `source` | object | Yes | Image source |
| `destination` | object | Yes | Texture destination |
| `copySize` | array | Yes | `[width, height]` |

**source object:**

| Property | Type | Description |
|----------|------|-------------|
| `source` | reference | ImageBitmap reference |
| `origin` | array | `[x, y]` offset |
| `flipY` | boolean | Flip vertically |

**destination object:**

| Property | Type | Description |
|----------|------|-------------|
| `texture` | reference | Target texture |
| `mipLevel` | number | Target mip level |
| `origin` | array | `[x, y, z]` offset |

### copyTextureToTexture

**Type:** `object`

Copies between textures.

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `source` | object | Yes | Source texture info |
| `destination` | object | Yes | Destination texture info |
| `copySize` | array | Yes | `[width, height, depth]` |

### copyBufferToBuffer

**Type:** `object`

Copies between buffers.

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `source` | reference | Yes | Source buffer |
| `sourceOffset` | number | No | Source byte offset |
| `destination` | reference | Yes | Destination buffer |
| `destinationOffset` | number | No | Dest byte offset |
| `size` | number | Yes | Bytes to copy |

## Built-in Data Sources

### pngineInputs

The `pngineInputs` identifier provides runtime data that updates every frame. It writes 16 bytes:

| Field | Type | Offset | Description |
|-------|------|--------|-------------|
| `time` | f32 | 0 | Elapsed seconds since start |
| `width` | f32 | 4 | Canvas width in pixels |
| `height` | f32 | 8 | Canvas height in pixels |
| `aspect` | f32 | 12 | width / height |

Your uniform buffer must be at least 16 bytes when using `pngineInputs`.

Your WGSL struct must match this layout:

```
struct PngineInputs {
  time: f32,
  canvasWidth: f32,
  canvasHeight: f32,
  aspect: f32,
}
@group(0) @binding(0) var<uniform> inputs: PngineInputs;
```

## Examples

### Write Runtime Uniforms (pngineInputs)

```
#buffer uniforms {
  size=16
  usage=[UNIFORM COPY_DST]
}

#queue writeTime {
  writeBuffer={
    buffer=uniforms
    bufferOffset=0
    data=pngineInputs
  }
}

#frame main {
  perform=[writeTime renderPass]
}
```

### Write Static Data

```
#data vertexData {
  float32Array=[0 0.5 -0.5 -0.5 0.5 -0.5]
}

#buffer vertices {
  size=24
  usage=[VERTEX COPY_DST]
}

#queue initVertices {
  writeBuffer={
    buffer=vertices
    data=vertexData
  }
}
```

### Load Texture from Image

```
#data imageFile {
  blob={ file={ url="texture.png" } }
}

#imageBitmap textureBitmap {
  image=imageFile
}

#texture colorMap {
  size=[512 512]
  format=rgba8unorm
  usage=[TEXTURE_BINDING COPY_DST RENDER_ATTACHMENT]
}

#queue loadTexture {
  copyExternalImageToTexture={
    source={ source=textureBitmap }
    destination={ texture=colorMap }
    copySize=[512 512]
  }
}

#frame main {
  init=[loadTexture]
  perform=[renderPass]
}
```

### Partial Buffer Update

```
#queue updateTransform {
  writeBuffer={
    buffer=uniformBuffer
    bufferOffset=64
    data=transformData
    size=64
  }
}
```

### Buffer Copy

```
#queue copyResults {
  copyBufferToBuffer={
    source=gpuBuffer
    sourceOffset=0
    destination=readbackBuffer
    destinationOffset=0
    size=4096
  }
}
```

## Frame Integration

Queue operations are executed when included in `#frame`:

```
#frame main {
  perform=[writeUniforms renderPass]
}
```

Or in initialization (runs once):

```
#frame main {
  init=[loadTexture]
  perform=[writeUniforms renderPass]
}
```

## Validation Rules

| Rule | Error |
|------|-------|
| Name must be unique | `duplicate_definition` |
| Referenced buffers/textures must exist | `undefined_reference` |
| At least one operation required | `missing_required_property` |

## WebGPU Mapping

Maps to queue operations:

```javascript
// writeBuffer (static data)
device.queue.writeBuffer(buffer, offset, data);

// writeBuffer (pngineInputs) - runtime provides data
device.queue.writeBuffer(buffer, offset,
  new Float32Array([time, width, height, aspect]));

// copyExternalImageToTexture
device.queue.copyExternalImageToTexture(
  { source: imageBitmap },
  { texture: gpuTexture },
  [width, height]
);
```

## Related

- [`#data`](/docs/dsl/data/) - Define static data to write
- [`#buffer`](/docs/dsl/buffer/) - Target buffers
- [`#texture`](/docs/dsl/texture/) - Target textures
- [`#frame`](/docs/dsl/frame/) - Execute queue operations
