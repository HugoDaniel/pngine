---
.title = "WASM API",
.description = "WebAssembly module exports",
.author = "PNGine Team",
.date = @date("2024-12-18"),
.layout = "page.shtml",
---

## Overview

The WASM module (`pngine.wasm`) provides two interfaces:
1. **Compiler API** - Compile source to bytecode
2. **Runtime API** - Execute bytecode via WebGPU

## Loading

```javascript
async function loadPNGine(imports) {
  const response = await fetch('pngine.wasm');
  const { instance } = await WebAssembly.instantiate(
    await response.arrayBuffer(),
    imports
  );
  return instance.exports;
}
```

## Compiler Exports

### onInit()

Initialize the module. Call once before other functions.

```javascript
pngine.onInit();
```

### compile(srcPtr, srcLen): number

Compile source to bytecode.

| Parameter | Type | Description |
|-----------|------|-------------|
| srcPtr | number | Pointer to source in WASM memory |
| srcLen | number | Source length in bytes |

Returns:
| Code | Description |
|------|-------------|
| 0 | Success |
| 1 | Not initialized |
| 2 | Out of memory |
| 3 | Parse error |
| 4 | Analysis error |

### getOutputPtr(): number

Pointer to compiled bytecode.

### getOutputLen(): number

Length of compiled bytecode.

### freeOutput()

Free the compilation output buffer.

### alloc(len): number

Allocate memory. Returns pointer or 0 on failure.

### free(ptr, len)

Free allocated memory.

## Runtime Exports

The runtime executes bytecode by calling back into JavaScript for GPU operations.

### executeAll(bytecodePtr, bytecodeLen)

Execute all opcodes in bytecode.

### executeFrame(frameId)

Execute a specific frame by ID.

### setTime(seconds)

Set the time uniform (f32).

### setResolution(width, height)

Set the resolution uniforms (u32, u32).

## Required Imports

The runtime requires these JavaScript imports under the `env` namespace:

### Logging

```javascript
wasm_log_write(ptr, len)   // Write to log buffer
wasm_log_flush()           // Flush log to console
```

### Resource Creation

```javascript
gpuCreateBuffer(id, descPtr, descLen)
gpuCreateTexture(id, descPtr, descLen)
gpuCreateTextureView(viewId, textureId, descPtr, descLen)
gpuCreateSampler(id, descPtr, descLen)
gpuCreateShaderModule(id, codePtr, codeLen)
gpuCreateRenderPipeline(id, descPtr, descLen)
gpuCreateComputePipeline(id, descPtr, descLen)
gpuCreateBindGroup(id, layoutId, descPtr, descLen)
gpuCreateBindGroupLayout(id, descPtr, descLen)
gpuCreatePipelineLayout(id, descPtr, descLen)
gpuCreateQuerySet(id, descPtr, descLen)
```

### Render Pass

```javascript
gpuBeginRenderPass(textureId, loadOp, storeOp, hasDepth)
gpuSetPipeline(pipelineId)
gpuSetBindGroup(slot, groupId)
gpuSetVertexBuffer(slot, bufferId)
gpuDraw(vertexCount, instanceCount, firstVertex, firstInstance)
gpuDrawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance)
gpuEndRenderPass()
```

### Compute Pass

```javascript
gpuBeginComputePass()
gpuDispatchWorkgroups(x, y, z)
gpuEndComputePass()
```

### Execution

```javascript
gpuSubmit()
gpuWriteBuffer(bufferId, offset, dataPtr, dataLen)
```

## Example: Compilation

```javascript
const pngine = await loadPNGine({ env: {} });
pngine.onInit();

const source = `
#shaderModule code { code="..." }
#renderPipeline p { ... }
#frame main { ... }
`;

const encoder = new TextEncoder();
const bytes = encoder.encode(source);

const srcPtr = pngine.alloc(bytes.length);
new Uint8Array(pngine.memory.buffer, srcPtr, bytes.length).set(bytes);

const result = pngine.compile(srcPtr, bytes.length);
if (result === 0) {
  const bytecode = new Uint8Array(
    pngine.memory.buffer,
    pngine.getOutputPtr(),
    pngine.getOutputLen()
  ).slice();

  console.log('Compiled:', bytecode.length, 'bytes');
  pngine.freeOutput();
}

pngine.free(srcPtr, bytes.length);
```

## Example: Runtime

```javascript
import { PNGineGPU } from './pngine-gpu.js';

const adapter = await navigator.gpu.requestAdapter();
const device = await adapter.requestDevice();
const context = canvas.getContext('webgpu');

const gpu = new PNGineGPU(device, context);
const imports = gpu.getImports();

const pngine = await loadPNGine(imports);
gpu.setMemory(pngine.memory);

// Load bytecode
const bytecodePtr = pngine.alloc(bytecode.length);
new Uint8Array(pngine.memory.buffer, bytecodePtr, bytecode.length)
  .set(bytecode);

// Execute
pngine.executeAll(bytecodePtr, bytecode.length);
```

## Memory Layout

WASM linear memory is managed by the Zig allocator:

```
┌─────────────────────┐ 0x00000000
│ Stack               │
├─────────────────────┤
│ Static Data         │
├─────────────────────┤
│ Heap                │ ← alloc() returns pointers here
│   ↓ grows down      │
└─────────────────────┘
```

Pointers passed to JavaScript point directly into this memory. Use `Uint8Array` views to read data:

```javascript
function readBytes(ptr, len) {
  return new Uint8Array(pngine.memory.buffer, ptr, len);
}
```
