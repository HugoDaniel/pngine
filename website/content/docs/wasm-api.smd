---
.title = "WASM API",
.description = "Using PNGine from JavaScript",
.author = "PNGine Team",
.date = @date("2024-12-15"),
.layout = "page.shtml",
---

PNGine compiles to WebAssembly for use in browsers. The WASM module exports functions to compile PBSF source code into PNGB bytecode.

## Loading the Module

```javascript
async function loadPNGine() {
    const response = await fetch('pngine.wasm');
    const wasmModule = await WebAssembly.instantiate(await response.arrayBuffer());
    return wasmModule.instance.exports;
}

const pngine = await loadPNGine();
```

## Initialization

Before using any other function, initialize the module:

```javascript
pngine.onInit();
```

This sets up the internal memory allocator. Call this once after loading.

## Exported Functions

### `onInit()`

Initialize the WASM module. Must be called before any other function.

### `compile(srcPtr: number, srcLen: number): number`

Compile PBSF source to PNGB bytecode.

**Parameters:**
- `srcPtr` - Pointer to source bytes in WASM memory
- `srcLen` - Length of source in bytes

**Returns:**
- `0` - Success
- `1` - Module not initialized
- `2` - Out of memory
- `3` - Parse error

### `getOutputPtr(): number`

Get pointer to the last compilation output in WASM memory.

### `getOutputLen(): number`

Get length of the last compilation output in bytes.

### `freeOutput()`

Free the last compilation output. Call this when you're done with the bytecode.

### `alloc(len: number): number`

Allocate memory in the WASM heap. Returns pointer or 0 on failure.

### `free(ptr: number, len: number)`

Free previously allocated memory.

## Complete Example

```javascript
class PNGineCompiler {
    constructor(wasmExports) {
        this.wasm = wasmExports;
        this.wasm.onInit();
    }

    compile(source) {
        const encoder = new TextEncoder();
        const sourceBytes = encoder.encode(source);

        // Allocate memory for source
        const srcPtr = this.wasm.alloc(sourceBytes.length);
        if (srcPtr === 0) {
            throw new Error('Failed to allocate memory for source');
        }

        try {
            // Copy source to WASM memory
            const memory = new Uint8Array(this.wasm.memory.buffer);
            memory.set(sourceBytes, srcPtr);

            // Compile
            const result = this.wasm.compile(srcPtr, sourceBytes.length);

            if (result !== 0) {
                const errors = {
                    1: 'Module not initialized',
                    2: 'Out of memory',
                    3: 'Parse error'
                };
                throw new Error(errors[result] || `Unknown error: ${result}`);
            }

            // Copy output
            const outputPtr = this.wasm.getOutputPtr();
            const outputLen = this.wasm.getOutputLen();
            const bytecode = new Uint8Array(
                this.wasm.memory.buffer, outputPtr, outputLen
            ).slice(); // Copy to avoid referencing WASM memory

            // Free output
            this.wasm.freeOutput();

            return bytecode;
        } finally {
            // Free source memory
            this.wasm.free(srcPtr, sourceBytes.length);
        }
    }
}

// Usage
const response = await fetch('pngine.wasm');
const { instance } = await WebAssembly.instantiate(await response.arrayBuffer());
const compiler = new PNGineCompiler(instance.exports);

const source = `
(module "triangle"
  (data $d:0 "@vertex fn main() -> @builtin(position) vec4f { ... }")
  (shader $shd:0 (code $d:0))
  (render-pipeline $pipe:0 (shader $shd:0))
  (frame $frm:0 "main"
    (set-pipeline $pipe:0)
    (draw 3 1)
    (submit)))
`;

const bytecode = compiler.compile(source);
console.log('Compiled to', bytecode.length, 'bytes');
```

## Error Handling

The `compile` function returns error codes rather than throwing exceptions. Always check the return value:

```javascript
const result = pngine.compile(srcPtr, srcLen);

switch (result) {
    case 0:
        // Success - retrieve output
        break;
    case 1:
        console.error('Call onInit() first');
        break;
    case 2:
        console.error('Out of memory');
        break;
    case 3:
        console.error('Invalid PBSF syntax');
        break;
    default:
        console.error('Unknown error:', result);
}
```

## Memory Management

The WASM module manages its own memory. Follow these rules:

1. **Always call `onInit()` first** - Sets up the allocator
2. **Free what you allocate** - Use `free(ptr, len)` for memory from `alloc()`
3. **Free compilation output** - Call `freeOutput()` when done with bytecode
4. **Copy output if needed later** - The output buffer may be reused on next compile

```javascript
// Good: Copy the bytecode before freeing
const bytecode = new Uint8Array(wasm.memory.buffer, ptr, len).slice();
wasm.freeOutput();

// Bad: Keeping reference to WASM memory after free
const bytecode = new Uint8Array(wasm.memory.buffer, ptr, len);
wasm.freeOutput(); // bytecode is now invalid!
```
