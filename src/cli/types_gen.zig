//! TypeScript Type Generator
//!
//! Generates TypeScript type definitions (.d.ts) from uniform table metadata.
//! Enables type-safe setUniform() calls in TypeScript applications.
//!
//! ## Usage
//! ```bash
//! pngine shader.pngine --types  # Outputs shader.d.ts alongside PNG
//! ```
//!
//! ## Generated Format
//! ```typescript
//! export interface Uniforms {
//!   time: number;
//!   "position.x": number;
//!   color: [number, number, number, number];
//! }
//! export type UniformName = keyof Uniforms;
//! ```
//!
//! ## Invariants
//! - Output file is valid TypeScript
//! - All uniform fields from bytecode are represented
//! - Type mappings follow WGSL to TypeScript conventions

const std = @import("std");
const assert = std.debug.assert;
const Allocator = std.mem.Allocator;

const pngine = @import("pngine");
const format = pngine.format;
const UniformType = pngine.uniform_table.UniformType;
const UniformTable = pngine.uniform_table.UniformTable;
const StringTable = pngine.string_table.StringTable;

/// Maximum output size for generated TypeScript (safety limit).
const MAX_OUTPUT_SIZE: u32 = 64 * 1024;

/// Generate TypeScript type definitions from bytecode.
///
/// Pre-condition: bytecode is valid PNGB format.
/// Post-condition: Returns owned TypeScript source that caller must free.
pub fn generateFromBytecode(allocator: Allocator, bytecode: []const u8) ![]u8 {
    // Pre-conditions
    assert(bytecode.len >= format.HEADER_SIZE);
    assert(std.mem.eql(u8, bytecode[0..4], format.MAGIC));

    // Deserialize to get uniform table and string table
    var module = try format.deserialize(allocator, bytecode);
    defer module.deinit(allocator);

    return generate(allocator, &module.uniforms, &module.strings);
}

/// Generate TypeScript type definitions from uniform table.
///
/// Pre-condition: uniforms and strings are valid.
/// Post-condition: Returns owned TypeScript source that caller must free.
pub fn generate(
    allocator: Allocator,
    uniforms: *const UniformTable,
    strings: *const StringTable,
) ![]u8 {
    // Pre-conditions
    assert(@intFromPtr(uniforms) != 0);
    assert(@intFromPtr(strings) != 0);

    var output = std.ArrayListUnmanaged(u8){};
    errdefer output.deinit(allocator);

    // Write header comment
    try output.appendSlice(allocator,
        \\// Auto-generated by pngine - DO NOT EDIT
        \\// Uniform type definitions for setUniform() API
        \\
        \\
    );

    // Count total fields for empty check
    var total_fields: u32 = 0;
    for (uniforms.bindings.items) |binding| {
        total_fields += @intCast(binding.fields.len);
    }

    if (total_fields == 0) {
        // No uniforms - generate empty interface
        try output.appendSlice(allocator,
            \\export interface Uniforms {}
            \\export type UniformName = never;
            \\
        );
        return try output.toOwnedSlice(allocator);
    }

    // Write Uniforms interface
    try output.appendSlice(allocator, "export interface Uniforms {\n");

    // Iterate all bindings and fields
    for (uniforms.bindings.items) |binding| {
        for (binding.fields) |field| {
            const field_name = strings.get(@enumFromInt(field.name_string_id));
            const ts_type = uniformTypeToTypeScript(field.uniform_type);

            // Quote field names with dots (nested fields)
            if (std.mem.indexOf(u8, field_name, ".") != null) {
                const line = try std.fmt.allocPrint(allocator, "  \"{s}\": {s};\n", .{ field_name, ts_type });
                defer allocator.free(line);
                try output.appendSlice(allocator, line);
            } else {
                const line = try std.fmt.allocPrint(allocator, "  {s}: {s};\n", .{ field_name, ts_type });
                defer allocator.free(line);
                try output.appendSlice(allocator, line);
            }
        }
    }

    try output.appendSlice(allocator, "}\n\n");

    // Write UniformName type alias
    try output.appendSlice(allocator, "export type UniformName = keyof Uniforms;\n");

    // Post-condition: output is bounded
    assert(output.items.len <= MAX_OUTPUT_SIZE);

    return try output.toOwnedSlice(allocator);
}

/// Map UniformType to TypeScript type string.
///
/// Pre-condition: uniform_type is a valid UniformType.
/// Post-condition: Returns a valid TypeScript type string.
fn uniformTypeToTypeScript(uniform_type: UniformType) []const u8 {
    return switch (uniform_type) {
        // Scalar types
        .f32, .i32, .u32 => "number",

        // Vector types (tuples)
        .vec2f, .vec2i, .vec2u => "[number, number]",
        .vec3f, .vec3i, .vec3u => "[number, number, number]",
        .vec4f, .vec4i, .vec4u => "[number, number, number, number]",

        // Matrix types (nested tuples, column-major)
        .mat3x3f => "[[number, number, number], [number, number, number], [number, number, number]]",
        .mat4x4f => "[[number, number, number, number], [number, number, number, number], [number, number, number, number], [number, number, number, number]]",

        // Unknown - use generic ArrayLike
        .unknown => "ArrayLike<number>",
    };
}

/// Write TypeScript definitions to file.
///
/// Pre-condition: path ends with .d.ts, content is valid TypeScript.
/// Post-condition: File is written or error returned.
pub fn writeToFile(path: []const u8, content: []const u8) !void {
    // Pre-condition
    assert(path.len > 5); // At least "x.d.ts"
    assert(std.mem.endsWith(u8, path, ".d.ts"));

    const file = try std.fs.cwd().createFile(path, .{});
    defer file.close();

    try file.writeAll(content);
}

/// Derive .d.ts path from PNG/bytecode output path.
///
/// Pre-condition: output_path is a valid path.
/// Post-condition: Returns owned path that caller must free.
pub fn deriveTypesPath(allocator: Allocator, output_path: []const u8) ![]u8 {
    // Pre-condition
    assert(output_path.len > 0);

    const stem = std.fs.path.stem(output_path);
    const dir = std.fs.path.dirname(output_path);

    const result = if (dir) |d|
        try std.fmt.allocPrint(allocator, "{s}/{s}.d.ts", .{ d, stem })
    else
        try std.fmt.allocPrint(allocator, "{s}.d.ts", .{stem});

    // Post-condition
    assert(std.mem.endsWith(u8, result, ".d.ts"));

    return result;
}

// ============================================================================
// Tests
// ============================================================================

const testing = std.testing;

test "uniformTypeToTypeScript: scalar types" {
    // Property: Scalar types map to 'number'.
    try testing.expectEqualStrings("number", uniformTypeToTypeScript(.f32));
    try testing.expectEqualStrings("number", uniformTypeToTypeScript(.i32));
    try testing.expectEqualStrings("number", uniformTypeToTypeScript(.u32));
}

test "uniformTypeToTypeScript: vector types" {
    // Property: Vector types map to tuple types.
    try testing.expectEqualStrings("[number, number]", uniformTypeToTypeScript(.vec2f));
    try testing.expectEqualStrings("[number, number, number]", uniformTypeToTypeScript(.vec3f));
    try testing.expectEqualStrings("[number, number, number, number]", uniformTypeToTypeScript(.vec4f));
}

test "uniformTypeToTypeScript: matrix types" {
    // Property: Matrix types map to nested tuple types.
    const mat3 = uniformTypeToTypeScript(.mat3x3f);
    try testing.expect(std.mem.indexOf(u8, mat3, "[[number") != null);

    const mat4 = uniformTypeToTypeScript(.mat4x4f);
    try testing.expect(std.mem.indexOf(u8, mat4, "[[number") != null);
}

test "generate: empty uniform table" {
    // Property: Empty uniform table produces empty interface.
    const allocator = testing.allocator;

    var uniforms = UniformTable.empty;
    defer uniforms.deinit(allocator);

    var strings = pngine.string_table.StringTable.empty;
    defer strings.deinit(allocator);

    const output = try generate(allocator, &uniforms, &strings);
    defer allocator.free(output);

    try testing.expect(std.mem.indexOf(u8, output, "interface Uniforms {}") != null);
    try testing.expect(std.mem.indexOf(u8, output, "type UniformName = never") != null);
}

test "generate: single field" {
    // Property: Single field produces valid interface.
    const allocator = testing.allocator;

    var uniforms = UniformTable.empty;
    defer uniforms.deinit(allocator);

    var strings = pngine.string_table.StringTable.empty;
    defer strings.deinit(allocator);

    // Add a field named "time" (string ID 0)
    const time_id = try strings.intern(allocator, "time");

    try uniforms.addBinding(
        allocator,
        0, // buffer_id
        time_id, // name_string_id
        0, // group
        0, // binding_index
        &[_]pngine.uniform_table.UniformField{
            .{
                .slot = 0,
                .name_string_id = time_id,
                .offset = 0,
                .size = 4,
                .uniform_type = .f32,
            },
        },
    );

    const output = try generate(allocator, &uniforms, &strings);
    defer allocator.free(output);

    try testing.expect(std.mem.indexOf(u8, output, "time: number;") != null);
    try testing.expect(std.mem.indexOf(u8, output, "type UniformName = keyof Uniforms") != null);
}

test "generate: nested field with dot notation" {
    // Property: Nested fields are quoted in output.
    const allocator = testing.allocator;

    var uniforms = UniformTable.empty;
    defer uniforms.deinit(allocator);

    var strings = pngine.string_table.StringTable.empty;
    defer strings.deinit(allocator);

    // Add a nested field "position.x"
    const binding_id = try strings.intern(allocator, "uniforms");
    const field_id = try strings.intern(allocator, "position.x");

    try uniforms.addBinding(
        allocator,
        0,
        binding_id,
        0,
        0,
        &[_]pngine.uniform_table.UniformField{
            .{
                .slot = 0,
                .name_string_id = field_id,
                .offset = 0,
                .size = 4,
                .uniform_type = .f32,
            },
        },
    );

    const output = try generate(allocator, &uniforms, &strings);
    defer allocator.free(output);

    // Nested field should be quoted
    try testing.expect(std.mem.indexOf(u8, output, "\"position.x\": number;") != null);
}

test "generate: vector field" {
    // Property: Vector fields produce tuple types.
    const allocator = testing.allocator;

    var uniforms = UniformTable.empty;
    defer uniforms.deinit(allocator);

    var strings = pngine.string_table.StringTable.empty;
    defer strings.deinit(allocator);

    const binding_id = try strings.intern(allocator, "uniforms");
    const color_id = try strings.intern(allocator, "color");

    try uniforms.addBinding(
        allocator,
        0,
        binding_id,
        0,
        0,
        &[_]pngine.uniform_table.UniformField{
            .{
                .slot = 0,
                .name_string_id = color_id,
                .offset = 0,
                .size = 16,
                .uniform_type = .vec4f,
            },
        },
    );

    const output = try generate(allocator, &uniforms, &strings);
    defer allocator.free(output);

    try testing.expect(std.mem.indexOf(u8, output, "color: [number, number, number, number];") != null);
}

test "deriveTypesPath: simple path" {
    // Property: Derives .d.ts path from PNG path.
    const allocator = testing.allocator;

    const result = try deriveTypesPath(allocator, "shader.png");
    defer allocator.free(result);

    try testing.expectEqualStrings("shader.d.ts", result);
}

test "deriveTypesPath: path with directory" {
    // Property: Preserves directory in output path.
    const allocator = testing.allocator;

    const result = try deriveTypesPath(allocator, "output/shader.png");
    defer allocator.free(result);

    try testing.expectEqualStrings("output/shader.d.ts", result);
}

test "uniformTypeToTypeScript: all integer vector types" {
    // Property: Integer vector types map correctly to tuple types.
    try testing.expectEqualStrings("[number, number]", uniformTypeToTypeScript(.vec2i));
    try testing.expectEqualStrings("[number, number]", uniformTypeToTypeScript(.vec2u));
    try testing.expectEqualStrings("[number, number, number]", uniformTypeToTypeScript(.vec3i));
    try testing.expectEqualStrings("[number, number, number]", uniformTypeToTypeScript(.vec3u));
    try testing.expectEqualStrings("[number, number, number, number]", uniformTypeToTypeScript(.vec4i));
    try testing.expectEqualStrings("[number, number, number, number]", uniformTypeToTypeScript(.vec4u));
}

test "uniformTypeToTypeScript: unknown type" {
    // Property: Unknown type maps to ArrayLike<number>.
    try testing.expectEqualStrings("ArrayLike<number>", uniformTypeToTypeScript(.unknown));
}

test "uniformTypeToTypeScript: matrix dimensions" {
    // Property: Matrix types have correct element counts.
    const mat3 = uniformTypeToTypeScript(.mat3x3f);
    // mat3x3 should have 3 rows of 3 elements each
    try testing.expectEqualStrings(
        "[[number, number, number], [number, number, number], [number, number, number]]",
        mat3,
    );

    const mat4 = uniformTypeToTypeScript(.mat4x4f);
    // mat4x4 should have 4 rows of 4 elements each
    try testing.expectEqualStrings(
        "[[number, number, number, number], [number, number, number, number], [number, number, number, number], [number, number, number, number]]",
        mat4,
    );
}

test "generate: multiple fields in single binding" {
    // Property: Multiple fields produce multiple interface properties.
    const allocator = testing.allocator;

    var uniforms = UniformTable.empty;
    defer uniforms.deinit(allocator);

    var strings = pngine.string_table.StringTable.empty;
    defer strings.deinit(allocator);

    const binding_id = try strings.intern(allocator, "inputs");
    const time_id = try strings.intern(allocator, "time");
    const width_id = try strings.intern(allocator, "width");
    const height_id = try strings.intern(allocator, "height");
    const aspect_id = try strings.intern(allocator, "aspect");

    try uniforms.addBinding(
        allocator,
        0,
        binding_id,
        0,
        0,
        &[_]pngine.uniform_table.UniformField{
            .{ .slot = 0, .name_string_id = aspect_id, .offset = 12, .size = 4, .uniform_type = .f32 },
            .{ .slot = 1, .name_string_id = height_id, .offset = 8, .size = 4, .uniform_type = .f32 },
            .{ .slot = 2, .name_string_id = time_id, .offset = 0, .size = 4, .uniform_type = .f32 },
            .{ .slot = 3, .name_string_id = width_id, .offset = 4, .size = 4, .uniform_type = .f32 },
        },
    );

    const output = try generate(allocator, &uniforms, &strings);
    defer allocator.free(output);

    // All four fields should be present
    try testing.expect(std.mem.indexOf(u8, output, "time: number;") != null);
    try testing.expect(std.mem.indexOf(u8, output, "width: number;") != null);
    try testing.expect(std.mem.indexOf(u8, output, "height: number;") != null);
    try testing.expect(std.mem.indexOf(u8, output, "aspect: number;") != null);
    try testing.expect(std.mem.indexOf(u8, output, "export interface Uniforms {") != null);
    try testing.expect(std.mem.indexOf(u8, output, "export type UniformName = keyof Uniforms;") != null);
}

test "generate: multiple bindings" {
    // Property: Fields from multiple bindings are all included.
    const allocator = testing.allocator;

    var uniforms = UniformTable.empty;
    defer uniforms.deinit(allocator);

    var strings = pngine.string_table.StringTable.empty;
    defer strings.deinit(allocator);

    const binding1_id = try strings.intern(allocator, "inputs");
    const binding2_id = try strings.intern(allocator, "material");
    const time_id = try strings.intern(allocator, "time");
    const color_id = try strings.intern(allocator, "color");

    // First binding: time uniform
    try uniforms.addBinding(
        allocator,
        0,
        binding1_id,
        0,
        0,
        &[_]pngine.uniform_table.UniformField{
            .{ .slot = 0, .name_string_id = time_id, .offset = 0, .size = 4, .uniform_type = .f32 },
        },
    );

    // Second binding: color uniform
    try uniforms.addBinding(
        allocator,
        1,
        binding2_id,
        0,
        1,
        &[_]pngine.uniform_table.UniformField{
            .{ .slot = 1, .name_string_id = color_id, .offset = 0, .size = 16, .uniform_type = .vec4f },
        },
    );

    const output = try generate(allocator, &uniforms, &strings);
    defer allocator.free(output);

    // Both bindings' fields should be present
    try testing.expect(std.mem.indexOf(u8, output, "time: number;") != null);
    try testing.expect(std.mem.indexOf(u8, output, "color: [number, number, number, number];") != null);
}

test "generate: deeply nested field paths" {
    // Property: Deeply nested paths (a.b.c) are properly quoted.
    const allocator = testing.allocator;

    var uniforms = UniformTable.empty;
    defer uniforms.deinit(allocator);

    var strings = pngine.string_table.StringTable.empty;
    defer strings.deinit(allocator);

    const binding_id = try strings.intern(allocator, "scene");
    const field1_id = try strings.intern(allocator, "camera.position.x");
    const field2_id = try strings.intern(allocator, "camera.position.y");
    const field3_id = try strings.intern(allocator, "light.color");

    try uniforms.addBinding(
        allocator,
        0,
        binding_id,
        0,
        0,
        &[_]pngine.uniform_table.UniformField{
            .{ .slot = 0, .name_string_id = field1_id, .offset = 0, .size = 4, .uniform_type = .f32 },
            .{ .slot = 1, .name_string_id = field2_id, .offset = 4, .size = 4, .uniform_type = .f32 },
            .{ .slot = 2, .name_string_id = field3_id, .offset = 16, .size = 16, .uniform_type = .vec4f },
        },
    );

    const output = try generate(allocator, &uniforms, &strings);
    defer allocator.free(output);

    // Nested fields should be quoted
    try testing.expect(std.mem.indexOf(u8, output, "\"camera.position.x\": number;") != null);
    try testing.expect(std.mem.indexOf(u8, output, "\"camera.position.y\": number;") != null);
    try testing.expect(std.mem.indexOf(u8, output, "\"light.color\": [number, number, number, number];") != null);
}

test "generate: matrix field" {
    // Property: Matrix fields produce nested tuple types.
    const allocator = testing.allocator;

    var uniforms = UniformTable.empty;
    defer uniforms.deinit(allocator);

    var strings = pngine.string_table.StringTable.empty;
    defer strings.deinit(allocator);

    const binding_id = try strings.intern(allocator, "transforms");
    const mvp_id = try strings.intern(allocator, "mvp");
    const normal_id = try strings.intern(allocator, "normalMatrix");

    try uniforms.addBinding(
        allocator,
        0,
        binding_id,
        0,
        0,
        &[_]pngine.uniform_table.UniformField{
            .{ .slot = 0, .name_string_id = mvp_id, .offset = 0, .size = 64, .uniform_type = .mat4x4f },
            .{ .slot = 1, .name_string_id = normal_id, .offset = 64, .size = 48, .uniform_type = .mat3x3f },
        },
    );

    const output = try generate(allocator, &uniforms, &strings);
    defer allocator.free(output);

    // mat4x4f should have 4 rows of 4 elements
    try testing.expect(std.mem.indexOf(u8, output, "mvp: [[number, number, number, number]") != null);
    // mat3x3f should have 3 rows of 3 elements
    try testing.expect(std.mem.indexOf(u8, output, "normalMatrix: [[number, number, number]") != null);
}

test "generate: all vector types" {
    // Property: All vector types produce correct tuple sizes.
    const allocator = testing.allocator;

    var uniforms = UniformTable.empty;
    defer uniforms.deinit(allocator);

    var strings = pngine.string_table.StringTable.empty;
    defer strings.deinit(allocator);

    const binding_id = try strings.intern(allocator, "vectors");
    const v2f_id = try strings.intern(allocator, "v2f");
    const v3f_id = try strings.intern(allocator, "v3f");
    const v4f_id = try strings.intern(allocator, "v4f");
    const v2i_id = try strings.intern(allocator, "v2i");
    const v3u_id = try strings.intern(allocator, "v3u");

    try uniforms.addBinding(
        allocator,
        0,
        binding_id,
        0,
        0,
        &[_]pngine.uniform_table.UniformField{
            .{ .slot = 0, .name_string_id = v2f_id, .offset = 0, .size = 8, .uniform_type = .vec2f },
            .{ .slot = 1, .name_string_id = v3f_id, .offset = 16, .size = 12, .uniform_type = .vec3f },
            .{ .slot = 2, .name_string_id = v4f_id, .offset = 32, .size = 16, .uniform_type = .vec4f },
            .{ .slot = 3, .name_string_id = v2i_id, .offset = 48, .size = 8, .uniform_type = .vec2i },
            .{ .slot = 4, .name_string_id = v3u_id, .offset = 56, .size = 12, .uniform_type = .vec3u },
        },
    );

    const output = try generate(allocator, &uniforms, &strings);
    defer allocator.free(output);

    try testing.expect(std.mem.indexOf(u8, output, "v2f: [number, number];") != null);
    try testing.expect(std.mem.indexOf(u8, output, "v3f: [number, number, number];") != null);
    try testing.expect(std.mem.indexOf(u8, output, "v4f: [number, number, number, number];") != null);
    try testing.expect(std.mem.indexOf(u8, output, "v2i: [number, number];") != null);
    try testing.expect(std.mem.indexOf(u8, output, "v3u: [number, number, number];") != null);
}

test "generate: header comment present" {
    // Property: Output always starts with the header comment.
    const allocator = testing.allocator;

    var uniforms = UniformTable.empty;
    defer uniforms.deinit(allocator);

    var strings = pngine.string_table.StringTable.empty;
    defer strings.deinit(allocator);

    const output = try generate(allocator, &uniforms, &strings);
    defer allocator.free(output);

    try testing.expect(std.mem.startsWith(u8, output, "// Auto-generated by pngine"));
    try testing.expect(std.mem.indexOf(u8, output, "DO NOT EDIT") != null);
}

test "deriveTypesPath: nested directories" {
    // Property: Deep nested paths are preserved.
    const allocator = testing.allocator;

    const result = try deriveTypesPath(allocator, "dist/shaders/effects/glow.png");
    defer allocator.free(result);

    try testing.expectEqualStrings("dist/shaders/effects/glow.d.ts", result);
}

test "deriveTypesPath: pngb extension" {
    // Property: Works with .pngb files too.
    const allocator = testing.allocator;

    const result = try deriveTypesPath(allocator, "output.pngb");
    defer allocator.free(result);

    try testing.expectEqualStrings("output.d.ts", result);
}

test "deriveTypesPath: no extension" {
    // Property: Works with files without extension.
    const allocator = testing.allocator;

    const result = try deriveTypesPath(allocator, "shader");
    defer allocator.free(result);

    try testing.expectEqualStrings("shader.d.ts", result);
}

test "deriveTypesPath: absolute path" {
    // Property: Absolute paths are preserved.
    const allocator = testing.allocator;

    const result = try deriveTypesPath(allocator, "/home/user/project/shader.png");
    defer allocator.free(result);

    try testing.expectEqualStrings("/home/user/project/shader.d.ts", result);
}
