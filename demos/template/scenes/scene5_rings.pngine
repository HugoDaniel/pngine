// Scene 5: Rings
// Concentric pulsing rings with interference patterns

#buffer ringsUniforms {
  size=16
  usage=[UNIFORM COPY_DST]
}

#queue ringsWriteUniforms {
  writeBuffer={ buffer=ringsUniforms bufferOffset=0 data=pngineInputs }
}

#shaderModule ringsShader {
  code="
    struct Uniforms {
      time: f32,
      width: f32,
      height: f32,
      aspect: f32,
    }
    @group(0) @binding(0) var<uniform> u: Uniforms;

    const PI: f32 = 3.14159265359;

    @vertex
    fn vs(@builtin(vertex_index) i: u32) -> @builtin(position) vec4f {
      let x = f32(i & 1u) * 4.0 - 1.0;
      let y = f32((i >> 1u) & 1u) * 4.0 - 1.0;
      return vec4f(x, y, 0.0, 1.0);
    }

    @fragment
    fn fs(@builtin(position) pos: vec4f) -> @location(0) vec4f {
      let uv = vec2f(pos.x / u.width, pos.y / u.height);
      var p = (uv - 0.5) * 2.0;
      p.x *= u.aspect;

      let t = u.time;

      // Multiple ring sources
      let c1 = vec2f(sin(t * 0.3) * 0.3, cos(t * 0.4) * 0.3);
      let c2 = vec2f(sin(t * 0.5 + 2.0) * 0.4, cos(t * 0.3 + 1.0) * 0.3);
      let c3 = vec2f(0.0, 0.0);

      let d1 = length(p - c1);
      let d2 = length(p - c2);
      let d3 = length(p - c3);

      // Ring patterns
      let ring1 = sin(d1 * 20.0 - t * 3.0) * 0.5 + 0.5;
      let ring2 = sin(d2 * 15.0 - t * 2.5) * 0.5 + 0.5;
      let ring3 = sin(d3 * 25.0 - t * 4.0) * 0.5 + 0.5;

      // Interference pattern
      let interference = ring1 * ring2 * ring3;

      // Color based on angle and time
      let angle = atan2(p.y, p.x);
      let hue = fract((angle / (2.0 * PI)) + t * 0.1);

      let col1 = vec3f(1.0, 0.2, 0.4);
      let col2 = vec3f(0.2, 0.4, 1.0);
      let col3 = vec3f(0.4, 1.0, 0.6);

      var col = col1 * ring1 * 0.4 + col2 * ring2 * 0.4 + col3 * ring3 * 0.3;

      // Add bright interference lines
      let lines = pow(interference, 3.0);
      col += vec3f(1.0) * lines * 0.5;

      // Pulse effect
      let pulse = sin(t * 2.0) * 0.2 + 0.8;
      col *= pulse;

      // Vignette
      let vignette = 1.0 - length(p) * 0.4;
      col *= vignette;

      return vec4f(col, 1.0);
    }
  "
}

#renderPipeline ringsPipeline {
  layout=auto
  vertex={ entryPoint=vs module=ringsShader }
  fragment={
    entryPoint=fs
    module=ringsShader
    targets=[{ format=preferredCanvasFormat }]
  }
}

#bindGroup ringsUniformsBindGroup {
  layout={ pipeline=ringsPipeline index=0 }
  entries=[{ binding=0 resource={ buffer=ringsUniforms } }]
}

#renderPass ringsPass {
  colorAttachments=[{
    view=contextCurrentTexture
    clearValue=[0 0 0 1]
    loadOp=clear
    storeOp=store
  }]
  pipeline=ringsPipeline
  bindGroups=[ringsUniformsBindGroup]
  draw=3
}

#frame rings {
  perform=[ringsWriteUniforms ringsPass]
}
