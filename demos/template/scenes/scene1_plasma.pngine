// Scene 1: Plasma
// Classic plasma effect with pulsing colors

#buffer plasmaUniforms {
  size=16
  usage=[UNIFORM COPY_DST]
}

#queue plasmaWriteUniforms {
  writeBuffer={ buffer=plasmaUniforms bufferOffset=0 data=pngineInputs }
}

#shaderModule plasmaShader {
  code="
    struct Uniforms {
      time: f32,
      width: f32,
      height: f32,
      aspect: f32,
    }
    @group(0) @binding(0) var<uniform> u: Uniforms;

    @vertex
    fn vs(@builtin(vertex_index) i: u32) -> @builtin(position) vec4f {
      let x = f32(i & 1u) * 4.0 - 1.0;
      let y = f32((i >> 1u) & 1u) * 4.0 - 1.0;
      return vec4f(x, y, 0.0, 1.0);
    }

    @fragment
    fn fs(@builtin(position) pos: vec4f) -> @location(0) vec4f {
      let uv = vec2f(pos.x / u.width, pos.y / u.height);
      let p = (uv - 0.5) * 8.0;
      let t = u.time * 0.5;

      var v = 0.0;
      v += sin(p.x + t);
      v += sin((p.y + t) * 0.5);
      v += sin((p.x + p.y + t) * 0.5);

      let cx = p.x + 0.5 * sin(t * 0.33);
      let cy = p.y + 0.5 * cos(t * 0.5);
      v += sin(sqrt(cx * cx + cy * cy + 1.0) + t);

      v = v * 0.5;

      let r = sin(v * 3.14159) * 0.5 + 0.5;
      let g = sin(v * 3.14159 + 2.094) * 0.5 + 0.5;
      let b = sin(v * 3.14159 + 4.188) * 0.5 + 0.5;

      return vec4f(r, g, b, 1.0);
    }
  "
}

#renderPipeline plasmaPipeline {
  layout=auto
  vertex={ entryPoint=vs module=plasmaShader }
  fragment={
    entryPoint=fs
    module=plasmaShader
    targets=[{ format=preferredCanvasFormat }]
  }
}

#bindGroup plasmaUniformsBindGroup {
  layout={ pipeline=plasmaPipeline index=0 }
  entries=[{ binding=0 resource={ buffer=plasmaUniforms } }]
}

#renderPass plasmaPass {
  colorAttachments=[{
    view=contextCurrentTexture
    clearValue=[0 0 0 1]
    loadOp=clear
    storeOp=store
  }]
  pipeline=plasmaPipeline
  bindGroups=[plasmaUniformsBindGroup]
  draw=3
}

#frame plasma {
  perform=[plasmaWriteUniforms plasmaPass]
}
