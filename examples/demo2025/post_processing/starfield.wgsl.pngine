/*
This pipeline will be rendering to the canvas so we need to set the
target format as the presentationFormat
*/
#renderPipeline postProcessStarfieldPipeline {
  layout=auto
  vertex={ module=postProcessStarfieldModule }
  fragment={
	module=postProcessStarfieldModule
	targets=[{ format=preferredCanvasFormat }]
  }
}

#renderPass postProcessStarfieldRenderPass {
  colorAttachments=[{
    view=contextCurrentTexture
    loadOp=clear
    storeOp=store
  }]
  pipeline=postProcessStarfieldPipeline
  bindGroups=[postProcessStarfieldBindGroup]
  draw=3
}

#bindGroup postProcessStarfieldBindGroup {
  layout={ pipeline=postProcessStarfieldPipeline index=0 }
  entries=[
    { binding=0 resource=renderTarget },
    { binding=1 resource=postProcessSampler },
    { binding=2 resource={ buffer=uniformPngineInputsBuffer } }
  ]
}

#shaderModule postProcessStarfieldModule {

  code="

struct PngineInputs {
  time: f32,
};



struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) texcoord: vec2f,
};



@vertex fn vs(@builtin(vertex_index) vertexIndex : u32) -> VSOutput {
  var pos = array(
    vec2f(-1.0, -1.0),
    vec2f(-1.0,  3.0),
    vec2f( 3.0, -1.0),
  );

  var vsOutput: VSOutput;
  let xy = pos[vertexIndex];
  vsOutput.position = vec4f(xy, 0.0, 1.0);
  vsOutput.texcoord = xy * vec2f(0.5, -0.5) + vec2f(0.5);
  return vsOutput;
}



@group(0) @binding(0) var postTexture2d: texture_2d<f32>;
@group(0) @binding(1) var postSampler: sampler;
@group(0) @binding(2) var<uniform> inputs : PngineInputs;

fn hash(p: vec2f) -> f32 {
  let p3 = fract(vec3f(p.xyx) * 0.1031);
  let p3_add = p3 + dot(p3, p3.yzx + 33.33);
  return fract((p3_add.x + p3_add.y) * p3_add.z);
}

@fragment fn fs2d(fsInput: VSOutput) -> @location(0) vec4f {
  let uv = fsInput.texcoord;
  let t = inputs.time;
  // To avoid post-processing uncomment the following line:
  return textureSample(postTexture2d, postSampler, uv);

/*
  // Chromatic Aberration
  let ca_amount = 0.03;
  let r_offset = vec2f(ca_amount, ca_amount) * (1.0 - uv.y);
  let b_offset = vec2f(-ca_amount, -ca_amount) * (1.0 - uv.y);

 
  let r = textureSample(postTexture2d, postSampler, uv + r_offset).r;
  let g = textureSample(postTexture2d, postSampler, uv).g;
  let b = textureSample(postTexture2d, postSampler, uv + b_offset).b;

  var color = vec3f(r, g, b);
  
  // Vignette
  let vignette_strength = 0.9;
  let vignette_falloff = 0.4;
  let dist = length(uv - 0.5);
  let vignette = smoothstep(vignette_falloff, vignette_strength, dist);

  color *= 1.0 - vignette;

  // Film Grain
  // let grain_amount = 0.01;
  // let grain = (hash(uv + inputs.time) - 0.5) * grain_amount;
  // color += grain;

  return vec4f(color, 1.0);
  */
}
"

}


