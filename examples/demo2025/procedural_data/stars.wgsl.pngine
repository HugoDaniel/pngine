#define NUM_STARS_PARTICLES="64*64"

// Buffer size: 4096 particles * 8 floats (pos.xyzw + vel.xyzw) * 4 bytes
#define STARS_BUFFER_SIZE="NUM_STARS_PARTICLES * 8 * 4"

// Pooled 2 buffers for ping-pong simulation
#buffer starsParticlesBuffers {
  size=STARS_BUFFER_SIZE
  usage=[VERTEX STORAGE]
  pool=2
}

#buffer starsSimParamBuffer {
  size=32 // deltaT + simId + vec3 + vec3 (8 floats * 4 bytes)
  usage=[UNIFORM COPY_DST]
}

#data starsSimParamsData {
  float32Array=[
  // deltaT:
  0.04,
  // simId:
  0.0
  // rule1Distance:
  0.1,
  // rule2Distance:
  0.025,
  // rule3Distance:
  0.025,
  // rule1Scale:
  0.02,
  // rule2Scale:
  0.05,
  // rule3Scale:
  0.005
]}

#queue initStarsSimParams {
  writeBuffer={
    buffer=starsSimParamBuffer
    bufferOffset=0
    data=starsSimParamsData
  }
}

// Initialization shader for star particles
#shaderModule initStarsShader {
  code="
    struct Particle {
      pos: vec4f,
      vel: vec4f,
    }
    struct Particles { data: array<Particle> }

    @binding(0) @group(0) var<storage, read_write> particles: Particles;

    fn hash(n: u32) -> f32 {
      var x = n;
      x = ((x >> 16u) ^ x) * 0x45d9f3bu;
      x = ((x >> 16u) ^ x) * 0x45d9f3bu;
      x = (x >> 16u) ^ x;
      return f32(x) / f32(0xffffffffu);
    }

    const TOTAL: u32 = 4096u;

    @compute @workgroup_size(64)
    fn main(@builtin(global_invocation_id) id: vec3u) {
      let i = id.x;
      if (i >= TOTAL) { return; }

      // Position: random in [-10, 10]
      particles.data[i].pos = vec4f(
        hash(i * 7u) * 20.0 - 10.0,
        hash(i * 11u) * 20.0 - 10.0,
        hash(i * 13u) * 20.0 - 10.0,
        1.0  // homogeneous coord
      );

      // Velocity: random in [0, 1] with random position in w
      particles.data[i].vel = vec4f(
        hash(i * 17u),
        hash(i * 19u),
        hash(i * 23u),
        hash(i * 29u) * 20.0 - 10.0  // random position for variety
      );
    }
  "
}

#init initStarsParticles {
  buffer=starsParticlesBuffers
  shader=initStarsShader
  workgroups="ceil(NUM_STARS_PARTICLES / 64)"
}

#bindGroup starsParticlesBindGroups {
  layout={ pipeline=computeStarsParticles index=0 }
  entries=[
    { binding=0 resource={ buffer=starsParticlesBuffers pingPong=0 }}
    { binding=1 resource={ buffer=starsParticlesBuffers pingPong=1 }}
    { binding=2 resource={ buffer=starsSimParamBuffer }}
    { binding=3 resource={ buffer=sceneQInputsBuffer }}
    { binding=4 resource={ buffer=uniformPngineInputsBuffer } }
  ]
  pool=2
}

#computePipeline computeStarsParticles {
  layout=auto
  compute={
    entrypoint=computeStarsParticlesMain
    module=starsParticlesModule
  }
}

#computePass computeStarsParticlesPass {
  pipeline=computeStarsParticles
  bindGroups=[starsParticlesBindGroups]
  dispatchWorkgroups="ceil(NUM_STARS_PARTICLES / 64)"
}

#wgsl sceneQStarsShader {
  value="./wgsl/sceneQStars.wgsl"
  imports=[constants, transform2D, primitives, beats, tangram]
}

#shaderModule starsParticlesModule {
  code=sceneQStarsShader
}
