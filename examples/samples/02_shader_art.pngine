// 02 - Shader Art (Plasma Effect)
// Shadertoy-style plasma animation
// Demonstrates: complex math, time-based animation, color mixing

#buffer uniforms {
  size=16
  usage=[UNIFORM COPY_DST]
}

#queue writeUniforms {
  writeBuffer={ buffer=uniforms bufferOffset=0 data=pngineInputs }
}

#shaderModule shader {
  code="
    struct Uniforms {
      time: f32,
      width: f32,
      height: f32,
      aspect: f32,
    }
    @group(0) @binding(0) var<uniform> u: Uniforms;

    const PI: f32 = 3.14159265359;

    @vertex
    fn vs(@builtin(vertex_index) i: u32) -> @builtin(position) vec4f {
      let x = f32(i & 1u) * 4.0 - 1.0;
      let y = f32((i >> 1u) & 1u) * 4.0 - 1.0;
      return vec4f(x, y, 0.0, 1.0);
    }

    @fragment
    fn fs(@builtin(position) pos: vec4f) -> @location(0) vec4f {
      let uv = vec2f(pos.x / u.width, pos.y / u.height);
      let t = u.time;

      // Classic plasma effect
      let p = uv * 8.0;

      var v = 0.0;
      v += sin(p.x + t);
      v += sin(p.y + t * 0.7);
      v += sin((p.x + p.y) + t * 0.5);

      let cx = p.x + 0.5 * sin(t * 0.5);
      let cy = p.y + 0.5 * cos(t * 0.3);
      v += sin(sqrt(cx * cx + cy * cy + 1.0) + t);

      v = v * 0.5;

      // Color palette
      let r = sin(v * PI) * 0.5 + 0.5;
      let g = sin(v * PI + PI * 0.666) * 0.5 + 0.5;
      let b = sin(v * PI + PI * 1.333) * 0.5 + 0.5;

      return vec4f(r, g, b, 1.0);
    }
  "
}

#renderPipeline pipeline {
  layout=auto
  vertex={ entryPoint=vs module=shader }
  fragment={
    entryPoint=fs
    module=shader
    targets=[{ format=preferredCanvasFormat }]
  }
}

#bindGroup uniformsBindGroup {
  layout={ pipeline=pipeline index=0 }
  entries=[{ binding=0 resource={ buffer=uniforms } }]
}

#renderPass mainPass {
  colorAttachments=[{
    view=contextCurrentTexture
    clearValue=[0 0 0 1]
    loadOp=clear
    storeOp=store
  }]
  pipeline=pipeline
  bindGroups=[uniformsBindGroup]
  draw=3
}

#frame main {
  perform=[writeUniforms mainPass]
}
