// 15 - Heightmap Terrain
// Procedural terrain with compute-generated mesh
// Demonstrates: compute mesh generation, FBM noise, height-based coloring

#define GRID_SIZE=48
#define VERTEX_COUNT="GRID_SIZE * GRID_SIZE"
#define INDEX_COUNT="(GRID_SIZE - 1) * (GRID_SIZE - 1) * 6"

#buffer vertexBuffer {
  size="VERTEX_COUNT * 8 * 4"
  usage=[VERTEX STORAGE]
}

#buffer indexBuffer {
  size="INDEX_COUNT * 4"
  usage=[INDEX STORAGE]
}

#buffer uniforms {
  size=16
  usage=[UNIFORM COPY_DST]
}

#queue writeUniforms {
  writeBuffer={ buffer=uniforms bufferOffset=0 data=pngineInputs }
}

#init initTerrain {
  buffer=vertexBuffer
  shader=initVertexShader
  workgroups=[6 6 1]
}

#init initIndices {
  buffer=indexBuffer
  shader=initIndexShader
  workgroups=[6 6 1]
}

#shaderModule initVertexShader {
  code="
    struct Vertex {
      pos: vec3f,
      normal: vec3f,
      uv: vec2f,
    }
    struct Vertices { data: array<Vertex> }

    @binding(0) @group(0) var<storage, read_write> vertices: Vertices;

    const GRID_SIZE: u32 = 48u;
    const SCALE: f32 = 2.0;
    const HEIGHT_SCALE: f32 = 0.5;

    fn hash(p: vec2f) -> f32 {
      return fract(sin(dot(p, vec2f(127.1, 311.7))) * 43758.5453);
    }

    fn noise(p: vec2f) -> f32 {
      let i = floor(p);
      let f = fract(p);
      let u = f * f * (3.0 - 2.0 * f);
      return mix(
        mix(hash(i + vec2f(0.0, 0.0)), hash(i + vec2f(1.0, 0.0)), u.x),
        mix(hash(i + vec2f(0.0, 1.0)), hash(i + vec2f(1.0, 1.0)), u.x),
        u.y
      );
    }

    fn fbm(p: vec2f) -> f32 {
      var value = 0.0;
      var amp = 0.5;
      var freq = 1.0;
      for (var i = 0u; i < 5u; i++) {
        value += amp * noise(p * freq);
        amp *= 0.5;
        freq *= 2.0;
      }
      return value;
    }

    fn getHeight(uv: vec2f) -> f32 {
      return fbm(uv * 6.0) * HEIGHT_SCALE;
    }

    @compute @workgroup_size(8, 8)
    fn main(@builtin(global_invocation_id) id: vec3u) {
      if (id.x >= GRID_SIZE || id.y >= GRID_SIZE) { return; }

      let idx = id.y * GRID_SIZE + id.x;
      let u = f32(id.x) / f32(GRID_SIZE - 1u);
      let v = f32(id.y) / f32(GRID_SIZE - 1u);
      let uv = vec2f(u, v);

      let x = (u - 0.5) * SCALE;
      let z = (v - 0.5) * SCALE;
      let y = getHeight(uv);

      // Calculate normal from neighbors
      let eps = 1.0 / f32(GRID_SIZE);
      let hL = getHeight(uv + vec2f(-eps, 0.0));
      let hR = getHeight(uv + vec2f(eps, 0.0));
      let hD = getHeight(uv + vec2f(0.0, -eps));
      let hU = getHeight(uv + vec2f(0.0, eps));
      let normal = normalize(vec3f(hL - hR, 2.0 * eps * SCALE, hD - hU));

      vertices.data[idx].pos = vec3f(x, y, z);
      vertices.data[idx].normal = normal;
      vertices.data[idx].uv = uv;
    }
  "
}

#shaderModule initIndexShader {
  code="
    struct Indices { data: array<u32> }

    @binding(0) @group(0) var<storage, read_write> indices: Indices;

    const GRID_SIZE: u32 = 48u;

    @compute @workgroup_size(8, 8)
    fn main(@builtin(global_invocation_id) id: vec3u) {
      if (id.x >= GRID_SIZE - 1u || id.y >= GRID_SIZE - 1u) { return; }

      let quadIdx = id.y * (GRID_SIZE - 1u) + id.x;
      let baseIdx = quadIdx * 6u;

      let tl = id.y * GRID_SIZE + id.x;
      let tr = tl + 1u;
      let bl = tl + GRID_SIZE;
      let br = bl + 1u;

      indices.data[baseIdx + 0u] = tl;
      indices.data[baseIdx + 1u] = bl;
      indices.data[baseIdx + 2u] = tr;
      indices.data[baseIdx + 3u] = tr;
      indices.data[baseIdx + 4u] = bl;
      indices.data[baseIdx + 5u] = br;
    }
  "
}

#shaderModule renderShader {
  code="
    struct Uniforms {
      time: f32,
      width: f32,
      height: f32,
      aspect: f32,
    }
    @group(0) @binding(0) var<uniform> u: Uniforms;

    struct VertexOutput {
      @builtin(position) pos: vec4f,
      @location(0) normal: vec3f,
      @location(1) height: f32,
    }

    fn rotateY(p: vec3f, angle: f32) -> vec3f {
      let c = cos(angle);
      let s = sin(angle);
      return vec3f(p.x * c + p.z * s, p.y, -p.x * s + p.z * c);
    }

    fn rotateX(p: vec3f, angle: f32) -> vec3f {
      let c = cos(angle);
      let s = sin(angle);
      return vec3f(p.x, p.y * c - p.z * s, p.y * s + p.z * c);
    }

    @vertex
    fn vs(
      @location(0) position: vec3f,
      @location(1) normal: vec3f,
      @location(2) uv: vec2f
    ) -> VertexOutput {
      // Rotate terrain
      var pos = position;
      var norm = normal;

      pos = rotateX(pos, 0.5);
      pos = rotateY(pos, u.time * 0.15);
      norm = rotateX(norm, 0.5);
      norm = rotateY(norm, u.time * 0.15);

      // Simple perspective
      let z = pos.z + 2.0;
      let projX = pos.x / z / u.aspect;
      let projY = pos.y / z;
      let depth = (z - 1.0) / 4.0;

      var out: VertexOutput;
      out.pos = vec4f(projX, projY, depth, 1.0);
      out.normal = norm;
      out.height = position.y;
      return out;
    }

    @fragment
    fn fs(in: VertexOutput) -> @location(0) vec4f {
      let lightDir = normalize(vec3f(0.5, 1.0, 0.3));
      let N = normalize(in.normal);
      let diff = max(dot(N, lightDir), 0.0);
      let ambient = 0.2;

      // Height-based coloring
      let water = vec3f(0.1, 0.3, 0.5);
      let sand = vec3f(0.8, 0.7, 0.5);
      let grass = vec3f(0.2, 0.5, 0.15);
      let rock = vec3f(0.4, 0.35, 0.3);
      let snow = vec3f(0.95, 0.95, 1.0);

      var color = water;
      let h = in.height * 4.0;
      if (h > 0.05) { color = mix(sand, grass, clamp((h - 0.05) * 4.0, 0.0, 1.0)); }
      if (h > 0.3) { color = mix(grass, rock, clamp((h - 0.3) * 3.0, 0.0, 1.0)); }
      if (h > 0.6) { color = mix(rock, snow, clamp((h - 0.6) * 3.0, 0.0, 1.0)); }

      let lit = color * (ambient + diff * 0.8);
      return vec4f(lit, 1.0);
    }
  "
}

#renderPipeline pipeline {
  layout=auto
  vertex={
    entryPoint=vs
    module=renderShader
    buffers=[{
      arrayStride=32
      attributes=[
        { shaderLocation=0 offset=0 format=float32x3 }
        { shaderLocation=1 offset=12 format=float32x3 }
        { shaderLocation=2 offset=24 format=float32x2 }
      ]
    }]
  }
  fragment={
    entryPoint=fs
    module=renderShader
    targets=[{ format=preferredCanvasFormat }]
  }
  primitive={ cullMode=back }
  depthStencil={
    format=depth24plus
    depthWriteEnabled=true
    depthCompare=less
  }
}

#texture depthTexture {
  size=[canvasWidth canvasHeight]
  format=depth24plus
  usage=[RENDER_ATTACHMENT]
}

#bindGroup bindings {
  layout={ pipeline=pipeline index=0 }
  entries=[{ binding=0 resource={ buffer=uniforms } }]
}

#renderPass mainPass {
  colorAttachments=[{
    view=contextCurrentTexture
    clearValue=[0.5 0.7 0.9 1]
    loadOp=clear
    storeOp=store
  }]
  depthStencilAttachment={
    view=depthTexture
    depthClearValue=1.0
    depthLoadOp=clear
    depthStoreOp=store
  }
  pipeline=pipeline
  vertexBuffers=[vertexBuffer]
  indexBuffer=indexBuffer
  bindGroups=[bindings]
  drawIndexed=INDEX_COUNT
}

#frame main {
  init=[initTerrain initIndices]
  perform=[writeUniforms mainPass]
}
