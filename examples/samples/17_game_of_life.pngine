// 17 - Game of Life
// Conway's Game of Life using compute shaders with ping-pong buffers
// Demonstrates: cellular automata, ping-pong pattern, compute simulation

#define GRID_SIZE=128

// Cell state buffer (u32 per cell) with ping-pong
#buffer cellBuffer {
  size="GRID_SIZE * GRID_SIZE * 4"
  usage=[STORAGE]
  pool=2
}

#buffer uniforms {
  size=16
  usage=[UNIFORM COPY_DST]
}

#queue writeUniforms {
  writeBuffer={ buffer=uniforms bufferOffset=0 data=pngineInputs }
}

// Initialize with random pattern
#init initCells {
  buffer=cellBuffer
  shader=initShader
  workgroups=[8 8 1]
}

#shaderModule initShader {
  code="
    struct Cells { data: array<u32> }
    @binding(0) @group(0) var<storage, read_write> cells: Cells;

    fn hash(n: u32) -> f32 {
      var x = n;
      x = ((x >> 16u) ^ x) * 0x45d9f3bu;
      x = ((x >> 16u) ^ x) * 0x45d9f3bu;
      x = (x >> 16u) ^ x;
      return f32(x) / f32(0xffffffffu);
    }

    const SIZE: u32 = 128u;

    @compute @workgroup_size(16, 16)
    fn main(@builtin(global_invocation_id) id: vec3u) {
      if (id.x >= SIZE || id.y >= SIZE) { return; }

      let idx = id.y * SIZE + id.x;
      // ~30% chance of being alive
      cells.data[idx] = select(0u, 1u, hash(idx) < 0.3);
    }
  "
}

// Game of Life step shader
#shaderModule stepShader {
  code="
    struct Cells { data: array<u32> }
    @binding(0) @group(0) var<storage, read> cellsIn: Cells;
    @binding(1) @group(0) var<storage, read_write> cellsOut: Cells;

    const SIZE: u32 = 128u;

    fn getCell(x: i32, y: i32) -> u32 {
      let wx = (x + i32(SIZE)) % i32(SIZE);
      let wy = (y + i32(SIZE)) % i32(SIZE);
      return cellsIn.data[u32(wy) * SIZE + u32(wx)];
    }

    @compute @workgroup_size(16, 16)
    fn main(@builtin(global_invocation_id) id: vec3u) {
      if (id.x >= SIZE || id.y >= SIZE) { return; }

      let x = i32(id.x);
      let y = i32(id.y);
      let idx = id.y * SIZE + id.x;

      // Count neighbors (8-way)
      var neighbors = 0u;
      neighbors += getCell(x - 1, y - 1);
      neighbors += getCell(x, y - 1);
      neighbors += getCell(x + 1, y - 1);
      neighbors += getCell(x - 1, y);
      neighbors += getCell(x + 1, y);
      neighbors += getCell(x - 1, y + 1);
      neighbors += getCell(x, y + 1);
      neighbors += getCell(x + 1, y + 1);

      let alive = cellsIn.data[idx];

      // Conway's rules
      var newState = 0u;
      if (alive == 1u) {
        newState = select(0u, 1u, neighbors == 2u || neighbors == 3u);
      } else {
        newState = select(0u, 1u, neighbors == 3u);
      }

      cellsOut.data[idx] = newState;
    }
  "
}

#computePipeline stepPipeline {
  layout=auto
  compute={ entryPoint=main module=stepShader }
}

#bindGroup stepBindGroup {
  layout={ pipeline=stepPipeline index=0 }
  entries=[
    { binding=0 resource={ buffer=cellBuffer pingPong=0 } }
    { binding=1 resource={ buffer=cellBuffer pingPong=1 } }
  ]
  pool=2
}

#computePass stepPass {
  pipeline=stepPipeline
  bindGroups=[stepBindGroup]
  bindGroupsPoolOffsets=[0]
  dispatch=[8 8 1]
}

// Render shader
#shaderModule renderShader {
  code="
    struct Cells { data: array<u32> }
    @group(0) @binding(0) var<storage, read> cells: Cells;

    struct Uniforms {
      time: f32,
      width: f32,
      height: f32,
      aspect: f32,
    }
    @group(0) @binding(1) var<uniform> u: Uniforms;

    const SIZE: f32 = 128.0;

    @vertex
    fn vs(@builtin(vertex_index) i: u32) -> @builtin(position) vec4f {
      let x = f32(i & 1u) * 4.0 - 1.0;
      let y = f32((i >> 1u) & 1u) * 4.0 - 1.0;
      return vec4f(x, y, 0.0, 1.0);
    }

    @fragment
    fn fs(@builtin(position) pos: vec4f) -> @location(0) vec4f {
      let cellX = u32(pos.x * SIZE / u.width);
      let cellY = u32(pos.y * SIZE / u.height);
      let idx = cellY * u32(SIZE) + cellX;

      if (idx >= u32(SIZE * SIZE)) {
        return vec4f(0.1, 0.1, 0.15, 1.0);
      }

      let alive = cells.data[idx];
      let color = select(vec3f(0.1, 0.1, 0.15), vec3f(0.2, 0.8, 0.3), alive == 1u);
      return vec4f(color, 1.0);
    }
  "
}

#renderPipeline renderPipeline {
  layout=auto
  vertex={ entryPoint=vs module=renderShader }
  fragment={
    entryPoint=fs
    module=renderShader
    targets=[{ format=preferredCanvasFormat }]
  }
}

#bindGroup renderBindGroup {
  layout={ pipeline=renderPipeline index=0 }
  entries=[
    { binding=0 resource={ buffer=cellBuffer pingPong=1 } }
    { binding=1 resource={ buffer=uniforms } }
  ]
  pool=2
}

#renderPass drawPass {
  colorAttachments=[{
    view=contextCurrentTexture
    clearValue=[0.1 0.1 0.15 1]
    loadOp=clear
    storeOp=store
  }]
  pipeline=renderPipeline
  bindGroups=[renderBindGroup]
  bindGroupsPoolOffsets=[0]
  draw=3
}

#frame main {
  init=[initCells]
  perform=[writeUniforms stepPass drawPass]
}
