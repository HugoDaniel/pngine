// 10 - Animated Mesh
// GPU-driven vertex animation with wave deformation
// Demonstrates: compute shader vertex animation, ping-pong buffers, dynamic normals

#define GRID_SIZE=32
#define VERTEX_COUNT="GRID_SIZE * GRID_SIZE"
#define INDEX_COUNT="(GRID_SIZE - 1) * (GRID_SIZE - 1) * 6"

// Vertex buffer: pos(3) + normal(3) = 6 floats per vertex
#buffer vertexBuffer {
  size="VERTEX_COUNT * 6 * 4"
  usage=[VERTEX STORAGE]
  pool=2
}

// Index buffer for triangulated grid
#buffer indexBuffer {
  size="INDEX_COUNT * 4"
  usage=[INDEX STORAGE]
}

#buffer uniforms {
  size=16
  usage=[UNIFORM COPY_DST]
}

#queue writeUniforms {
  writeBuffer={ buffer=uniforms bufferOffset=0 data=pngineInputs }
}

// Initialize grid positions
#init initMesh {
  buffer=vertexBuffer
  shader=initShader
  workgroups=[4 4 1]
}

// Initialize index buffer
#init initIndices {
  buffer=indexBuffer
  shader=initIndexShader
  workgroups=[4 4 1]
}

#shaderModule initShader {
  code="
    struct Vertex {
      pos: vec3f,
      normal: vec3f,
    }
    struct Vertices { data: array<Vertex> }

    @binding(0) @group(0) var<storage, read_write> verts: Vertices;

    const GRID_SIZE: u32 = 32u;

    @compute @workgroup_size(8, 8)
    fn main(@builtin(global_invocation_id) id: vec3u) {
      if (id.x >= GRID_SIZE || id.y >= GRID_SIZE) { return; }

      let idx = id.y * GRID_SIZE + id.x;
      let u = f32(id.x) / f32(GRID_SIZE - 1u) - 0.5;
      let v = f32(id.y) / f32(GRID_SIZE - 1u) - 0.5;

      verts.data[idx].pos = vec3f(u * 2.0, 0.0, v * 2.0);
      verts.data[idx].normal = vec3f(0.0, 1.0, 0.0);
    }
  "
}

#shaderModule initIndexShader {
  code="
    struct Indices { data: array<u32> }

    @binding(0) @group(0) var<storage, read_write> indices: Indices;

    const GRID_SIZE: u32 = 32u;

    @compute @workgroup_size(8, 8)
    fn main(@builtin(global_invocation_id) id: vec3u) {
      let x = id.x;
      let y = id.y;

      if (x >= GRID_SIZE - 1u || y >= GRID_SIZE - 1u) { return; }

      let quadIdx = y * (GRID_SIZE - 1u) + x;
      let baseIdx = quadIdx * 6u;

      let v00 = y * GRID_SIZE + x;
      let v10 = y * GRID_SIZE + x + 1u;
      let v01 = (y + 1u) * GRID_SIZE + x;
      let v11 = (y + 1u) * GRID_SIZE + x + 1u;

      // Two triangles per quad
      indices.data[baseIdx + 0u] = v00;
      indices.data[baseIdx + 1u] = v10;
      indices.data[baseIdx + 2u] = v01;
      indices.data[baseIdx + 3u] = v10;
      indices.data[baseIdx + 4u] = v11;
      indices.data[baseIdx + 5u] = v01;
    }
  "
}

#shaderModule animShader {
  code="
    struct Uniforms {
      time: f32,
      width: f32,
      height: f32,
      aspect: f32,
    }
    @group(0) @binding(0) var<uniform> u: Uniforms;

    struct Vertex {
      pos: vec3f,
      normal: vec3f,
    }
    struct Vertices { data: array<Vertex> }

    @group(0) @binding(1) var<storage, read> vertsIn: Vertices;
    @group(0) @binding(2) var<storage, read_write> vertsOut: Vertices;

    const GRID_SIZE: u32 = 32u;
    const PI: f32 = 3.14159265359;

    @compute @workgroup_size(8, 8)
    fn main(@builtin(global_invocation_id) id: vec3u) {
      if (id.x >= GRID_SIZE || id.y >= GRID_SIZE) { return; }

      let idx = id.y * GRID_SIZE + id.x;
      let basePos = vertsIn.data[idx].pos;

      // Multiple wave components for interesting motion
      let wave1 = sin(basePos.x * 4.0 + u.time * 2.0) * 0.12;
      let wave2 = sin(basePos.z * 3.5 + u.time * 1.7) * 0.1;
      let wave3 = sin((basePos.x + basePos.z) * 2.5 + u.time * 1.2) * 0.06;
      let wave4 = sin(length(basePos.xz) * 5.0 - u.time * 3.0) * 0.05;

      let height = wave1 + wave2 + wave3 + wave4;

      // Compute normal from gradient
      let eps = 0.1;
      let hL = sin((basePos.x - eps) * 4.0 + u.time * 2.0) * 0.12 +
               sin(basePos.z * 3.5 + u.time * 1.7) * 0.1 +
               sin((basePos.x - eps + basePos.z) * 2.5 + u.time * 1.2) * 0.06 +
               sin(length(vec2f(basePos.x - eps, basePos.z)) * 5.0 - u.time * 3.0) * 0.05;

      let hR = sin((basePos.x + eps) * 4.0 + u.time * 2.0) * 0.12 +
               sin(basePos.z * 3.5 + u.time * 1.7) * 0.1 +
               sin((basePos.x + eps + basePos.z) * 2.5 + u.time * 1.2) * 0.06 +
               sin(length(vec2f(basePos.x + eps, basePos.z)) * 5.0 - u.time * 3.0) * 0.05;

      let hD = sin(basePos.x * 4.0 + u.time * 2.0) * 0.12 +
               sin((basePos.z - eps) * 3.5 + u.time * 1.7) * 0.1 +
               sin((basePos.x + basePos.z - eps) * 2.5 + u.time * 1.2) * 0.06 +
               sin(length(vec2f(basePos.x, basePos.z - eps)) * 5.0 - u.time * 3.0) * 0.05;

      let hU = sin(basePos.x * 4.0 + u.time * 2.0) * 0.12 +
               sin((basePos.z + eps) * 3.5 + u.time * 1.7) * 0.1 +
               sin((basePos.x + basePos.z + eps) * 2.5 + u.time * 1.2) * 0.06 +
               sin(length(vec2f(basePos.x, basePos.z + eps)) * 5.0 - u.time * 3.0) * 0.05;

      let normal = normalize(vec3f(hL - hR, 2.0 * eps, hD - hU));

      vertsOut.data[idx].pos = vec3f(basePos.x, height, basePos.z);
      vertsOut.data[idx].normal = normal;
    }
  "
}

#computePipeline animPipeline {
  layout=auto
  compute={ entryPoint=main module=animShader }
}

#bindGroup animBindGroup {
  layout={ pipeline=animPipeline index=0 }
  entries=[
    { binding=0 resource={ buffer=uniforms } }
    { binding=1 resource={ buffer=vertexBuffer pingPong=0 } }
    { binding=2 resource={ buffer=vertexBuffer pingPong=1 } }
  ]
  pool=2
}

#computePass animPass {
  pipeline=animPipeline
  bindGroups=[animBindGroup]
  bindGroupsPoolOffsets=[0]
  dispatch=[4 4 1]
}

#shaderModule renderShader {
  code="
    struct Uniforms {
      time: f32,
      width: f32,
      height: f32,
      aspect: f32,
    }
    @group(0) @binding(0) var<uniform> u: Uniforms;

    struct VertexOutput {
      @builtin(position) pos: vec4f,
      @location(0) normal: vec3f,
      @location(1) worldPos: vec3f,
    }

    fn rotateY(p: vec3f, angle: f32) -> vec3f {
      let c = cos(angle);
      let s = sin(angle);
      return vec3f(p.x * c + p.z * s, p.y, -p.x * s + p.z * c);
    }

    fn rotateX(p: vec3f, angle: f32) -> vec3f {
      let c = cos(angle);
      let s = sin(angle);
      return vec3f(p.x, p.y * c - p.z * s, p.y * s + p.z * c);
    }

    @vertex
    fn vs(
      @location(0) position: vec3f,
      @location(1) normal: vec3f
    ) -> VertexOutput {
      // Rotate mesh for better view
      var pos = position * 0.5;
      var norm = normal;

      pos = rotateX(pos, 0.5);
      pos = rotateY(pos, u.time * 0.2);
      norm = rotateX(norm, 0.5);
      norm = rotateY(norm, u.time * 0.2);

      // Simple perspective
      let z = pos.z + 2.0;
      let projX = pos.x / z / u.aspect;
      let projY = pos.y / z;
      let depth = (z - 1.0) / 4.0;

      var out: VertexOutput;
      out.pos = vec4f(projX, projY, depth, 1.0);
      out.normal = norm;
      out.worldPos = pos;
      return out;
    }

    @fragment
    fn fs(in: VertexOutput) -> @location(0) vec4f {
      let lightDir = normalize(vec3f(0.5, 1.0, 0.3));
      let N = normalize(in.normal);

      let diffuse = max(dot(N, lightDir), 0.0);
      let ambient = 0.15;

      // Color based on height
      let heightColor = mix(
        vec3f(0.1, 0.3, 0.6),
        vec3f(0.4, 0.8, 1.0),
        clamp(in.worldPos.y * 3.0 + 0.5, 0.0, 1.0)
      );

      let lit = heightColor * (ambient + diffuse * 0.85);
      return vec4f(lit, 1.0);
    }
  "
}

#renderPipeline renderPipeline {
  layout=auto
  vertex={
    entryPoint=vs
    module=renderShader
    buffers=[{
      arrayStride=24
      attributes=[
        { shaderLocation=0 offset=0 format=float32x3 }
        { shaderLocation=1 offset=12 format=float32x3 }
      ]
    }]
  }
  fragment={
    entryPoint=fs
    module=renderShader
    targets=[{ format=preferredCanvasFormat }]
  }
  primitive={ cullMode=back }
  depthStencil={
    format=depth24plus
    depthWriteEnabled=true
    depthCompare=less
  }
}

#texture depthTexture {
  size=[canvasWidth canvasHeight]
  format=depth24plus
  usage=[RENDER_ATTACHMENT]
}

#bindGroup renderBindGroup {
  layout={ pipeline=renderPipeline index=0 }
  entries=[{ binding=0 resource={ buffer=uniforms } }]
}

#renderPass drawPass {
  colorAttachments=[{
    view=contextCurrentTexture
    clearValue=[0.02 0.02 0.05 1]
    loadOp=clear
    storeOp=store
  }]
  depthStencilAttachment={
    view=depthTexture
    depthClearValue=1.0
    depthLoadOp=clear
    depthStoreOp=store
  }
  pipeline=renderPipeline
  vertexBuffers=[{ buffer=vertexBuffer pingPong=1 }]
  indexBuffer=indexBuffer
  bindGroups=[renderBindGroup]
  drawIndexed=INDEX_COUNT
}

#frame main {
  init=[initMesh initIndices]
  perform=[writeUniforms animPass drawPass]
}
