// 27 - Color Cycling / Palette Animation
// Time-based color effects using HSV manipulation
// Demonstrates: HSV color space, palette cycling, smooth transitions

#buffer uniforms {
  size=16
  usage=[UNIFORM COPY_DST]
}

#queue writeUniforms {
  writeBuffer={ buffer=uniforms bufferOffset=0 data=pngineInputs }
}

#shaderModule shader {
  code="
    struct Uniforms {
      time: f32,
      width: f32,
      height: f32,
      aspect: f32,
    }
    @group(0) @binding(0) var<uniform> u: Uniforms;

    const PI: f32 = 3.14159265359;

    fn hsv2rgb(h: f32, s: f32, v: f32) -> vec3f {
      let c = v * s;
      let x = c * (1.0 - abs(fract(h * 6.0) * 2.0 - 1.0));
      let m = v - c;

      var rgb = vec3f(0.0);
      let hi = u32(h * 6.0) % 6u;
      if (hi == 0u) { rgb = vec3f(c, x, 0.0); }
      else if (hi == 1u) { rgb = vec3f(x, c, 0.0); }
      else if (hi == 2u) { rgb = vec3f(0.0, c, x); }
      else if (hi == 3u) { rgb = vec3f(0.0, x, c); }
      else if (hi == 4u) { rgb = vec3f(x, 0.0, c); }
      else { rgb = vec3f(c, 0.0, x); }

      return rgb + m;
    }

    @vertex
    fn vs(@builtin(vertex_index) i: u32) -> @builtin(position) vec4f {
      let x = f32(i & 1u) * 4.0 - 1.0;
      let y = f32((i >> 1u) & 1u) * 4.0 - 1.0;
      return vec4f(x, y, 0.0, 1.0);
    }

    @fragment
    fn fs(@builtin(position) pos: vec4f) -> @location(0) vec4f {
      let uv = vec2f(pos.x / u.width, pos.y / u.height);
      let t = u.time;

      // Different patterns based on time
      let mode = u32(t * 0.15) % 4u;

      var color = vec3f(0.0);

      if (mode == 0u) {
        // Plasma pattern
        let p = uv * 8.0;
        let v1 = sin(p.x + t);
        let v2 = sin(10.0 * (p.x * sin(t * 0.5) + p.y * cos(t * 0.3)));
        let cx = p.x + 0.5 * sin(t * 0.3);
        let cy = p.y + 0.5 * cos(t * 0.4);
        let v3 = sin(sqrt(100.0 * (cx * cx + cy * cy) + 1.0) + t);
        let idx = (v1 + v2 + v3) / 3.0 * 0.5 + 0.5;

        let hue = fract(idx + t * 0.1);
        color = hsv2rgb(hue, 0.8, 0.9);
      } else if (mode == 1u) {
        // Concentric rings
        let dist = length(uv - 0.5);
        let idx = fract(dist * 10.0 - t * 0.5);
        let hue = fract(idx + t * 0.05);
        color = hsv2rgb(hue, 0.7, 0.85);
      } else if (mode == 2u) {
        // Diagonal stripes
        let idx = fract((uv.x + uv.y) * 8.0 - t * 0.3);
        let hue = fract(idx + t * 0.08);
        color = hsv2rgb(hue, 0.75, 0.9);
      } else {
        // Radial rainbow
        let centered = uv - 0.5;
        let angle = atan2(centered.y, centered.x) / (2.0 * PI) + 0.5;
        let hue = fract(angle + t * 0.15);
        let dist = length(centered) * 2.0;
        color = hsv2rgb(hue, 0.9 - dist * 0.3, 0.95);
      }

      return vec4f(color, 1.0);
    }
  "
}

#renderPipeline pipeline {
  layout=auto
  vertex={ entryPoint=vs module=shader }
  fragment={
    entryPoint=fs
    module=shader
    targets=[{ format=preferredCanvasFormat }]
  }
}

#bindGroup uniformsBindGroup {
  layout={ pipeline=pipeline index=0 }
  entries=[{ binding=0 resource={ buffer=uniforms } }]
}

#renderPass mainPass {
  colorAttachments=[{
    view=contextCurrentTexture
    clearValue=[0 0 0 1]
    loadOp=clear
    storeOp=store
  }]
  pipeline=pipeline
  bindGroups=[uniformsBindGroup]
  draw=3
}

#frame main {
  perform=[writeUniforms mainPass]
}
