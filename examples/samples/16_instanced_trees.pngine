// 16 - Instanced Trees
// Render many instances with a single draw call
// Demonstrates: instanced rendering, compute init, depth testing

#define NUM_TREES=400

// Tree instance data: pos(3) + scale(1) + rotation(1) + colorTint(3) = 8 floats
#buffer instanceBuffer {
  size="NUM_TREES * 8 * 4"
  usage=[VERTEX STORAGE]
}

#buffer uniforms {
  size=16
  usage=[UNIFORM COPY_DST]
}

#queue writeUniforms {
  writeBuffer={ buffer=uniforms bufferOffset=0 data=pngineInputs }
}

// Initialize tree positions with compute shader
#init initTrees {
  buffer=instanceBuffer
  shader=initShader
  workgroups=7
}

#shaderModule initShader {
  code="
    struct Tree {
      pos: vec3f,
      scale: f32,
      rotation: f32,
      colorTint: vec3f,
    }
    struct Trees { data: array<Tree> }

    @binding(0) @group(0) var<storage, read_write> trees: Trees;

    fn hash(n: u32) -> f32 {
      var x = n;
      x = ((x >> 16u) ^ x) * 0x45d9f3bu;
      x = ((x >> 16u) ^ x) * 0x45d9f3bu;
      x = (x >> 16u) ^ x;
      return f32(x) / f32(0xffffffffu);
    }

    const NUM: u32 = 400u;
    const PI: f32 = 3.14159265359;

    @compute @workgroup_size(64)
    fn main(@builtin(global_invocation_id) id: vec3u) {
      let i = id.x;
      if (i >= NUM) { return; }

      // Random position in a large area
      let x = (hash(i * 7u) - 0.5) * 4.0;
      let z = (hash(i * 11u) - 0.5) * 4.0 - 2.0;  // Offset back
      let y = -0.5;  // Ground level

      trees.data[i].pos = vec3f(x, y, z);
      trees.data[i].scale = 0.1 + hash(i * 13u) * 0.15;
      trees.data[i].rotation = hash(i * 17u) * PI * 2.0;

      // Green tint variations
      trees.data[i].colorTint = vec3f(
        0.2 + hash(i * 19u) * 0.2,
        0.5 + hash(i * 23u) * 0.3,
        0.1 + hash(i * 29u) * 0.15
      );
    }
  "
}

// Simple tree mesh: trunk (6 vertices) + foliage cone (3 vertices)
#data treeMesh {
  float32Array=[
    // Trunk (quad as 2 triangles) - brown
    -0.05 0.0 0.0   0.6 0.3 0.1
    0.05 0.0 0.0    0.6 0.3 0.1
    0.05 0.4 0.0    0.5 0.25 0.1
    -0.05 0.0 0.0   0.6 0.3 0.1
    0.05 0.4 0.0    0.5 0.25 0.1
    -0.05 0.4 0.0   0.5 0.25 0.1
    // Foliage (triangle) - uses instance color
    -0.2 0.3 0.0    0.0 0.0 0.0
    0.2 0.3 0.0     0.0 0.0 0.0
    0.0 0.8 0.0     0.0 0.0 0.0
    // Second foliage layer
    -0.15 0.45 0.0  0.0 0.0 0.0
    0.15 0.45 0.0   0.0 0.0 0.0
    0.0 0.95 0.0    0.0 0.0 0.0
  ]
}

#buffer treeBuffer {
  size=treeMesh
  usage=[VERTEX]
  mappedAtCreation=treeMesh
}

#shaderModule renderShader {
  code="
    struct Uniforms {
      time: f32,
      width: f32,
      height: f32,
      aspect: f32,
    }
    @group(0) @binding(0) var<uniform> u: Uniforms;

    struct VertexOutput {
      @builtin(position) pos: vec4f,
      @location(0) color: vec3f,
    }

    @vertex
    fn vs(
      @location(0) localPos: vec3f,
      @location(1) localColor: vec3f,
      @location(2) instPos: vec3f,
      @location(3) instScale: f32,
      @location(4) instRotation: f32,
      @location(5) instColorTint: vec3f
    ) -> VertexOutput {
      // Apply instance transform
      let c = cos(instRotation);
      let s = sin(instRotation);

      var pos = localPos * instScale;

      // Rotate around Y axis
      let rx = pos.x * c - pos.z * s;
      let rz = pos.x * s + pos.z * c;
      pos = vec3f(rx, pos.y, rz);

      pos += instPos;

      // Wind sway for foliage (vertices above y=0.3)
      if (localPos.y > 0.25) {
        let sway = sin(u.time * 2.0 + instPos.x * 3.0) * 0.02 * (localPos.y - 0.25);
        pos.x += sway;
      }

      // Simple perspective projection
      let z = pos.z + 3.0;
      let projX = pos.x / z / u.aspect;
      let projY = pos.y / z;
      let depth = 1.0 - (z / 6.0);

      var out: VertexOutput;
      out.pos = vec4f(projX, projY, depth, 1.0);

      // Use local color for trunk, instance tint for foliage
      if (length(localColor) > 0.1) {
        out.color = localColor;  // Trunk
      } else {
        out.color = instColorTint;  // Foliage
      }

      return out;
    }

    @fragment
    fn fs(in: VertexOutput) -> @location(0) vec4f {
      return vec4f(in.color, 1.0);
    }
  "
}

#renderPipeline renderPipeline {
  layout=auto
  vertex={
    entryPoint=vs
    module=renderShader
    buffers=[
      {
        arrayStride=24
        stepMode=vertex
        attributes=[
          { shaderLocation=0 offset=0 format=float32x3 }
          { shaderLocation=1 offset=12 format=float32x3 }
        ]
      }
      {
        arrayStride=32
        stepMode=instance
        attributes=[
          { shaderLocation=2 offset=0 format=float32x3 }
          { shaderLocation=3 offset=12 format=float32 }
          { shaderLocation=4 offset=16 format=float32 }
          { shaderLocation=5 offset=20 format=float32x3 }
        ]
      }
    ]
  }
  fragment={
    entryPoint=fs
    module=renderShader
    targets=[{ format=preferredCanvasFormat }]
  }
  depthStencil={
    format=depth24plus
    depthWriteEnabled=true
    depthCompare=less
  }
}

#texture depthTexture {
  size=[canvasWidth canvasHeight]
  format=depth24plus
  usage=[RENDER_ATTACHMENT]
}

#bindGroup uniformsBindGroup {
  layout={ pipeline=renderPipeline index=0 }
  entries=[{ binding=0 resource={ buffer=uniforms } }]
}

#renderPass mainPass {
  colorAttachments=[{
    view=contextCurrentTexture
    clearValue=[0.5 0.7 0.9 1]
    loadOp=clear
    storeOp=store
  }]
  depthStencilAttachment={
    view=depthTexture
    depthClearValue=1.0
    depthLoadOp=clear
    depthStoreOp=store
  }
  pipeline=renderPipeline
  vertexBuffers=[treeBuffer instanceBuffer]
  bindGroups=[uniformsBindGroup]
  draw={
    vertexCount=12
    instanceCount=NUM_TREES
  }
}

#frame main {
  init=[initTrees]
  perform=[writeUniforms mainPass]
}
