#define SAMPLE_COUNT=4

#renderPipeline pipeline {
  layout=auto
  vertex={ entrypoint=vertexMain module=code }
  fragment={
    entrypoint=fragMain
    module=code
    targets=[{ format=preferredCanvasFormat }]
  }
  primitive={ topology=triangle-list }
  multisample=SAMPLE_COUNT
}

#texture tex {
  size=[canvas.width canvas.height]
  sampleCount=SAMPLE_COUNT
  format=preferredCanvasFormat
  usage=[RENDER_ATTACHMENT]
}

#renderPass drawTriangle {
  colorAttachments=[{
    view=tex
    resolveTarget=contextCurrentTexture
    clearValue=[0 0 0 0]
    loadOp=clear
    storeOp=discard
  }]
  pipeline=pipeline
  bindGroups=[inputsBinding]
  draw=3
}

#frame msaaTriangle {
  perform=[
    writeInputUniforms
    drawTriangle
  ]
}

#buffer uniformInputsBuffer {
  size=4
  usage=[UNIFORM COPY_DST]
}

#queue writeInputUniforms {
  writeBuffer={
    buffer=uniformInputsBuffer
    bufferOffset=0
    data="$uniforms.code.inputs.data"
  }
}

#bindGroup inputsBinding {
  layout={ pipeline=pipeline index=0 }
  entries=[
    { binding=0 resource={ buffer=uniformInputsBuffer }}
  ]
}

#shaderModule code {
  code="
struct PngineInputs {
  time: f32,
};
@binding(0) @group(0) var<uniform> inputs : PngineInputs;

@vertex
fn vertexMain(
  @builtin(vertex_index) VertexIndex : u32
) -> @builtin(position) vec4f {
  var pos = array<vec2f, 3>(
    vec2(sin(inputs.time * 8.0) * 0.25, 0.5),
    vec2(-0.5, -0.5),
    vec2(0.5, -0.5)
  );

  return vec4f(pos[VertexIndex], 0.0, 1.0);
}

@fragment
fn fragMain() -> @location(0) vec4f {
  return vec4(abs(sin(inputs.time)), abs(cos(inputs.time)), 0.0, 1.0);
}
"
}

