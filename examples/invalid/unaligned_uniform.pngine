// Invalid example: Uniform buffer with unaligned size
// Detection: WebGPU runtime (buffer binding validation fails)
// Validator: Passes - alignment checks happen in browser/GPU
// Note: WebGPU requires minUniformBufferOffsetAlignment (usually 256 bytes)

#data uniforms {
  // 12 bytes - NOT 16-byte aligned (uniforms require 16-byte alignment)
  float32Array=[1.0 2.0 3.0]
}

#buffer uniformBuffer {
  // ERROR: Size 12 is not 16-byte aligned for UNIFORM usage
  size = 12
  usage = [UNIFORM COPY_DST]
  mappedAtCreation = uniforms
}

#renderPipeline pipeline {
  layout=auto
  vertex={ entryPoint=vertexMain module=code }
  fragment={
    entryPoint=fragMain
    module=code
    targets=[{ format=preferredCanvasFormat }]
  }
  primitive={ topology=triangle-list }
}

#bindGroupLayout uniformLayout {
  entries=[{
    binding=0
    visibility=[FRAGMENT]
    buffer={ type=uniform }
  }]
}

#bindGroup uniformGroup {
  layout=uniformLayout
  entries=[{ binding=0 buffer=uniformBuffer }]
}

#renderPass render {
  colorAttachments=[{
    view=contextCurrentTexture
    clearValue=[0, 0, 0, 0]
    loadOp=clear
    storeOp=store
  }]
  pipeline=pipeline
  bindGroups=[uniformGroup]
  draw=3
}

#frame unalignedUniform {
  perform=[render]
}

#shaderModule code {
  code="
    struct Uniforms {
        values: vec3f,
    }

    @group(0) @binding(0) var<uniform> uniforms: Uniforms;

    @vertex
    fn vertexMain(
      @builtin(vertex_index) VertexIndex : u32
    ) -> @builtin(position) vec4f {
      var pos = array<vec2f, 3>(
        vec2(0.0, 0.5),
        vec2(-0.5, -0.5),
        vec2(0.5, -0.5)
      );
      return vec4f(pos[VertexIndex], 0.0, 1.0);
    }

    @fragment
    fn fragMain() -> @location(0) vec4f {
      return vec4(uniforms.values.x, uniforms.values.y, uniforms.values.z, 1.0);
    }
  "
}
