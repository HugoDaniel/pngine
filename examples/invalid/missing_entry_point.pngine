// Invalid example: Pipeline references non-existent entry point
// Detection: WebGPU runtime (device.createRenderPipeline fails)
// Validator: Passes - entry point validation happens in browser/GPU

#renderPipeline pipeline {
  layout=auto
  vertex={ entryPoint=nonExistentVertex module=code }
  fragment={
    entryPoint=fragMain
    module=code
    targets=[{ format=preferredCanvasFormat }]
  }
  primitive={ topology=triangle-list }
}

#renderPass renderPipeline {
  colorAttachments=[{
    view=contextCurrentTexture
    clearValue=[0, 0, 0, 0]
    loadOp=clear
    storeOp=store
  }]
  pipeline=pipeline
  draw=3
}

#frame missingEntry {
  perform=[renderPipeline]
}

#shaderModule code {
  code="
    // Note: Entry point is 'vertexMain' but pipeline references 'nonExistentVertex'
    @vertex
    fn vertexMain(
      @builtin(vertex_index) VertexIndex : u32
    ) -> @builtin(position) vec4f {
      var pos = array<vec2f, 3>(
        vec2(0.0, 0.5),
        vec2(-0.5, -0.5),
        vec2(0.5, -0.5)
      );
      return vec4f(pos[VertexIndex], 0.0, 1.0);
    }

    @fragment
    fn fragMain() -> @location(0) vec4f {
      return vec4(1.0, 0.0, 0.0, 1.0);
    }
  "
}
