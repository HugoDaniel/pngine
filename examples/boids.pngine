#define NUM_PARTICLES=2048
#renderPipeline renderBoids {
  layout=auto
  vertex={
    entrypoint=vertexMain
    module=code 
    buffers= [
      // instanced particles buffer:
      {
        arrayStride = "4*4"
        stepMode=instance
        attributes=[

          // instance position:
          { shaderLocation=0 offset=0 format=float32x2 }

          // instance velocity
          { shaderLocation=1 offset="2*4" format=float32x2 }

        ]
      }

      // vertex buffer
      {
        arrayStride="2*4"
        stepMode=vertex
        attributes=[

          // vertex positions
          { shaderLocation=2 offset=0 format=float32x2 }

        ]
      }
    ]
  }

  fragment={
    entrypoint=fragMain
    module=code 
    targets=[{ format=preferredCanvasFormat }]
  }
  primitive={
    topology=triangle-list
  }
}

#computePipeline computeBoids {
  layout=auto
  compute={
    entrypoint=computeMain
  }
}

#renderPass drawBoidsPass {
  colorAttachments=[{
    view=contextCurrentTexture
    clearValue=[0.0 0.0 0.0 1.0]
    loadOp=clear
    storeOp=store
  }]
  pipeline=renderBoids
  vertexBuffers=[particleBuffers, spriteVertexBuffer]
  // Optionally set the pool offset at each vertex buffer: vertexBuffersPoolOffsets=[0]
  // non pooled bind groups will be left as is regardless of the value set
  vertexBuffersPoolOffsets=[1, 0]
  draw={
    vertexCount=3
    instanceCount=NUM_PARTICLES
    firstVertex=0
    firstInstance=0
  }
}

#computePass computeBoidsPass {
  pipeline=computeBoids
  bindGroups=[particleBindGroups]
  // Optionally set the pool offset at each bind group: bindGroupsPoolOffsets=[0]
  // non pooled bind groups will be left as is regardless of the value set
  dispatchWorkgroups="ceil(NUM_PARTICLES / 64)"
}

#data vertexBufferData {
  float32Array=[
  -0.01 -0.02 0.01
  -0.02 0.0 0.02
]}

#buffer spriteVertexBuffer {
  size  = vertexBufferData
  usage = [VERTEX]
  mappedAtCreation=vertexBufferData
}

#buffer simParamBuffer {
  size="7*4"
  usage=[UNIFORM COPY_DST]
}
#data simParamsData {
  float32Array=[
  // deltaT:
  0.04,
  // rule1Distance:
  0.1,
  // rule2Distance:
  0.025,
  // rule3Distance:
  0.025,
  // rule1Scale:
  0.02,
  // rule2Scale:
  0.05,
  // rule3Scale:
  0.005
]}

#queue updateSimParams {
  writeBuffer={
    buffer=simParamBuffer
    bufferOffset=0
    data=simParamsData
  }
}


#data initialParticleData {
  float32Array={
    numberOfElements=NUM_PARTICLES 
    initEachElementWith=[
    // position:
      "cos((ELEMENT_ID / NUM_PARTICLES) * PI * 2) * sqrt(ELEMENT_ID / NUM_PARTICLES)"
      "sin((ELEMENT_ID / NUM_PARTICLES) * PI * 2) * sqrt(ELEMENT_ID / NUM_PARTICLES)"
    // velocity:
      "random()"
      "random()"
    ]
  }
}

#buffer particleBuffers {
  size = initialParticleData
  usage = [VERTEX STORAGE]
  mappedAtCreation = initialParticleData
  pool=2
}

#bindGroup particleBindGroups {
  layout={ pipeline=computeBoids index=0 }
  entries=[
    { binding=0 resource={ buffer=simParamBuffer }}
    { binding=1 resource={ buffer=particleBuffers size=initialParticleData pingPong=0 }}
    { binding=2 resource={ buffer=particleBuffers size=initialParticleData pingPong=1 }}
  ]
  pool=2
}

#frame boids {
  before=[
    updateSimParams
  ]
  perform=[
    computeBoidsPass
    drawBoidsPass
  ]
}

#shaderModule code {
  code="
struct Particle {
  pos : vec2f,
  vel : vec2f,
}
struct SimParams {
  deltaT : f32,
  rule1Distance : f32,
  rule2Distance : f32,
  rule3Distance : f32,
  rule1Scale : f32,
  rule2Scale : f32,
  rule3Scale : f32,
}

struct Particles {
  particles : array<Particle>,
}

@binding(0) @group(0) var<uniform> params : SimParams;
@binding(1) @group(0) var<storage, read> particlesA : Particles;
@binding(2) @group(0) var<storage, read_write> particlesB : Particles;

// https://github.com/austinEng/Project6-Vulkan-Flocking/blob/master/data/shaders/computeparticles/particle.comp
@compute @workgroup_size(64)
fn computeMain(@builtin(global_invocation_id) GlobalInvocationID : vec3u) {
  var index = GlobalInvocationID.x;

  var vPos = particlesA.particles[index].pos;
  var vVel = particlesA.particles[index].vel;
  var cMass = vec2(0.0);
  var cVel = vec2(0.0);
  var colVel = vec2(0.0);
  var cMassCount = 0u;
  var cVelCount = 0u;
  var pos : vec2f;
  var vel : vec2f;

  for (var i = 0u; i < arrayLength(&particlesA.particles); i++) {
    if (i == index) {
      continue;
    }

    pos = particlesA.particles[i].pos.xy;
    vel = particlesA.particles[i].vel.xy;
    if (distance(pos, vPos) < params.rule1Distance) {
      cMass += pos;
      cMassCount++;
    }
    if (distance(pos, vPos) < params.rule2Distance) {
      colVel -= pos - vPos;
    }
    if (distance(pos, vPos) < params.rule3Distance) {
      cVel += vel;
      cVelCount++;
    }
  }
  if (cMassCount > 0) {
    cMass = (cMass / vec2(f32(cMassCount))) - vPos;
  }
  if (cVelCount > 0) {
    cVel /= f32(cVelCount);
  }
  vVel += (cMass * params.rule1Scale) + (colVel * params.rule2Scale) + (cVel * params.rule3Scale);

  // clamp velocity for a more pleasing simulation
  vVel = normalize(vVel) * clamp(length(vVel), 0.0, 0.1);
  // kinematic update
  vPos = vPos + (vVel * params.deltaT);
  // Wrap around boundary
  if (vPos.x < -1.0) {
    vPos.x = 1.0;
  }
  if (vPos.x > 1.0) {
    vPos.x = -1.0;
  }
  if (vPos.y < -1.0) {
    vPos.y = 1.0;
  }
  if (vPos.y > 1.0) {
    vPos.y = -1.0;
  }
  // Write back
  particlesB.particles[index].pos = vPos;
  particlesB.particles[index].vel = vVel;
}


struct VertexOutput {
  @builtin(position) position : vec4f,
  @location(4) color : vec4f,
}

@vertex
fn vertexMain(
  @location(0) a_particlePos : vec2f,
  @location(1) a_particleVel : vec2f,
  @location(2) a_pos : vec2f
) -> VertexOutput {
  let angle = -atan2(a_particleVel.x, a_particleVel.y);
  let pos = vec2(
    (a_pos.x * cos(angle)) - (a_pos.y * sin(angle)),
    (a_pos.x * sin(angle)) + (a_pos.y * cos(angle))
  );
  
  var output : VertexOutput;
  output.position = vec4(pos + a_particlePos, 0.0, 1.0);
  output.color = vec4(
    0.75, 0.33, 0.55,
    // 1.0 - sin(angle + 1.0) - a_particleVel.y,
    // pos.x * 100.0 - a_particleVel.y + 0.1,
    // a_particleVel.x + cos(angle + 0.5),
    1.0);
  return output;
}

@fragment
fn fragMain(@location(4) color : vec4f) -> @location(0) vec4f {
  return color;
}
"
}

