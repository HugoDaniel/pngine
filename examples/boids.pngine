#define NUM_PARTICLES=2048

#renderPipeline renderBoids {
  layout=auto
  vertex={
    entrypoint=vertexMain
    module=code
    buffers=[
      // instanced particles buffer (pos + vel per instance)
      {
        arrayStride="4*4"
        stepMode=instance
        attributes=[
          { shaderLocation=0 offset=0 format=float32x2 }
          { shaderLocation=1 offset="2*4" format=float32x2 }
        ]
      }
      // vertex buffer (triangle vertices)
      {
        arrayStride="2*4"
        stepMode=vertex
        attributes=[
          { shaderLocation=2 offset=0 format=float32x2 }
        ]
      }
    ]
  }
  fragment={
    entrypoint=fragMain
    module=code
    targets=[{ format=preferredCanvasFormat }]
  }
  primitive={
    topology=triangle-list
  }
}

#computePipeline computeBoids {
  layout=auto
  compute={
    entrypoint=computeMain
    module=code
  }
}

#renderPass drawBoidsPass {
  colorAttachments=[{
    view=contextCurrentTexture
    clearValue=[0.0 0.0 0.0 1.0]
    loadOp=clear
    storeOp=store
  }]
  pipeline=renderBoids
  vertexBuffers=[particleBuffers spriteVertexBuffer]
  vertexBuffersPoolOffsets=[1 0]
  draw={
    vertexCount=3
    instanceCount=NUM_PARTICLES
    firstVertex=0
    firstInstance=0
  }
}

#computePass computeBoidsPass {
  pipeline=computeBoids
  bindGroups=[particleBindGroups]
  dispatchWorkgroups="ceil(NUM_PARTICLES / 64)"
}

#data vertexBufferData {
  float32Array=[
    -0.01 -0.02
    0.01 -0.02
    0.0 0.02
  ]
}

#buffer spriteVertexBuffer {
  size=vertexBufferData
  usage=[VERTEX]
  mappedAtCreation=vertexBufferData
}

#buffer simParamBuffer {
  size="7*4"
  usage=[UNIFORM COPY_DST]
}

#data simParamsData {
  float32Array=[
    0.04    // deltaT
    0.1     // rule1Distance
    0.025   // rule2Distance
    0.025   // rule3Distance
    0.02    // rule1Scale
    0.05    // rule2Scale
    0.005   // rule3Scale
  ]
}

#queue updateSimParams {
  writeBuffer={
    buffer=simParamBuffer
    bufferOffset=0
    data=simParamsData
  }
}

// Particle buffer: NUM_PARTICLES * 4 floats (pos.x, pos.y, vel.x, vel.y) * 4 bytes
#buffer particleBuffers {
  size="NUM_PARTICLES * 4 * 4"
  usage=[VERTEX STORAGE]
  pool=2
}

// Initialize particles using compute shader
#init initParticles {
  buffer=particleBuffers
  shader=initShader
  workgroups="ceil(NUM_PARTICLES / 64)"
}

#shaderModule initShader {
  code="
struct Particle {
  pos : vec2f,
  vel : vec2f,
}

struct Particles {
  particles : array<Particle>,
}

@binding(0) @group(0) var<storage, read_write> data : Particles;

// Simple hash for pseudo-random numbers
fn hash(n: u32) -> f32 {
  var x = n;
  x = ((x >> 16u) ^ x) * 0x45d9f3bu;
  x = ((x >> 16u) ^ x) * 0x45d9f3bu;
  x = (x >> 16u) ^ x;
  return f32(x) / f32(0xffffffffu);
}

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) id : vec3u) {
  let i = id.x;
  let total = arrayLength(&data.particles);
  if (i >= total) { return; }

  let t = f32(i) / f32(total);
  let angle = t * 6.283185;  // 2 * PI
  let radius = sqrt(t);

  // Spiral pattern for initial positions
  data.particles[i].pos = vec2f(cos(angle) * radius, sin(angle) * radius);

  // Random velocities
  data.particles[i].vel = vec2f(
    (hash(i * 2u) - 0.5) * 0.1,
    (hash(i * 2u + 1u) - 0.5) * 0.1
  );
}
"
}

#bindGroup particleBindGroups {
  layout={ pipeline=computeBoids index=0 }
  entries=[
    { binding=0 resource={ buffer=simParamBuffer } }
    { binding=1 resource={ buffer=particleBuffers pingPong=0 } }
    { binding=2 resource={ buffer=particleBuffers pingPong=1 } }
  ]
  pool=2
}

#frame boids {
  init=[initParticles]
  before=[updateSimParams]
  perform=[
    computeBoidsPass
    drawBoidsPass
  ]
}

#shaderModule code {
  code="
struct Particle {
  pos : vec2f,
  vel : vec2f,
}

struct SimParams {
  deltaT : f32,
  rule1Distance : f32,
  rule2Distance : f32,
  rule3Distance : f32,
  rule1Scale : f32,
  rule2Scale : f32,
  rule3Scale : f32,
}

struct Particles {
  particles : array<Particle>,
}

@binding(0) @group(0) var<uniform> params : SimParams;
@binding(1) @group(0) var<storage, read> particlesA : Particles;
@binding(2) @group(0) var<storage, read_write> particlesB : Particles;

@compute @workgroup_size(64)
fn computeMain(@builtin(global_invocation_id) GlobalInvocationID : vec3u) {
  var index = GlobalInvocationID.x;

  var vPos = particlesA.particles[index].pos;
  var vVel = particlesA.particles[index].vel;
  var cMass = vec2(0.0);
  var cVel = vec2(0.0);
  var colVel = vec2(0.0);
  var cMassCount = 0u;
  var cVelCount = 0u;
  var pos : vec2f;
  var vel : vec2f;

  for (var i = 0u; i < arrayLength(&particlesA.particles); i++) {
    if (i == index) {
      continue;
    }

    pos = particlesA.particles[i].pos.xy;
    vel = particlesA.particles[i].vel.xy;
    if (distance(pos, vPos) < params.rule1Distance) {
      cMass += pos;
      cMassCount++;
    }
    if (distance(pos, vPos) < params.rule2Distance) {
      colVel -= pos - vPos;
    }
    if (distance(pos, vPos) < params.rule3Distance) {
      cVel += vel;
      cVelCount++;
    }
  }
  if (cMassCount > 0) {
    cMass = (cMass / vec2(f32(cMassCount))) - vPos;
  }
  if (cVelCount > 0) {
    cVel /= f32(cVelCount);
  }
  vVel += (cMass * params.rule1Scale) + (colVel * params.rule2Scale) + (cVel * params.rule3Scale);

  // clamp velocity for a more pleasing simulation
  vVel = normalize(vVel) * clamp(length(vVel), 0.0, 0.1);
  // kinematic update
  vPos = vPos + (vVel * params.deltaT);
  // Wrap around boundary
  if (vPos.x < -1.0) { vPos.x = 1.0; }
  if (vPos.x > 1.0) { vPos.x = -1.0; }
  if (vPos.y < -1.0) { vPos.y = 1.0; }
  if (vPos.y > 1.0) { vPos.y = -1.0; }
  // Write back
  particlesB.particles[index].pos = vPos;
  particlesB.particles[index].vel = vVel;
}

struct VertexOutput {
  @builtin(position) position : vec4f,
  @location(4) color : vec4f,
}

@vertex
fn vertexMain(
  @location(0) a_particlePos : vec2f,
  @location(1) a_particleVel : vec2f,
  @location(2) a_pos : vec2f
) -> VertexOutput {
  let angle = -atan2(a_particleVel.x, a_particleVel.y);
  let pos = vec2(
    (a_pos.x * cos(angle)) - (a_pos.y * sin(angle)),
    (a_pos.x * sin(angle)) + (a_pos.y * cos(angle))
  );

  var output : VertexOutput;
  output.position = vec4(pos + a_particlePos, 0.0, 1.0);
  output.color = vec4(
    1.0 - sin(angle + 1.0) - a_particleVel.y,
    pos.x * 100.0 - a_particleVel.y + 0.1,
    a_particleVel.x + cos(angle + 0.5),
    1.0
  );
  return output;
}

@fragment
fn fragMain(@location(4) color : vec4f) -> @location(0) vec4f {
  return color;
}
"
}
