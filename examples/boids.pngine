#define NUM_PARTICLES=2048
#renderPipeline renderBoids {
  layout=auto
  vertex={
    entrypoint=vertexMain
    module=code
    // DEBUG: Remove all vertex buffer layouts
  }

  fragment={
    entrypoint=fragMain
    module=code
    targets=[{ format=preferredCanvasFormat }]
  }
  primitive={
    topology=triangle-list
  }
}

#computePipeline computeBoids {
  layout=auto
  compute={
    entrypoint=computeMain
    module=code
  }
}

#renderPass drawBoidsPass {
  colorAttachments=[{
    view=contextCurrentTexture
    clearValue=[0.0 0.0 0.0 1.0]
    loadOp=clear
    storeOp=store
  }]
  pipeline=renderBoids
  // DEBUG: No vertex buffers, simple draw
  draw=3
}

#computePass computeBoidsPass {
  pipeline=computeBoids
  bindGroups=[particleBindGroups]
  // Optionally set the pool offset at each bind group: bindGroupsPoolOffsets=[0]
  // non pooled bind groups will be left as is regardless of the value set
  dispatchWorkgroups="ceil(NUM_PARTICLES / 64)"
}

#data vertexBufferData {
  float32Array=[
  -0.01 -0.02 0.01
  -0.02 0.0 0.02
]}

#buffer spriteVertexBuffer {
  size  = vertexBufferData
  usage = [VERTEX]
  mappedAtCreation=vertexBufferData
}

#buffer simParamBuffer {
  size="7*4"
  usage=[UNIFORM COPY_DST]
}
#data simParamsData {
  float32Array=[
  // deltaT:
  0.04,
  // rule1Distance:
  0.1,
  // rule2Distance:
  0.025,
  // rule3Distance:
  0.025,
  // rule1Scale:
  0.02,
  // rule2Scale:
  0.05,
  // rule3Scale:
  0.005
]}

#queue updateSimParams {
  writeBuffer={
    buffer=simParamBuffer
    bufferOffset=0
    data=simParamsData
  }
}


#data initialParticleData {
  float32Array={
    numberOfElements=NUM_PARTICLES 
    initEachElementWith=[
    // position:
      "cos((ELEMENT_ID / NUM_PARTICLES) * PI * 2) * sqrt(ELEMENT_ID / NUM_PARTICLES)"
      "sin((ELEMENT_ID / NUM_PARTICLES) * PI * 2) * sqrt(ELEMENT_ID / NUM_PARTICLES)"
    // velocity:
      "random()"
      "random()"
    ]
  }
}

#buffer particleBuffers {
  size = initialParticleData
  usage = [VERTEX STORAGE]
  mappedAtCreation = initialParticleData
  pool=2
}

#bindGroup particleBindGroups {
  layout={ pipeline=computeBoids index=0 }
  entries=[
    { binding=0 resource={ buffer=simParamBuffer }}
    { binding=1 resource={ buffer=particleBuffers size=initialParticleData pingPong=0 }}
    { binding=2 resource={ buffer=particleBuffers size=initialParticleData pingPong=1 }}
  ]
  pool=2
}

#frame boids {
  // DEBUG: No compute pass, just render
  perform=[
    drawBoidsPass
  ]
}

#shaderModule code {
  code="
struct Particle {
  pos : vec2f,
  vel : vec2f,
}
struct SimParams {
  deltaT : f32,
  rule1Distance : f32,
  rule2Distance : f32,
  rule3Distance : f32,
  rule1Scale : f32,
  rule2Scale : f32,
  rule3Scale : f32,
}

struct Particles {
  particles : array<Particle>,
}

@binding(0) @group(0) var<uniform> params : SimParams;
@binding(1) @group(0) var<storage, read> particlesA : Particles;
@binding(2) @group(0) var<storage, read_write> particlesB : Particles;

// https://github.com/austinEng/Project6-Vulkan-Flocking/blob/master/data/shaders/computeparticles/particle.comp
@compute @workgroup_size(64)
fn computeMain(@builtin(global_invocation_id) GlobalInvocationID : vec3u) {
  var index = GlobalInvocationID.x;

  var vPos = particlesA.particles[index].pos;
  var vVel = particlesA.particles[index].vel;
  var cMass = vec2(0.0);
  var cVel = vec2(0.0);
  var colVel = vec2(0.0);
  var cMassCount = 0u;
  var cVelCount = 0u;
  var pos : vec2f;
  var vel : vec2f;

  for (var i = 0u; i < arrayLength(&particlesA.particles); i++) {
    if (i == index) {
      continue;
    }

    pos = particlesA.particles[i].pos.xy;
    vel = particlesA.particles[i].vel.xy;
    if (distance(pos, vPos) < params.rule1Distance) {
      cMass += pos;
      cMassCount++;
    }
    if (distance(pos, vPos) < params.rule2Distance) {
      colVel -= pos - vPos;
    }
    if (distance(pos, vPos) < params.rule3Distance) {
      cVel += vel;
      cVelCount++;
    }
  }
  if (cMassCount > 0) {
    cMass = (cMass / vec2(f32(cMassCount))) - vPos;
  }
  if (cVelCount > 0) {
    cVel /= f32(cVelCount);
  }
  vVel += (cMass * params.rule1Scale) + (colVel * params.rule2Scale) + (cVel * params.rule3Scale);

  // clamp velocity for a more pleasing simulation
  vVel = normalize(vVel) * clamp(length(vVel), 0.0, 0.1);
  // kinematic update
  vPos = vPos + (vVel * params.deltaT);
  // Wrap around boundary
  if (vPos.x < -1.0) {
    vPos.x = 1.0;
  }
  if (vPos.x > 1.0) {
    vPos.x = -1.0;
  }
  if (vPos.y < -1.0) {
    vPos.y = 1.0;
  }
  if (vPos.y > 1.0) {
    vPos.y = -1.0;
  }
  // Write back
  particlesB.particles[index].pos = vPos;
  particlesB.particles[index].vel = vVel;
}


struct VertexOutput {
  @builtin(position) position : vec4f,
  @location(4) color : vec4f,
}

@vertex
fn vertexMain(
  @builtin(vertex_index) vid : u32
) -> VertexOutput {
  // DEBUG: Fixed triangle using only vertex_index - no vertex buffers
  var positions = array<vec2f, 3>(
    vec2f(-0.5, -0.5),
    vec2f(0.5, -0.5),
    vec2f(0.0, 0.5)
  );
  var output : VertexOutput;
  output.position = vec4(positions[vid % 3], 0.0, 1.0);
  output.color = vec4(1.0, 0.0, 1.0, 1.0);
  return output;
}

@fragment
fn fragMain(@location(4) color : vec4f) -> @location(0) vec4f {
  return vec4f(1.0, 0.0, 1.0, 1.0);  // DEBUG: magenta
}
"
}

