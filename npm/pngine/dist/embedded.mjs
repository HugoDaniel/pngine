var Ut={0:"rgba8unorm",1:"rgba8snorm",2:"rgba8uint",3:"rgba8sint",4:"bgra8unorm",5:"rgba16float",6:"rgba32float",16:"depth24plus",17:"depth24plus-stencil8",18:"depth32float",32:"r32float",33:"rg32float"},mt=u=>Ut[u]??navigator.gpu.getPreferredCanvasFormat(),z=["nearest","linear"],H=u=>z[u]??"linear",R=["clamp-to-edge","repeat","mirror-repeat"],X=u=>R[u]??"clamp-to-edge",dt=0,xt=1,bt=2,Gt=3,$t=4,ht=5,yt=6,Pt=7,Et=8,Dt=9,Bt=10,Tt=11,At=12,Ct=13;var _t=1111969360;function St(u){let d=new DataView(u.buffer,u.byteOffset,u.byteLength);if(d.getUint32(0,!0)!==_t)return{uniforms:new Map,strings:[]};let l=d.getUint32(20,!0),f=d.getUint32(32,!0),G=Mt(u,l),g=new Map;if(f===0||f>=u.length)return{uniforms:g,strings:G};let U=f,y=d.getUint16(U,!0);U+=2;for(let i=0;i<y&&U+8<=u.length;i++){let b=d.getUint16(U,!0);U+=2,U+=4;let h=d.getUint16(U,!0);U+=2;for(let T=0;T<h&&U+10<=u.length;T++){U+=2;let D=d.getUint16(U,!0);U+=2;let A=d.getUint16(U,!0);U+=2;let C=d.getUint16(U,!0);U+=2;let M=d.getUint8(U);U+=2;let _=G[D]||`field_${D}`;g.set(_,{bufferId:b,offset:A,size:C,type:M})}}return{uniforms:g,strings:G}}function Mt(u,d){if(d===0||d>=u.length-2)return[];let l=new DataView(u.buffer,u.byteOffset,u.byteLength),f=new TextDecoder,G=[],g=l.getUint16(d,!0);if(g===0)return G;let U=d+2,y=U+g*2,i=y+g*2;if(i>u.length)return G;for(let b=0;b<g;b++){let h=l.getUint16(U+b*2,!0),T=l.getUint16(y+b*2,!0),D=i+h;D+T<=u.length?G.push(f.decode(u.subarray(D,D+T))):G.push(`string_${b}`)}return G}function Y(u,d){let l=null,f=0,G=0,g=0,U=null,y=null,i=!1,b=[],h=[],T=[],D=[],A=[],C=[],M=[],_=[],k=[],w=[],V=[],I=[],q=[],W=[];function F(n,e){return e===0?"":new TextDecoder().decode(new Uint8Array(l.buffer,n,e))}let Z=mt;function K(n,e,t){b[n]||(i&&console.log(`[GPU] createBuffer(${n}, ${e}, 0x${t.toString(16)})`),b[n]=u.createBuffer({size:e,usage:t||GPUBufferUsage.COPY_DST}))}function Q(n,e,t){if(A[n])return;if(i&&console.log(`[GPU] createShader(${n}, ${t}b)`),t===0){i&&console.warn(`[GPU] createShader(${n}) skipped: len=0`);return}let r=F(e,t);i&&console.log(`[GPU]   code:
${r}`);let a=u.createShaderModule({code:r});a.getCompilationInfo().then(s=>{for(let o of s.messages)o.type==="error"&&(console.error(`[GPU] Shader ${n} error at line ${o.lineNum}:${o.linePos}: ${o.message}`),console.error(`[GPU] Context: ${r.split(`
`).slice(Math.max(0,o.lineNum-3),o.lineNum+2).join(`
`)}`))}),A[n]=a}function v(n,e,t){if(C[n])return;if(t===0){i&&console.warn(`[GPU] createRenderPipeline(${n}) skipped: len=0`);return}let r=JSON.parse(F(e,t)),a=navigator.gpu.getPreferredCanvasFormat();i&&console.log(`[GPU] createRenderPipeline(${n}) desc=`,JSON.stringify(r));let s=r.fragment?.targetFormat;(!s||s==="preferredCanvasFormat")&&(s=a),i&&console.log(`[GPU]   targetFormat: ${s}`);let o=[{format:s}],c=u.createRenderPipeline({layout:"auto",vertex:{module:A[r.vertex?.shader??0],entryPoint:r.vertex?.entryPoint??"vs_main",buffers:r.vertex?.buffers??[]},fragment:{module:A[r.fragment?.shader??r.vertex?.shader??0],entryPoint:r.fragment?.entryPoint??"fs_main",targets:o},primitive:r.primitive??{topology:"triangle-list"},depthStencil:r.depthStencil});C[n]=c,_[n]=c.getBindGroupLayout(0)}function tt(n,e,t){if(C[n])return;if(t<4){i&&console.warn(`[GPU] createComputePipeline(${n}) skipped: len=${t}`);return}let r=new Uint8Array(l.buffer,e,t),s=new DataView(r.buffer,r.byteOffset,r.byteLength).getUint16(1,!0),o=r[3],c=o>0?new TextDecoder().decode(r.slice(4,4+o)):"main";i&&console.log(`[GPU] createComputePipeline(${n}) shader=${s} entry=${c}`);let m=u.createComputePipeline({layout:"auto",compute:{module:A[s]??A[0],entryPoint:c}});C[n]=m,_[n]=m.getBindGroupLayout(0)}function et(n,e,t){if(h[n])return;if(t===0){i&&console.warn(`[GPU] createTexture(${n}) skipped: len=0`);return}let r=new Uint8Array(l.buffer,e,t),a=new DataView(r.buffer,r.byteOffset,r.byteLength),s=2,o={size:[G||512,g||512],format:navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT,sampleCount:1},c=r[1];for(let m=0;m<c;m++){let $=r[s++],P=r[s++];if(P===0){let B=a.getUint32(s,!0);s+=4,$===1?o.size[0]=B:$===2?o.size[1]=B:$===5&&(o.sampleCount=B)}else if(P===7){let B=r[s++];$===7?o.format=Z(B):$===8&&(o.usage=B||GPUTextureUsage.RENDER_ATTACHMENT)}}W[n]={format:o.format,usage:o.usage},i&&console.log(`[GPU] createTexture(${n}) ${o.size[0]}x${o.size[1]} ${o.format} usage=0x${o.usage.toString(16)}`),h[n]=u.createTexture(o)}function rt(n,e,t){if(D[n])return;if(t===0){i&&console.warn(`[GPU] createSampler(${n}) skipped: len=0`);return}let r=new Uint8Array(l.buffer,e,t),a=2,s={magFilter:z[1],minFilter:z[1],addressModeU:R[0],addressModeV:R[0]},o=r[1];for(let c=0;c<o;c++){let m=r[a++];if(r[a++]===7){let P=r[a++];m===4?s.magFilter=H(P):m===5?s.minFilter=H(P):m===1?s.addressModeU=X(P):m===2&&(s.addressModeV=X(P))}}i&&console.log(`[GPU] createSampler(${n}) ${s.magFilter}/${s.minFilter}`),D[n]=u.createSampler(s)}function nt(n,e,t,r){if(M[n])return;if(r===0){i&&console.warn(`[GPU] createBindGroup(${n}) skipped: len=0`);return}let a=new Uint8Array(l.buffer,t,r),s=new DataView(a.buffer,a.byteOffset,a.byteLength),o=2,c=0,m=[],$=a[1];for(let x=0;x<$;x++){let E=a[o++],S=a[o++];if(E===1&&S===7)c=a[o++];else if(E===2&&S===3){let L=a[o++];for(let p=0;p<L;p++){let lt=a[o++],J=a[o++],gt=s.getUint16(o,!0);o+=2;let O={binding:lt,rt:J,rid:gt};J===0&&(O.offset=s.getUint32(o,!0),o+=4,O.size=s.getUint32(o,!0),o+=4),m.push(O)}}}q[n]={layoutId:e,gi:c,entries:m},i&&console.log(`[GPU] createBindGroup(${n}) layoutId=${e} entries=[${m.map(x=>`{b=${x.binding} rt=${x.rt} rid=${x.rid}}`).join(",")}]`);let P=C[e];if(!P)return;let B=m.map(x=>{let E={binding:x.binding};return x.rt===0?(E.resource={buffer:b[x.rid]},x.offset&&(E.resource.offset=x.offset),x.size&&(E.resource.size=x.size)):x.rt===1?(E.resource=h[x.rid]?.createView(),i&&console.log(`[GPU]   bindGroup entry b=${x.binding}: tex[${x.rid}]=${h[x.rid]?"exists":"MISSING"} view=${E.resource?"valid":"NULL"}`)):x.rt===2&&(E.resource=D[x.rid]),E});M[n]=u.createBindGroup({layout:P.getBindGroupLayout(c),entries:B})}function at(n,e,t,r){U||(U=u.createCommandEncoder());let a=65534,s;if(n===a){let c=d.getCurrentTexture();i&&console.log(`[GPU]   canvasTex: ${c?.width}x${c?.height} ${c?.format}`),s=c.createView()}else s=h[n]?.createView();i&&console.log(`[GPU] beginRenderPass colorId=${n===a?"CANVAS":n} loadOp=${e} storeOp=${t} depthId=${r}`),i&&console.log(`[GPU]   tex[${n}]=${h[n]?"exists":"MISSING"} view=${s?"valid":"NULL"}`);let o={colorAttachments:[{view:s,loadOp:e===1?"clear":"load",storeOp:t===0?"store":"discard",clearValue:{r:0,g:0,b:0,a:0}}]};r!==65535&&h[r]&&(o.depthStencilAttachment={view:h[r].createView(),depthLoadOp:"clear",depthStoreOp:"store",depthClearValue:1}),y=U.beginRenderPass(o)}function ot(){U||(U=u.createCommandEncoder()),y=U.beginComputePass()}function st(n,e,t){switch(n){case 1:return K(e.getUint16(t,!0),e.getUint32(t+2,!0),e.getUint8(t+6)),t+7;case 2:return et(e.getUint16(t,!0),e.getUint32(t+2,!0),e.getUint32(t+6,!0)),t+10;case 3:return rt(e.getUint16(t,!0),e.getUint32(t+2,!0),e.getUint32(t+6,!0)),t+10;case 4:return Q(e.getUint16(t,!0),e.getUint32(t+2,!0),e.getUint32(t+6,!0)),t+10;case 5:return v(e.getUint16(t,!0),e.getUint32(t+2,!0),e.getUint32(t+6,!0)),t+10;case 6:return tt(e.getUint16(t,!0),e.getUint32(t+2,!0),e.getUint32(t+6,!0)),t+10;case 7:return nt(e.getUint16(t,!0),e.getUint16(t+2,!0),e.getUint32(t+4,!0),e.getUint32(t+8,!0)),t+12;case 8:{let r=e.getUint16(t,!0),a=e.getUint16(t+2,!0);return!T[r]&&h[a]&&(T[r]=h[a].createView()),t+12}case 9:return t+10;case 10:{let r=e.getUint16(t,!0),a=e.getUint32(t+2,!0),s=e.getUint32(t+6,!0);return _[r]||(_[r]=u.createBindGroupLayout(JSON.parse(F(a,s)))),t+10}case 11:{let r=e.getUint16(t,!0),a=e.getUint32(t+2,!0),s=e.getUint32(t+6,!0);if(s===0)return t+10;let o=new Blob([new Uint8Array(l.buffer,a,s)]);return createImageBitmap(o).then(c=>(w[r]=c,t+10))}case 12:{let r=e.getUint16(t,!0),a=e.getUint32(t+2,!0),s=e.getUint32(t+6,!0),o=JSON.parse(F(a,s));return k[r]=u.createPipelineLayout({bindGroupLayouts:o.bindGroupLayouts.map(c=>_[c])}),t+10}case 13:return t+10;case 16:return at(e.getUint16(t,!0),e.getUint8(t+2),e.getUint8(t+3),e.getUint16(t+4,!0)),t+6;case 17:return ot(),t;case 18:{let r=e.getUint16(t,!0);return i&&console.log(`[GPU] setPipeline(${r})`),y?.setPipeline(C[r]),t+2}case 19:{let r=e.getUint8(t),a=e.getUint16(t+1,!0);return i&&console.log(`[GPU] setBindGroup(${r}, ${a}) pass=${y?"valid":"NULL"} bg[${a}]=${M[a]?"exists":"MISSING"}`),y?.setBindGroup(r,M[a]),t+3}case 20:return y?.setVertexBuffer(e.getUint8(t),b[e.getUint16(t+1,!0)]),t+3;case 21:{let r=e.getUint32(t,!0),a=e.getUint32(t+4,!0);return i&&console.log(`[GPU] draw(${r}, ${a}) pass=${y?"valid":"NULL"}`),y?.draw(r,a,e.getUint32(t+8,!0),e.getUint32(t+12,!0)),t+16}case 22:return y?.drawIndexed(e.getUint32(t,!0),e.getUint32(t+4,!0),e.getUint32(t+8,!0),e.getInt32(t+12,!0),e.getUint32(t+16,!0)),t+20;case 23:return i&&console.log("[GPU] endPass"),y?.end(),y=null,t;case 24:return y?.dispatchWorkgroups(e.getUint32(t,!0),e.getUint32(t+4,!0),e.getUint32(t+8,!0)),t+12;case 25:return y?.setIndexBuffer(b[e.getUint16(t,!0)],e.getUint8(t+2)===1?"uint32":"uint16"),t+3;case 26:{let r=e.getUint8(t);return t+1+r*2}case 32:{let r=e.getUint16(t,!0),a=e.getUint32(t+2,!0),s=e.getUint32(t+6,!0),o=e.getUint32(t+10,!0);return i&&console.log(`[GPU] write_buffer: id=${r}, offset=${a}, dataPtr=${s}, dataLen=${o}`),b[r]&&o>0&&u.queue.writeBuffer(b[r],a,new Uint8Array(l.buffer,s,o)),t+14}case 33:{let r=e.getUint16(t,!0),a=e.getUint32(t+2,!0),s=e.getUint16(t+6,!0);if(i&&console.log(`[GPU] writeTimeUniform buf[${r}] time=${f} cw=${G} ch=${g}`),b[r]){let o=new Float32Array([f,G,g,G/(g||1)]);u.queue.writeBuffer(b[r],a,new Uint8Array(o.buffer,0,Math.min(s,16)))}return t+8}case 34:{let r=e.getUint16(t,!0),a=e.getUint32(t+2,!0),s=e.getUint16(t+6,!0),o=e.getUint32(t+8,!0),c=e.getUint32(t+12,!0);return U||(U=u.createCommandEncoder()),U.copyBufferToBuffer(b[r],a,b[s],o,c),t+16}case 35:{let r=e.getUint16(t,!0),a=e.getUint16(t+2,!0),s=e.getUint16(t+4,!0),o=e.getUint16(t+6,!0);return U||(U=u.createCommandEncoder()),U.copyTextureToTexture({texture:h[r]},{texture:h[a]},[s,o]),t+8}case 36:{let r=e.getUint16(t,!0),a=e.getUint32(t+2,!0),s=e.getUint32(t+6,!0),o=e.getUint32(t+10,!0),c=I[s];if(i&&console.log(`[GPU] write_buffer_from_wasm: bid=${r}, off=${a}, callId=${s}, sz=${o}, cr=`,c),b[r]&&c&&o>0){let m=V[c.mid],$=m?.inst?.exports?.memory?.buffer||m?.importedMem?.buffer;i&&console.log(`[GPU] write_buffer_from_wasm: mod=${!!m}, wasmMem=${!!$}, result=${c.result}, memSize=${$?.byteLength}`),$&&c.result!=null&&c.result+o<=$.byteLength?u.queue.writeBuffer(b[r],a,new Uint8Array($,c.result,o)):i&&console.warn(`[GPU] write_buffer_from_wasm: invalid params - result=${c.result}, sz=${o}, memSize=${$?.byteLength}`)}return t+14}case 37:{let r=e.getUint16(t,!0),a=e.getUint16(t+2,!0),s=e.getUint8(t+4),o=e.getUint16(t+5,!0),c=e.getUint16(t+7,!0),m=w[r];return m&&h[a]&&u.queue.copyExternalImageToTexture({source:m},{texture:h[a],mipLevel:s,origin:[o,c]},[m.width,m.height]),t+9}case 48:{let r=e.getUint16(t,!0),a=e.getUint32(t+2,!0),s=e.getUint32(t+6,!0);if(i&&console.log(`[GPU] init_wasm_module: id=${r}, ptr=${a}, len=${s}`),s===0)return t+10;let o=new Uint8Array(l.buffer,a,s).slice(),c=new WebAssembly.Memory({initial:1}),m={env:{abort:()=>{throw new Error("WASM abort")},memory:c}};return WebAssembly.compile(o).then($=>WebAssembly.instantiate($,m).then(P=>(V[r]={inst:P,importedMem:c},i&&console.log(`[GPU] init_wasm_module done: id=${r}, exports=`,Object.keys(P.exports)),t+10)))}case 49:{let r=e.getUint16(t,!0),a=e.getUint16(t+2,!0),s=e.getUint32(t+4,!0),o=e.getUint32(t+8,!0),c=e.getUint8(t+12),m=new Uint8Array(l.buffer,t+13,c).slice(),$=F(s,o);i&&console.log(`[GPU] call_wasm_func: cid=${r}, mid=${a}, name="${$}", ac=${c}`);let{inst:P}=V[a]||{},B=P?.exports[$],x=[],E=new DataView(m.buffer,m.byteOffset,m.byteLength);for(let S=0,L=0;S<c/5|0;S++){let p=m[L++];p===0?x.push(E.getFloat32(L,!0)):p===1?x.push(E.getInt32(L,!0)):p===2&&x.push(E.getUint32(L,!0)),L+=4}if(B){let S=B(...x);I[r]={mid:a,result:S},i&&console.log(`[GPU] call_wasm_func result: cid=${r}, result=${S}`)}else i&&console.log(`[GPU] call_wasm_func: fn not found! mid=${a}, name="${$}"`);return t+13+c}case 240:return i&&console.log(`[GPU] submit enc=${!!U}`),U&&(u.queue.submit([U.finish()]),U=null),t;case 255:return t;default:return console.warn(`Unknown cmd: 0x${n.toString(16)}`),t}}async function ut(n){let e=new DataView(l.buffer),t=e.getUint32(n,!0),r=e.getUint16(n+4,!0);i&&console.log(`[GPU] Execute: ${r} cmds, ${t}b`);let a=n+8,s=n+t;for(let o=0;o<r&&a<s;o++){let c=e.getUint8(a++),m=st(c,e,a);m instanceof Promise?(a=await m,e=new DataView(l.buffer)):a=m}}function it(){b.forEach(n=>n?.destroy?.()),h.forEach(n=>n?.destroy?.()),b.length=h.length=T.length=D.length=A.length=C.length=0,M.length=_.length=k.length=w.length=V.length=0,I.length=q.length=W.length=0}let N=null;function ct(n){N=n,i&&console.log(`[GPU] setUniformTable: ${n.size} uniforms`)}function j(n,e){if(!N)return!1;let t=N.get(n);if(!t)return i&&console.warn(`[GPU] setUniform: unknown uniform '${n}'`),!1;let r=b[t.bufferId];if(!r)return i&&console.warn(`[GPU] setUniform: buffer ${t.bufferId} not found`),!1;let a=Lt(e,t.type,t.size);return a?(u.queue.writeBuffer(r,t.offset,a),i&&console.log(`[GPU] setUniform: ${n} = ${Array.isArray(e)?`[${e.join(",")}]`:e} @ buffer[${t.bufferId}]+${t.offset}`),!0):(i&&console.warn(`[GPU] setUniform: failed to convert value for '${n}'`),!1)}function ft(n){let e=0;for(let[t,r]of Object.entries(n))j(t,r)&&e++;return e}return{setDebug(n){i=n},setMemory(n){l=n},setTime(n){f=n},setCanvasSize(n,e){G=n,g=e},setUniformTable:ct,setUniform:j,setUniforms:ft,execute:ut,destroy:it}}function Lt(u,d,l){let f=Array.isArray(u)?u:[u];switch(d){case dt:case Gt:case $t:case ht:{let g=new Float32Array(f);return new Uint8Array(g.buffer,0,Math.min(g.byteLength,l))}case xt:case Et:case Dt:case Bt:{let g=new Int32Array(f);return new Uint8Array(g.buffer,0,Math.min(g.byteLength,l))}case bt:case Tt:case At:case Ct:{let g=new Uint32Array(f);return new Uint8Array(g.buffer,0,Math.min(g.byteLength,l))}case yt:{let g=new Float32Array(12);return f.length>=9&&(g[0]=f[0],g[1]=f[3],g[2]=f[6],g[3]=0,g[4]=f[1],g[5]=f[4],g[6]=f[7],g[7]=0,g[8]=f[2],g[9]=f[5],g[10]=f[8],g[11]=0),new Uint8Array(g.buffer,0,Math.min(48,l))}case Pt:{let g=new Float32Array(f.length>=16?f:[...f,...Array(16-f.length).fill(0)]);return new Uint8Array(g.buffer,0,Math.min(64,l))}default:let G=new Float32Array(f);return new Uint8Array(G.buffer,0,Math.min(G.byteLength,l))}}function Vt(u,d){let l=Y(u,d);return{setMemory(f){l.setMemory(f)},execute(f){l.execute(f)},setUniform(f,G){return l.setUniform(f,G)},setUniforms(f){return l.setUniforms(f)},setUniformTable(f){l.setUniformTable(f)},destroy(){l.destroy()},setDebug(f){l.setDebug(f)},setTime(f){l.setTime(f)},setCanvasSize(f,G){l.setCanvasSize(f,G)},_dispatcher:l}}async function wt(u){if(!navigator.gpu)throw new Error("WebGPU not supported");let d=u||await navigator.gpu.requestAdapter();if(!d)throw new Error("No GPU adapter found");return d.requestDevice()}function It(u,d){let l=u.getContext("webgpu");if(!l)throw new Error("Failed to get WebGPU context");return l.configure({device:d,format:navigator.gpu.getPreferredCanvasFormat(),alphaMode:"premultiplied"}),l}export{It as configureCanvas,Y as createCommandDispatcher,Vt as createEmbeddedDispatcher,wt as getDevice,St as parseUniformTable};
