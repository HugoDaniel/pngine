
/**
 * PNGine Browser Bundle
 * Command buffer approach for minimal size
 */

// === Inline Worker Code ===
const WORKER_CODE = "// === _gpu.js (CommandDispatcher) ===\n/**\n * Minimal GPU Command Dispatcher\n *\n * Executes command buffers generated by WASM.\n * Replaces the 2000-line pngine-gpu.js with a ~200-line switch.\n */\n\n// Command opcodes (must match command_buffer.zig)\nconst CMD = {\n  CREATE_BUFFER: 0x01,\n  CREATE_TEXTURE: 0x02,\n  CREATE_SAMPLER: 0x03,\n  CREATE_SHADER: 0x04,\n  CREATE_RENDER_PIPELINE: 0x05,\n  CREATE_COMPUTE_PIPELINE: 0x06,\n  CREATE_BIND_GROUP: 0x07,\n  BEGIN_RENDER_PASS: 0x10,\n  BEGIN_COMPUTE_PASS: 0x11,\n  SET_PIPELINE: 0x12,\n  SET_BIND_GROUP: 0x13,\n  SET_VERTEX_BUFFER: 0x14,\n  DRAW: 0x15,\n  DRAW_INDEXED: 0x16,\n  END_PASS: 0x17,\n  DISPATCH: 0x18,\n  SET_INDEX_BUFFER: 0x19,\n  WRITE_BUFFER: 0x20,\n  WRITE_TIME_UNIFORM: 0x21,\n  SUBMIT: 0xf0,\n  END: 0xff,\n};\n\n// Usage flags (match opcodes.zig BufferUsage packed struct)\n// bit 0: map_read, bit 1: map_write, bit 2: copy_src, bit 3: copy_dst\n// bit 4: index, bit 5: vertex, bit 6: uniform, bit 7: storage\nconst USAGE = {\n  MAP_READ: 0x01,\n  MAP_WRITE: 0x02,\n  COPY_SRC: 0x04,\n  COPY_DST: 0x08,\n  INDEX: 0x10,\n  VERTEX: 0x20,\n  UNIFORM: 0x40,\n  STORAGE: 0x80,\n};\n\nclass CommandDispatcher {\n  constructor(device, context) {\n    this.device = device;\n    this.context = context;\n    this.memory = null;\n\n    // Resource tables\n    this.buffers = new Map();\n    this.textures = new Map();\n    this.samplers = new Map();\n    this.shaders = new Map();\n    this.pipelines = new Map();\n    this.bindGroups = new Map();\n    this.bindGroupLayouts = new Map();\n\n    // Render state\n    this.encoder = null;\n    this.pass = null;\n    this.time = 0;\n    this.canvasWidth = 0;\n    this.canvasHeight = 0;\n  }\n\n  setMemory(memory) {\n    this.memory = memory;\n  }\n\n  setTime(time) {\n    this.time = time;\n  }\n\n  setCanvasSize(w, h) {\n    this.canvasWidth = w;\n    this.canvasHeight = h;\n  }\n\n  /**\n   * Execute command buffer from WASM memory.\n   * @param {number} ptr - Pointer to command buffer in WASM memory\n   */\n  execute(ptr) {\n    const view = new DataView(this.memory.buffer);\n    const totalLen = view.getUint32(ptr, true);\n    const cmdCount = view.getUint16(ptr + 4, true);\n\n    let pos = ptr + 8; // Skip header\n    const end = ptr + totalLen;\n\n    for (let i = 0; i < cmdCount && pos < end; i++) {\n      const cmd = view.getUint8(pos++);\n      pos = this._dispatch(cmd, view, pos);\n    }\n  }\n\n  _dispatch(cmd, view, pos) {\n    switch (cmd) {\n      case CMD.CREATE_BUFFER: {\n        const id = view.getUint16(pos, true);\n        const size = view.getUint32(pos + 2, true);\n        const usage = view.getUint8(pos + 6);\n        this._createBuffer(id, size, usage);\n        return pos + 7;\n      }\n\n      case CMD.CREATE_SHADER: {\n        const id = view.getUint16(pos, true);\n        const codePtr = view.getUint32(pos + 2, true);\n        const codeLen = view.getUint32(pos + 6, true);\n        this._createShader(id, codePtr, codeLen);\n        return pos + 10;\n      }\n\n      case CMD.CREATE_RENDER_PIPELINE: {\n        const id = view.getUint16(pos, true);\n        const descPtr = view.getUint32(pos + 2, true);\n        const descLen = view.getUint32(pos + 6, true);\n        this._createRenderPipeline(id, descPtr, descLen);\n        return pos + 10;\n      }\n\n      case CMD.CREATE_COMPUTE_PIPELINE: {\n        const id = view.getUint16(pos, true);\n        const descPtr = view.getUint32(pos + 2, true);\n        const descLen = view.getUint32(pos + 6, true);\n        this._createComputePipeline(id, descPtr, descLen);\n        return pos + 10;\n      }\n\n      case CMD.CREATE_BIND_GROUP: {\n        const id = view.getUint16(pos, true);\n        const layoutId = view.getUint16(pos + 2, true);\n        const entriesPtr = view.getUint32(pos + 4, true);\n        const entriesLen = view.getUint32(pos + 8, true);\n        this._createBindGroup(id, layoutId, entriesPtr, entriesLen);\n        return pos + 12;\n      }\n\n      case CMD.CREATE_TEXTURE: {\n        const id = view.getUint16(pos, true);\n        const descPtr = view.getUint32(pos + 2, true);\n        const descLen = view.getUint32(pos + 6, true);\n        this._createTexture(id, descPtr, descLen);\n        return pos + 10;\n      }\n\n      case CMD.CREATE_SAMPLER: {\n        const id = view.getUint16(pos, true);\n        const descPtr = view.getUint32(pos + 2, true);\n        const descLen = view.getUint32(pos + 6, true);\n        this._createSampler(id, descPtr, descLen);\n        return pos + 10;\n      }\n\n      case CMD.BEGIN_RENDER_PASS: {\n        const colorId = view.getUint16(pos, true);\n        const loadOp = view.getUint8(pos + 2);\n        const storeOp = view.getUint8(pos + 3);\n        const depthId = view.getUint16(pos + 4, true);\n        this._beginRenderPass(colorId, loadOp, storeOp, depthId);\n        return pos + 6;\n      }\n\n      case CMD.BEGIN_COMPUTE_PASS: {\n        this._beginComputePass();\n        return pos;\n      }\n\n      case CMD.SET_PIPELINE: {\n        const id = view.getUint16(pos, true);\n        this.pass?.setPipeline(this.pipelines.get(id));\n        return pos + 2;\n      }\n\n      case CMD.SET_BIND_GROUP: {\n        const slot = view.getUint8(pos);\n        const id = view.getUint16(pos + 1, true);\n        this.pass?.setBindGroup(slot, this.bindGroups.get(id));\n        return pos + 3;\n      }\n\n      case CMD.SET_VERTEX_BUFFER: {\n        const slot = view.getUint8(pos);\n        const id = view.getUint16(pos + 1, true);\n        this.pass?.setVertexBuffer(slot, this.buffers.get(id));\n        return pos + 3;\n      }\n\n      case CMD.SET_INDEX_BUFFER: {\n        const id = view.getUint16(pos, true);\n        const format = view.getUint8(pos + 2);\n        const fmt = format === 1 ? \"uint32\" : \"uint16\";\n        this.pass?.setIndexBuffer(this.buffers.get(id), fmt);\n        return pos + 3;\n      }\n\n      case CMD.DRAW: {\n        const vtx = view.getUint32(pos, true);\n        const inst = view.getUint32(pos + 4, true);\n        const firstVtx = view.getUint32(pos + 8, true);\n        const firstInst = view.getUint32(pos + 12, true);\n        this.pass?.draw(vtx, inst, firstVtx, firstInst);\n        return pos + 16;\n      }\n\n      case CMD.DRAW_INDEXED: {\n        const idx = view.getUint32(pos, true);\n        const inst = view.getUint32(pos + 4, true);\n        const firstIdx = view.getUint32(pos + 8, true);\n        const baseVtx = view.getInt32(pos + 12, true);\n        const firstInst = view.getUint32(pos + 16, true);\n        this.pass?.drawIndexed(idx, inst, firstIdx, baseVtx, firstInst);\n        return pos + 20;\n      }\n\n      case CMD.DISPATCH: {\n        const x = view.getUint32(pos, true);\n        const y = view.getUint32(pos + 4, true);\n        const z = view.getUint32(pos + 8, true);\n        this.pass?.dispatchWorkgroups(x, y, z);\n        return pos + 12;\n      }\n\n      case CMD.END_PASS: {\n        this.pass?.end();\n        this.pass = null;\n        return pos;\n      }\n\n      case CMD.WRITE_BUFFER: {\n        const id = view.getUint16(pos, true);\n        const offset = view.getUint32(pos + 2, true);\n        const dataPtr = view.getUint32(pos + 6, true);\n        const dataLen = view.getUint32(pos + 10, true);\n        this._writeBuffer(id, offset, dataPtr, dataLen);\n        return pos + 14;\n      }\n\n      case CMD.WRITE_TIME_UNIFORM: {\n        const id = view.getUint16(pos, true);\n        const offset = view.getUint32(pos + 2, true);\n        const size = view.getUint16(pos + 6, true);\n        this._writeTimeUniform(id, offset, size);\n        return pos + 8;\n      }\n\n      case CMD.SUBMIT: {\n        if (this.encoder) {\n          this.device.queue.submit([this.encoder.finish()]);\n          this.encoder = null;\n        }\n        return pos;\n      }\n\n      case CMD.END: {\n        return pos;\n      }\n\n      default:\n        console.warn(`Unknown command: 0x${cmd.toString(16)}`);\n        return pos;\n    }\n  }\n\n  // Resource creation\n  _createBuffer(id, size, usage) {\n    if (this.buffers.has(id)) return;\n    const gpuUsage = this._translateUsage(usage);\n    this.buffers.set(\n      id,\n      this.device.createBuffer({ size, usage: gpuUsage })\n    );\n  }\n\n  _translateUsage(usage) {\n    let result = 0;\n    if (usage & USAGE.MAP_READ) result |= GPUBufferUsage.MAP_READ;\n    if (usage & USAGE.MAP_WRITE) result |= GPUBufferUsage.MAP_WRITE;\n    if (usage & USAGE.COPY_SRC) result |= GPUBufferUsage.COPY_SRC;\n    if (usage & USAGE.COPY_DST) result |= GPUBufferUsage.COPY_DST;\n    if (usage & USAGE.INDEX) result |= GPUBufferUsage.INDEX;\n    if (usage & USAGE.VERTEX) result |= GPUBufferUsage.VERTEX;\n    if (usage & USAGE.UNIFORM) result |= GPUBufferUsage.UNIFORM;\n    if (usage & USAGE.STORAGE) result |= GPUBufferUsage.STORAGE;\n    return result || GPUBufferUsage.COPY_DST;\n  }\n\n  _createShader(id, codePtr, codeLen) {\n    if (this.shaders.has(id)) return;\n    const code = this._readString(codePtr, codeLen);\n    this.shaders.set(id, this.device.createShaderModule({ code }));\n  }\n\n  _createRenderPipeline(id, descPtr, descLen) {\n    if (this.pipelines.has(id)) return;\n    const json = this._readString(descPtr, descLen);\n    if (!json || json.length === 0) {\n      console.error(`[GPU] Empty pipeline descriptor for id=${id}, ptr=${descPtr}, len=${descLen}`);\n      return;\n    }\n    const desc = JSON.parse(json);\n    const pipeline = this._buildRenderPipeline(desc);\n    this.pipelines.set(id, pipeline);\n    // Store layout for bind group creation\n    this.bindGroupLayouts.set(id, pipeline.getBindGroupLayout(0));\n  }\n\n  _buildRenderPipeline(desc) {\n    const format = navigator.gpu.getPreferredCanvasFormat();\n    // Always use \"auto\" layout - explicit layouts not yet supported\n    return this.device.createRenderPipeline({\n      layout: \"auto\",\n      vertex: {\n        module: this.shaders.get(desc.vertex?.shader ?? 0),\n        entryPoint: desc.vertex?.entryPoint ?? \"vs_main\",\n        buffers: desc.vertex?.buffers ?? [],\n      },\n      fragment: {\n        module: this.shaders.get(desc.fragment?.shader ?? desc.vertex?.shader ?? 0),\n        entryPoint: desc.fragment?.entryPoint ?? \"fs_main\",\n        targets: [{ format }],\n      },\n      primitive: desc.primitive ?? { topology: \"triangle-list\" },\n      depthStencil: desc.depthStencil,\n    });\n  }\n\n  _createComputePipeline(id, descPtr, descLen) {\n    if (this.pipelines.has(id)) return;\n    const json = this._readString(descPtr, descLen);\n    if (!json || json.length === 0) {\n      console.error(`[GPU] Empty compute pipeline descriptor for id=${id}, ptr=${descPtr}, len=${descLen}`);\n      return;\n    }\n    const desc = JSON.parse(json);\n    const pipeline = this.device.createComputePipeline({\n      layout: desc.layout === \"auto\" ? \"auto\" : undefined,\n      compute: {\n        module: this.shaders.get(desc.compute?.shader ?? 0),\n        entryPoint: desc.compute?.entryPoint ?? \"main\",\n      },\n    });\n    this.pipelines.set(id, pipeline);\n    if (desc.layout === \"auto\") {\n      this.bindGroupLayouts.set(id, pipeline.getBindGroupLayout(0));\n    }\n  }\n\n  _createBindGroup(id, layoutId, entriesPtr, entriesLen) {\n    if (this.bindGroups.has(id)) return;\n    const bytes = new Uint8Array(this.memory.buffer, entriesPtr, entriesLen);\n    const desc = this._decodeBindGroupDescriptor(bytes);\n\n    // Get layout from pipeline (layoutId is pipeline ID in this context)\n    const pipeline = this.pipelines.get(layoutId);\n    if (!pipeline) {\n      console.error(`[GPU] Pipeline ${layoutId} not found for bind group ${id}`);\n      return;\n    }\n\n    const gpuEntries = desc.entries.map((e) => {\n      const entry = { binding: e.binding };\n      if (e.resourceType === 0) { // buffer\n        const bufRes = { buffer: this.buffers.get(e.resourceId) };\n        if (e.offset) bufRes.offset = e.offset;\n        if (e.size) bufRes.size = e.size;\n        entry.resource = bufRes;\n      } else if (e.resourceType === 1) { // texture_view\n        entry.resource = this.textures.get(e.resourceId)?.createView();\n      } else if (e.resourceType === 2) { // sampler\n        entry.resource = this.samplers.get(e.resourceId);\n      }\n      return entry;\n    });\n\n    this.bindGroups.set(\n      id,\n      this.device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(desc.groupIndex),\n        entries: gpuEntries,\n      })\n    );\n  }\n\n  _decodeBindGroupDescriptor(bytes) {\n    const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    let offset = 0;\n\n    const typeTag = bytes[offset++];\n    if (typeTag !== 0x03) {\n      console.error(`[GPU] Invalid bind group descriptor type tag: ${typeTag}`);\n      return { groupIndex: 0, entries: [] };\n    }\n\n    const fieldCount = bytes[offset++];\n    let groupIndex = 0;\n    const entries = [];\n\n    const FIELD_LAYOUT = 0x01, FIELD_ENTRIES = 0x02;\n    const VALUE_ARRAY = 0x03, VALUE_ENUM = 0x07;\n\n    for (let i = 0; i < fieldCount; i++) {\n      const fieldId = bytes[offset++];\n      const valueType = bytes[offset++];\n\n      if (fieldId === FIELD_LAYOUT && valueType === VALUE_ENUM) {\n        groupIndex = bytes[offset++];\n      } else if (fieldId === FIELD_ENTRIES && valueType === VALUE_ARRAY) {\n        const entryCount = bytes[offset++];\n        for (let j = 0; j < entryCount; j++) {\n          const binding = bytes[offset++];\n          const resourceType = bytes[offset++];\n          const resourceId = view.getUint16(offset, true);\n          offset += 2;\n\n          const entry = { binding, resourceType, resourceId };\n          if (resourceType === 0) { // buffer has offset/size\n            entry.offset = view.getUint32(offset, true);\n            offset += 4;\n            entry.size = view.getUint32(offset, true);\n            offset += 4;\n          }\n          entries.push(entry);\n        }\n      }\n    }\n    return { groupIndex, entries };\n  }\n\n  _createTexture(id, descPtr, descLen) {\n    if (this.textures.has(id)) return;\n    const bytes = new Uint8Array(this.memory.buffer, descPtr, descLen);\n    const desc = this._decodeTextureDescriptor(bytes);\n    this.textures.set(id, this.device.createTexture(desc));\n  }\n\n  _createSampler(id, descPtr, descLen) {\n    if (this.samplers.has(id)) return;\n    const bytes = new Uint8Array(this.memory.buffer, descPtr, descLen);\n    const desc = this._decodeSamplerDescriptor(bytes);\n    this.samplers.set(id, this.device.createSampler(desc));\n  }\n\n  // Binary descriptor decoders (match DescriptorEncoder.zig format)\n  _decodeTextureDescriptor(bytes) {\n    const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    let offset = 0;\n\n    const typeTag = bytes[offset++];\n    if (typeTag !== 0x01) {\n      console.error(`[GPU] Invalid texture descriptor type tag: ${typeTag}`);\n      return { size: [256, 256], format: \"rgba8unorm\", usage: GPUTextureUsage.RENDER_ATTACHMENT };\n    }\n\n    const fieldCount = bytes[offset++];\n    const desc = {\n      size: [this.canvasWidth || 512, this.canvasHeight || 512],\n      format: navigator.gpu.getPreferredCanvasFormat(),\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n      sampleCount: 1,\n    };\n\n    const FIELD_WIDTH = 0x01, FIELD_HEIGHT = 0x02, FIELD_SAMPLE_COUNT = 0x05;\n    const FIELD_FORMAT = 0x07, FIELD_USAGE = 0x08;\n    const VALUE_U32 = 0x00, VALUE_ENUM = 0x07;\n\n    for (let i = 0; i < fieldCount; i++) {\n      const fieldId = bytes[offset++];\n      const valueType = bytes[offset++];\n\n      if (valueType === VALUE_U32) {\n        const value = view.getUint32(offset, true);\n        offset += 4;\n        if (fieldId === FIELD_WIDTH) desc.size[0] = value;\n        else if (fieldId === FIELD_HEIGHT) desc.size[1] = value;\n        else if (fieldId === FIELD_SAMPLE_COUNT) desc.sampleCount = value;\n      } else if (valueType === VALUE_ENUM) {\n        const value = bytes[offset++];\n        if (fieldId === FIELD_FORMAT) desc.format = this._decodeTextureFormat(value);\n        else if (fieldId === FIELD_USAGE) desc.usage = this._decodeTextureUsage(value);\n      }\n    }\n    return desc;\n  }\n\n  _decodeSamplerDescriptor(bytes) {\n    let offset = 0;\n    const typeTag = bytes[offset++];\n    if (typeTag !== 0x02) {\n      console.error(`[GPU] Invalid sampler descriptor type tag: ${typeTag}`);\n      return {};\n    }\n\n    const fieldCount = bytes[offset++];\n    const desc = {\n      magFilter: \"linear\",\n      minFilter: \"linear\",\n      addressModeU: \"clamp-to-edge\",\n      addressModeV: \"clamp-to-edge\",\n    };\n\n    const FIELD_ADDRESS_U = 0x01, FIELD_ADDRESS_V = 0x02;\n    const FIELD_MAG_FILTER = 0x04, FIELD_MIN_FILTER = 0x05;\n    const VALUE_ENUM = 0x07;\n\n    for (let i = 0; i < fieldCount; i++) {\n      const fieldId = bytes[offset++];\n      const valueType = bytes[offset++];\n\n      if (valueType === VALUE_ENUM) {\n        const value = bytes[offset++];\n        if (fieldId === FIELD_MAG_FILTER) desc.magFilter = value === 0 ? \"nearest\" : \"linear\";\n        else if (fieldId === FIELD_MIN_FILTER) desc.minFilter = value === 0 ? \"nearest\" : \"linear\";\n        else if (fieldId === FIELD_ADDRESS_U) desc.addressModeU = [\"clamp-to-edge\", \"repeat\", \"mirror-repeat\"][value] || \"clamp-to-edge\";\n        else if (fieldId === FIELD_ADDRESS_V) desc.addressModeV = [\"clamp-to-edge\", \"repeat\", \"mirror-repeat\"][value] || \"clamp-to-edge\";\n      }\n    }\n    return desc;\n  }\n\n  _decodeTextureFormat(value) {\n    const formats = {\n      0x00: \"rgba8unorm\", 0x01: \"rgba8snorm\", 0x02: \"rgba8uint\", 0x03: \"rgba8sint\",\n      0x04: \"bgra8unorm\", 0x05: \"rgba16float\", 0x06: \"rgba32float\",\n      0x10: \"depth24plus\", 0x11: \"depth24plus-stencil8\", 0x12: \"depth32float\",\n    };\n    return formats[value] || navigator.gpu.getPreferredCanvasFormat();\n  }\n\n  _decodeTextureUsage(value) {\n    let usage = 0;\n    if (value & 0x01) usage |= GPUTextureUsage.COPY_SRC;\n    if (value & 0x02) usage |= GPUTextureUsage.COPY_DST;\n    if (value & 0x04) usage |= GPUTextureUsage.TEXTURE_BINDING;\n    if (value & 0x08) usage |= GPUTextureUsage.STORAGE_BINDING;\n    if (value & 0x10) usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n    return usage || GPUTextureUsage.RENDER_ATTACHMENT;\n  }\n\n  _beginRenderPass(colorId, loadOp, storeOp, depthId) {\n    if (!this.encoder) {\n      this.encoder = this.device.createCommandEncoder();\n    }\n\n    // 0xFFFE (65534) = use canvas, else use texture\n    const CANVAS_TEXTURE_ID = 0xfffe;\n    const colorView =\n      colorId === CANVAS_TEXTURE_ID\n        ? this.context.getCurrentTexture().createView()\n        : this.textures.get(colorId)?.createView();\n\n    // loadOp: 0=load, 1=clear\n    // storeOp: 0=store, 1=discard\n    const loadOpStr = loadOp === 1 ? \"clear\" : \"load\";\n    const storeOpStr = storeOp === 0 ? \"store\" : \"discard\";\n\n    const passDesc = {\n      colorAttachments: [\n        {\n          view: colorView,\n          loadOp: loadOpStr,\n          storeOp: storeOpStr,\n          clearValue: { r: 0, g: 0, b: 0, a: 1 },\n        },\n      ],\n    };\n\n    if (depthId !== 0xffff) {\n      const depthView = this.textures.get(depthId)?.createView();\n      if (depthView) {\n        passDesc.depthStencilAttachment = {\n          view: depthView,\n          depthLoadOp: \"clear\",\n          depthStoreOp: \"store\",\n          depthClearValue: 1.0,\n        };\n      }\n    }\n\n    this.pass = this.encoder.beginRenderPass(passDesc);\n  }\n\n  _beginComputePass() {\n    if (!this.encoder) {\n      this.encoder = this.device.createCommandEncoder();\n    }\n    this.pass = this.encoder.beginComputePass();\n  }\n\n  _writeBuffer(id, offset, dataPtr, dataLen) {\n    const buffer = this.buffers.get(id);\n    if (!buffer) return;\n    const data = new Uint8Array(this.memory.buffer, dataPtr, dataLen);\n    this.device.queue.writeBuffer(buffer, offset, data);\n  }\n\n  _writeTimeUniform(id, offset, size) {\n    const buffer = this.buffers.get(id);\n    if (!buffer) return;\n    // pngineInputs: time, width, height, aspect\n    const data = new Float32Array([\n      this.time,\n      this.canvasWidth,\n      this.canvasHeight,\n      this.canvasWidth / (this.canvasHeight || 1),\n    ]);\n    const bytes = new Uint8Array(data.buffer, 0, Math.min(size, 16));\n    this.device.queue.writeBuffer(buffer, offset, bytes);\n  }\n\n  _readString(ptr, len) {\n    const bytes = new Uint8Array(this.memory.buffer, ptr, len);\n    return new TextDecoder().decode(bytes);\n  }\n\n  // Clean up resources\n  destroy() {\n    for (const buf of this.buffers.values()) buf.destroy?.();\n    for (const tex of this.textures.values()) tex.destroy?.();\n    this.buffers.clear();\n    this.textures.clear();\n    this.samplers.clear();\n    this.shaders.clear();\n    this.pipelines.clear();\n    this.bindGroups.clear();\n    this.bindGroupLayouts.clear();\n  }\n}\n\n\n// === _worker.js ===\n// Worker thread - owns WebGPU, WASM, and resources\n// Uses command buffer approach for minimal bundle size\n\n\nlet canvas, device, context, gpu, wasm, memory;\nlet initialized = false;\nlet moduleLoaded = false;\nlet frameCount = 0;\nlet log = () => {};\n\n// Message types\nconst MSG = {\n  INIT: \"init\",\n  DRAW: \"draw\",\n  LOAD: \"load\",\n  DESTROY: \"destroy\",\n  READY: \"ready\",\n  ERROR: \"error\",\n};\n\nonmessage = async (e) => {\n  const { type, ...data } = e.data;\n\n  try {\n    switch (type) {\n      case MSG.INIT:\n        await handleInit(data);\n        break;\n\n      case MSG.DRAW:\n        handleDraw(data);\n        break;\n\n      case MSG.LOAD:\n        await handleLoad(data);\n        break;\n\n      case MSG.DESTROY:\n        handleDestroy();\n        break;\n\n      default:\n        throw new Error(`Unknown message: ${type}`);\n    }\n  } catch (err) {\n    postMessage({ type: MSG.ERROR, message: err.message });\n  }\n};\n\nasync function handleInit(data) {\n  if (initialized) throw new Error(\"Already initialized\");\n\n  canvas = data.canvas;\n  log = data.debug ? console.log.bind(console, \"[Worker]\") : () => {};\n\n  // Initialize WebGPU\n  const adapter = await navigator.gpu?.requestAdapter();\n  if (!adapter) throw new Error(\"WebGPU not supported\");\n\n  device = await adapter.requestDevice();\n  context = canvas.getContext(\"webgpu\");\n  const format = navigator.gpu.getPreferredCanvasFormat();\n  context.configure({ device, format, alphaMode: \"premultiplied\" });\n\n  // Create command dispatcher\n  gpu = new CommandDispatcher(device, context);\n  gpu.setCanvasSize(canvas.width, canvas.height);\n\n  // Load WASM\n  if (!data.wasmUrl) throw new Error(\"wasmUrl required\");\n  const resp = await fetch(data.wasmUrl);\n  if (!resp.ok) throw new Error(`Failed to fetch WASM: ${resp.status}`);\n\n  const { instance } = await WebAssembly.instantiateStreaming(\n    resp,\n    getWasmImports()\n  );\n  wasm = instance.exports;\n  memory = wasm.memory;\n  gpu.setMemory(memory);\n\n  // Initialize WASM\n  wasm.onInit();\n  initialized = true;\n\n  log(\"Initialized\");\n\n  // If bytecode was provided, load it\n  if (data.bytecode) {\n    await loadBytecode(data.bytecode);\n  }\n\n  // Report ready\n  postMessage({\n    type: MSG.READY,\n    width: canvas.width,\n    height: canvas.height,\n    frameCount,\n  });\n}\n\nasync function handleLoad(data) {\n  if (!initialized) throw new Error(\"Not initialized\");\n  await loadBytecode(data.bytecode);\n  postMessage({ type: MSG.READY, frameCount });\n}\n\nasync function loadBytecode(bytecode) {\n  // Free previous module\n  if (moduleLoaded) {\n    wasm.freeModule();\n    gpu.destroy();\n    gpu = new CommandDispatcher(device, context);\n    gpu.setMemory(memory);\n    gpu.setCanvasSize(canvas.width, canvas.height);\n    moduleLoaded = false;\n  }\n\n  // Allocate and copy bytecode\n  const ptr = wasm.alloc(bytecode.byteLength);\n  if (!ptr) throw new Error(\"Failed to allocate memory\");\n\n  new Uint8Array(memory.buffer, ptr, bytecode.byteLength).set(\n    new Uint8Array(bytecode)\n  );\n\n  // Load module\n  const err = wasm.loadModule(ptr, bytecode.byteLength);\n  wasm.free(ptr, bytecode.byteLength);\n\n  if (err !== 0) throw new Error(`Load failed: ${err}`);\n\n  moduleLoaded = true;\n  frameCount = wasm.getFrameCount();\n\n  // First render to create resources\n  renderWithCommandBuffer(0, 0);\n\n  log(`Loaded module: ${frameCount} frames`);\n}\n\nfunction handleDraw(data) {\n  if (!initialized || !moduleLoaded) return;\n  // Note: frame name ignored for now - frame_id 0 executes all frames\n  renderWithCommandBuffer(data.time ?? 0, 0);\n}\n\nfunction renderWithCommandBuffer(time, frameId) {\n  gpu.setTime(time);\n\n  // Get command buffer from WASM\n  const ptr = wasm.renderFrame(time, frameId);\n  if (!ptr) {\n    log(\"renderFrame returned null\");\n    return;\n  }\n\n  // Execute commands\n  gpu.execute(ptr);\n}\n\nfunction handleDestroy() {\n  if (moduleLoaded) {\n    wasm.freeModule();\n    moduleLoaded = false;\n  }\n  gpu?.destroy();\n  if (device) {\n    device.destroy();\n    device = null;\n  }\n  initialized = false;\n  log(\"Destroyed\");\n}\n\n// WASM imports - mostly stubs since command buffer doesn't need them\nfunction getWasmImports() {\n  // Stub for all the old gpu* extern functions\n  const stub = () => {};\n\n  return {\n    env: {\n      // Old GPU functions (not used with command buffer, but WASM still imports them)\n      gpuCreateBuffer: stub,\n      gpuCreateTexture: stub,\n      gpuCreateSampler: stub,\n      gpuCreateShaderModule: stub,\n      gpuCreateRenderPipeline: stub,\n      gpuCreateComputePipeline: stub,\n      gpuCreateBindGroup: stub,\n      gpuCreateImageBitmap: stub,\n      gpuCreateTextureView: stub,\n      gpuCreateQuerySet: stub,\n      gpuCreateBindGroupLayout: stub,\n      gpuCreatePipelineLayout: stub,\n      gpuCreateRenderBundle: stub,\n      gpuBeginRenderPass: stub,\n      gpuBeginComputePass: stub,\n      gpuSetPipeline: stub,\n      gpuSetBindGroup: stub,\n      gpuSetVertexBuffer: stub,\n      gpuDraw: stub,\n      gpuDrawIndexed: stub,\n      gpuDispatch: stub,\n      gpuExecuteBundles: stub,\n      gpuEndPass: stub,\n      gpuWriteBuffer: stub,\n      gpuSubmit: stub,\n      gpuCopyExternalImageToTexture: stub,\n      gpuInitWasmModule: stub,\n      gpuCallWasmFunc: stub,\n      gpuWriteBufferFromWasm: stub,\n      gpuCreateTypedArray: stub,\n      gpuFillRandom: stub,\n      gpuFillExpression: stub,\n      gpuFillConstant: stub,\n      gpuWriteBufferFromArray: stub,\n      gpuWriteTimeUniform: stub,\n      gpuDebugLog: stub,\n      jsConsoleLog: (ptr, len) => {\n        const msg = new TextDecoder().decode(\n          new Uint8Array(memory.buffer, ptr, len)\n        );\n        log(msg);\n      },\n      jsConsoleLogInt: (ptr, len, value) => {\n        const msg = new TextDecoder().decode(\n          new Uint8Array(memory.buffer, ptr, len)\n        );\n        log(msg, value);\n      },\n    },\n  };\n}\n";

function createWorkerBlobUrl() {
  const blob = new Blob([WORKER_CODE], { type: 'application/javascript' });
  return URL.createObjectURL(blob);
}

// === _extract.js ===
// Bytecode extraction from PNG and ZIP files
// Runs on main thread

const PNG_SIG = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];
const PNGB_CHUNK = [0x70, 0x4e, 0x47, 0x62]; // 'pNGb'

/**
 * Check if data is PNG
 * @param {Uint8Array} b
 */
const isPng = (b) =>
  b.length >= 8 && PNG_SIG.every((v, i) => b[i] === v);

/**
 * Check if data is ZIP
 * @param {Uint8Array} b
 */
const isZip = (b) =>
  b.length >= 4 && b[0] === 0x50 && b[1] === 0x4b && (b[2] === 0x03 || b[2] === 0x05);

/**
 * Check if data is PNGB bytecode
 * @param {Uint8Array} b
 */
const isPngb = (b) =>
  b.length >= 4 && b[0] === 0x50 && b[1] === 0x4e && b[2] === 0x47 && b[3] === 0x42;

/**
 * Detect format
 * @param {Uint8Array} b
 * @returns {'png'|'zip'|'pngb'|null}
 */
function detectFormat(b) {
  if (isZip(b)) return "zip";
  if (isPng(b)) return "png";
  if (isPngb(b)) return "pngb";
  return null;
}

/**
 * Extract bytecode from any supported format
 * @param {ArrayBuffer|Uint8Array} data
 * @returns {Promise<Uint8Array>}
 */
async function extractBytecode(data) {
  const b = data instanceof Uint8Array ? data : new Uint8Array(data);
  const fmt = detectFormat(b);

  if (fmt === "pngb") return b;
  if (fmt === "png") return extractFromPng(b);
  if (fmt === "zip") return extractFromZip(b);

  throw new Error("Unknown format");
}

/**
 * Extract bytecode from PNG with pNGb chunk
 * @param {Uint8Array} b
 * @returns {Promise<Uint8Array>}
 */
async function extractFromPng(b) {
  if (!isPng(b)) throw new Error("Invalid PNG");

  let pos = 8;
  while (pos + 12 <= b.length) {
    const len = readU32BE(b, pos);
    const type = b.subarray(pos + 4, pos + 8);

    if (type[0] === PNGB_CHUNK[0] && type[1] === PNGB_CHUNK[1] &&
        type[2] === PNGB_CHUNK[2] && type[3] === PNGB_CHUNK[3]) {
      const chunk = b.subarray(pos + 8, pos + 8 + len);
      return parsePngbChunk(chunk);
    }
    pos += 12 + len;
  }

  throw new Error("No pNGb chunk found");
}

/**
 * Parse pNGb chunk data
 * @param {Uint8Array} data
 * @returns {Promise<Uint8Array>}
 */
async function parsePngbChunk(data) {
  if (data.length < 2) throw new Error("Invalid pNGb chunk");

  const version = data[0];
  const flags = data[1];
  const payload = data.subarray(2);

  if (version !== 1) throw new Error(`Unsupported pNGb version: ${version}`);

  // Compressed?
  if (flags & 1) {
    return decompress(payload);
  }
  return new Uint8Array(payload);
}

/**
 * Extract bytecode from ZIP bundle
 * @param {Uint8Array} b
 * @returns {Promise<Uint8Array>}
 */
async function extractFromZip(b) {
  // Find End of Central Directory
  let eocd = -1;
  for (let i = 22; i <= Math.min(b.length, 65557); i++) {
    const off = b.length - i;
    if (readU32LE(b, off) === 0x06054b50) {
      eocd = off;
      break;
    }
  }
  if (eocd === -1) throw new Error("Invalid ZIP");

  const entries = readU16LE(b, eocd + 10);
  let cdOff = readU32LE(b, eocd + 16);

  // Find manifest.json or first .pngb file
  let manifestEntry = null;
  let pngbEntry = null;

  for (let i = 0; i < entries; i++) {
    if (readU32LE(b, cdOff) !== 0x02014b50) break;

    const compression = readU16LE(b, cdOff + 10);
    const compSize = readU32LE(b, cdOff + 20);
    const uncompSize = readU32LE(b, cdOff + 24);
    const nameLen = readU16LE(b, cdOff + 28);
    const extraLen = readU16LE(b, cdOff + 30);
    const commentLen = readU16LE(b, cdOff + 32);
    const localOff = readU32LE(b, cdOff + 42);

    const name = new TextDecoder().decode(b.subarray(cdOff + 46, cdOff + 46 + nameLen));

    const localExtraLen = readU16LE(b, localOff + 28);
    const dataOff = localOff + 30 + nameLen + localExtraLen;

    const entry = { name, compression, compSize, uncompSize, dataOff };

    if (name === "manifest.json") manifestEntry = entry;
    else if (name.endsWith(".pngb") && !pngbEntry) pngbEntry = entry;

    cdOff += 46 + nameLen + extraLen + commentLen;
  }

  // Try manifest first
  if (manifestEntry) {
    const manifest = JSON.parse(
      new TextDecoder().decode(await extractEntry(b, manifestEntry))
    );
    if (manifest.entry) {
      // Find entry file
      cdOff = readU32LE(b, eocd + 16);
      for (let i = 0; i < entries; i++) {
        if (readU32LE(b, cdOff) !== 0x02014b50) break;
        const nameLen = readU16LE(b, cdOff + 28);
        const name = new TextDecoder().decode(b.subarray(cdOff + 46, cdOff + 46 + nameLen));
        if (name === manifest.entry) {
          const compression = readU16LE(b, cdOff + 10);
          const compSize = readU32LE(b, cdOff + 20);
          const uncompSize = readU32LE(b, cdOff + 24);
          const extraLen = readU16LE(b, cdOff + 30);
          const commentLen = readU16LE(b, cdOff + 32);
          const localOff = readU32LE(b, cdOff + 42);
          const localExtraLen = readU16LE(b, localOff + 28);
          const dataOff = localOff + 30 + nameLen + localExtraLen;
          return extractEntry(b, { compression, compSize, uncompSize, dataOff });
        }
        cdOff += 46 + nameLen + readU16LE(b, cdOff + 30) + readU16LE(b, cdOff + 32);
      }
    }
  }

  // Fallback to first .pngb
  if (pngbEntry) {
    return extractEntry(b, pngbEntry);
  }

  throw new Error("No bytecode found in ZIP");
}

/**
 * Extract ZIP entry data
 */
async function extractEntry(b, entry) {
  const data = b.subarray(entry.dataOff, entry.dataOff + entry.compSize);
  if (entry.compression === 0) return new Uint8Array(data);
  if (entry.compression === 8) return decompress(data);
  throw new Error(`Unsupported compression: ${entry.compression}`);
}

/**
 * Decompress deflate-raw data
 * @param {Uint8Array} data
 * @returns {Promise<Uint8Array>}
 */
async function decompress(data) {
  const ds = new DecompressionStream("deflate-raw");
  const writer = ds.writable.getWriter();
  const reader = ds.readable.getReader();

  writer.write(data);
  writer.close();

  const chunks = [];
  let len = 0;

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    chunks.push(value);
    len += value.length;
  }

  const result = new Uint8Array(len);
  let off = 0;
  for (const c of chunks) {
    result.set(c, off);
    off += c.length;
  }

  return result;
}

// Little-endian readers
const readU16LE = (b, o) => b[o] | (b[o + 1] << 8);
const readU32LE = (b, o) => (b[o] | (b[o + 1] << 8) | (b[o + 2] << 16) | (b[o + 3] << 24)) >>> 0;
const readU32BE = (b, o) => ((b[o] << 24) | (b[o + 1] << 16) | (b[o + 2] << 8) | b[o + 3]) >>> 0;


// === _anim.js ===
// Animation and playback control
// Runs on main thread, posts draw commands to worker

/**
 * Draw a frame (sync, post-and-forget)
 * @param {Pngine} p
 * @param {Object} [opts]
 * @param {number} [opts.time]
 * @param {string} [opts.frame]
 * @param {Object} [opts.uniforms]
 */
function draw(p, opts = {}) {
  const i = p._;
  if (!i) throw new Error("Pngine destroyed");
  if (!i.ready) throw new Error("Not initialized");

  // Post to worker (sync - returns immediately)
  i.worker.postMessage({
    type: "draw",
    time: opts.time ?? i.time,
    frame: opts.frame ?? null,
    uniforms: opts.uniforms ?? null,
  });

  // Update local time if provided
  if (opts.time !== undefined) {
    i.time = opts.time;
  }
}

/**
 * Start animation loop
 * @param {Pngine} p
 * @returns {Pngine}
 */
function play(p) {
  const i = p._;
  if (!i || i.playing) return p;

  i.playing = true;
  i.startTime = performance.now() - i.time * 1000;

  const loop = () => {
    if (!i.playing) return;

    const now = performance.now();
    i.time = (now - i.startTime) / 1000;

    draw(p, { time: i.time });

    i.animationId = requestAnimationFrame(loop);
  };

  i.animationId = requestAnimationFrame(loop);
  i.log?.("Playing");
  return p;
}

/**
 * Pause animation
 * @param {Pngine} p
 * @returns {Pngine}
 */
function pause(p) {
  const i = p._;
  if (!i || !i.playing) return p;

  i.playing = false;
  i.time = (performance.now() - i.startTime) / 1000;

  if (i.animationId) {
    cancelAnimationFrame(i.animationId);
    i.animationId = null;
  }

  i.log?.("Paused");
  return p;
}

/**
 * Stop animation and reset to start
 * @param {Pngine} p
 * @returns {Pngine}
 */
function stop(p) {
  pause(p);

  const i = p._;
  if (!i) return p;

  i.time = 0;
  i.startTime = performance.now();

  draw(p, { time: 0 });
  i.log?.("Stopped");
  return p;
}

/**
 * Seek to specific time
 * @param {Pngine} p
 * @param {number} time - Time in seconds
 * @returns {Pngine}
 */
function seek(p, time) {
  const i = p._;
  if (!i) return p;

  i.time = time;

  if (i.playing) {
    i.startTime = performance.now() - time * 1000;
  }

  draw(p, { time });
  return p;
}

/**
 * Set specific frame to render
 * @param {Pngine} p
 * @param {string|null} frame - Frame name or null for all
 * @returns {Pngine}
 */
function setFrame(p, frame) {
  const i = p._;
  if (!i) return p;

  i.currentFrame = frame;
  draw(p, { time: i.time, frame });
  return p;
}


// === _init.js (modified for inline worker) ===
// Main thread initialization
// Spawns worker, creates POJO


// Worker URL (will be replaced with blob URL by bundler)
let workerUrl = null;

/**
 * Initialize PNGine from various sources
 * @param {string|ArrayBuffer|Blob|Uint8Array|HTMLImageElement} source
 * @param {Object} [options]
 * @param {HTMLCanvasElement} [options.canvas]
 * @param {boolean} [options.debug]
 * @param {string} [options.wasmUrl]
 * @param {(err: Error) => void} [options.onError]
 * @returns {Promise<Pngine>}
 */
async function pngine(source, options = {}) {
  const log = options.debug ? console.log.bind(console, "[PNGine]") : () => {};

  // Resolve source to canvas + bytecode
  let canvas, bytecode;

  if (typeof source === "string") {
    // Check for CSS selector (# or . but not ../ which is a relative path)
    const isSelector = source.startsWith("#") || (source.startsWith(".") && !source.startsWith(".."));
    if (isSelector) {
      // Query selector
      const el = document.querySelector(source);
      if (!el) throw new Error(`Element not found: ${source}`);

      if (el instanceof HTMLImageElement) {
        ({ canvas, bytecode } = await initFromImage(el, options, log));
      } else if (el instanceof HTMLCanvasElement) {
        canvas = el;
        throw new Error("Canvas source requires URL or data");
      } else {
        throw new Error(`Invalid element type`);
      }
    } else {
      // URL
      canvas = options.canvas;
      if (!canvas) throw new Error("Canvas required for URL source");
      log(`Fetching: ${source}`);
      const resp = await fetch(source);
      if (!resp.ok) throw new Error(`Fetch failed: ${resp.status}`);
      bytecode = await extractBytecode(await resp.arrayBuffer());
    }
  } else if (source instanceof HTMLImageElement) {
    ({ canvas, bytecode } = await initFromImage(source, options, log));
  } else if (
    source instanceof ArrayBuffer ||
    source instanceof Uint8Array ||
    source instanceof Blob
  ) {
    canvas = options.canvas;
    if (!canvas) throw new Error("Canvas required for data source");
    const data = source instanceof Blob ? await source.arrayBuffer() : source;
    bytecode = await extractBytecode(data);
  } else {
    throw new Error("Invalid source type");
  }

  log(`Canvas: ${canvas.width}x${canvas.height}`);
  log(`Bytecode: ${bytecode.byteLength} bytes`);

  // Get OffscreenCanvas
  const offscreen = canvas.transferControlToOffscreen();

  // Spawn worker
  const worker = new Worker(createWorkerBlobUrl());

  // Wait for ready
  const result = await new Promise((resolve, reject) => {
    const timeout = setTimeout(
      () => reject(new Error("Worker init timeout")),
      15000
    );

    worker.onmessage = (e) => {
      if (e.data.type === "ready") {
        clearTimeout(timeout);
        resolve(e.data);
      } else if (e.data.type === "error") {
        clearTimeout(timeout);
        reject(new Error(e.data.message));
      }
    };

    worker.onerror = (e) => {
      clearTimeout(timeout);
      reject(new Error(e.message || "Worker error"));
    };

    // Compute WASM URL - must be absolute for worker blob context
    const wasmUrl = options.wasmUrl
      ? new URL(options.wasmUrl, window.location.href).href
      : new URL("pngine.wasm", import.meta.url).href;

    // Send init
    worker.postMessage(
      {
        type: "init",
        canvas: offscreen,
        bytecode,
        wasmUrl,
        debug: options.debug || false,
      },
      [offscreen, bytecode.buffer]
    );
  });

  // Set up error handler
  worker.onmessage = (e) => {
    if (e.data.type === "error" && options.onError) {
      options.onError(new Error(e.data.message));
    }
  };

  log(`Ready: ${result.frameCount} frames`);

  // Create POJO
  return createPngine({
    canvas,
    worker,
    width: result.width,
    height: result.height,
    frameCount: result.frameCount,
    ready: true,
    playing: false,
    time: 0,
    startTime: 0,
    animationId: null,
    debug: options.debug || false,
    log,
  });
}

/**
 * Initialize from image element
 */
async function initFromImage(img, options, log) {
  // Wait for image to load if needed
  if (!img.complete) {
    await new Promise((resolve, reject) => {
      img.onload = resolve;
      img.onerror = reject;
    });
  }

  const { naturalWidth: w, naturalHeight: h } = img;
  if (w === 0 || h === 0) throw new Error("Image has no dimensions");

  log(`Image: ${w}x${h} from ${img.src}`);

  // Create canvas
  const canvas = options.canvas || document.createElement("canvas");
  canvas.width = w;
  canvas.height = h;

  // Position canvas over image if not provided
  if (!options.canvas) {
    const parent = img.parentElement;
    if (parent && getComputedStyle(parent).position === "static") {
      parent.style.position = "relative";
    }

    Object.assign(canvas.style, {
      position: "absolute",
      top: img.offsetTop + "px",
      left: img.offsetLeft + "px",
      width: img.offsetWidth + "px",
      height: img.offsetHeight + "px",
      pointerEvents: "none",
    });

    if (parent) parent.appendChild(canvas);
  }

  // Fetch bytecode from image src
  const resp = await fetch(img.src);
  if (!resp.ok) throw new Error(`Failed to fetch image: ${resp.status}`);
  const bytecode = await extractBytecode(await resp.arrayBuffer());

  return { canvas, bytecode };
}

/**
 * Create Pngine POJO with getters
 */
function createPngine(internal) {
  return {
    get width() {
      return internal.width;
    },
    get height() {
      return internal.height;
    },
    get isPlaying() {
      return internal.playing;
    },
    get time() {
      return internal.time;
    },
    get frameCount() {
      return internal.frameCount;
    },

    // Internal state (for other functions)
    _: internal,
  };
}

/**
 * Destroy pngine instance
 * @param {Pngine} p
 * @returns {Pngine}
 */
function destroy(p) {
  const i = p._;
  if (!i) return p;

  if (i.animationId) cancelAnimationFrame(i.animationId);
  i.worker.postMessage({ type: "destroy" });
  i.worker.terminate();

  p._ = null;
  i.log("Destroyed");
  return p;
}

/**
 * Get worker URL (inline or separate file)
 */
function getWorkerUrl() { return createWorkerBlobUrl(); }

/**
 * Set worker URL (called by bundler)
 */
function setWorkerUrl(url) {
  workerUrl = url;
}


// === Exports ===
export { pngine, destroy };
export { draw, play, pause, stop, seek, setFrame };
export { extractBytecode, detectFormat, isPng, isZip, isPngb };
