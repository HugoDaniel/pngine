var S='var f={CREATE_BUFFER:1,CREATE_TEXTURE:2,CREATE_SAMPLER:3,CREATE_SHADER:4,CREATE_RENDER_PIPELINE:5,CREATE_COMPUTE_PIPELINE:6,CREATE_BIND_GROUP:7,CREATE_TEXTURE_VIEW:8,CREATE_QUERY_SET:9,CREATE_BIND_GROUP_LAYOUT:10,CREATE_IMAGE_BITMAP:11,CREATE_PIPELINE_LAYOUT:12,CREATE_RENDER_BUNDLE:13,BEGIN_RENDER_PASS:16,BEGIN_COMPUTE_PASS:17,SET_PIPELINE:18,SET_BIND_GROUP:19,SET_VERTEX_BUFFER:20,DRAW:21,DRAW_INDEXED:22,END_PASS:23,DISPATCH:24,SET_INDEX_BUFFER:25,EXECUTE_BUNDLES:26,WRITE_BUFFER:32,WRITE_TIME_UNIFORM:33,COPY_BUFFER_TO_BUFFER:34,COPY_TEXTURE_TO_TEXTURE:35,WRITE_BUFFER_FROM_WASM:36,COPY_EXTERNAL_IMAGE_TO_TEXTURE:37,INIT_WASM_MODULE:48,CALL_WASM_FUNC:49,CREATE_TYPED_ARRAY:64,FILL_RANDOM:65,FILL_EXPRESSION:66,FILL_CONSTANT:67,WRITE_BUFFER_FROM_ARRAY:68,SUBMIT:240,END:255},T={MAP_READ:1,MAP_WRITE:2,COPY_SRC:4,COPY_DST:8,INDEX:16,VERTEX:32,UNIFORM:64,STORAGE:128},G=class{constructor(r,t){this.device=r,this.context=t,this.memory=null,this.debug=!1,this.buffers=new Map,this.textures=new Map,this.textureViews=new Map,this.samplers=new Map,this.shaders=new Map,this.pipelines=new Map,this.bindGroups=new Map,this.bindGroupLayouts=new Map,this.pipelineLayouts=new Map,this.querySets=new Map,this.renderBundles=new Map,this.imageBitmaps=new Map,this.wasmModules=new Map,this.wasmCallResults=new Map,this.typedArrays=new Map,this.bindGroupDescriptors=new Map,this.textureDescriptors=new Map,this.encoder=null,this.pass=null,this.time=0,this.canvasWidth=0,this.canvasHeight=0}setDebug(r){this.debug=r}setMemory(r){this.memory=r}setTime(r){this.time=r}setCanvasSize(r,t){this.canvasWidth=r,this.canvasHeight=t}async execute(r){let t=new DataView(this.memory.buffer),e=t.getUint32(r,!0),n=t.getUint16(r+4,!0);this.debug&&console.log(`[GPU] Execute: ${n} commands, ${e} bytes`);let s=r+8,i=r+e;for(let o=0;o<n&&s<i;o++){let c=t.getUint8(s++);this.debug&&console.log(`[GPU] Cmd ${o}: 0x${c.toString(16)}`);let a=this._dispatch(c,t,s);a instanceof Promise?(s=await a,t=new DataView(this.memory.buffer)):s=a}}_dispatch(r,t,e){switch(r){case f.CREATE_BUFFER:{let n=t.getUint16(e,!0),s=t.getUint32(e+2,!0),i=t.getUint8(e+6);return this._createBuffer(n,s,i),e+7}case f.CREATE_SHADER:{let n=t.getUint16(e,!0),s=t.getUint32(e+2,!0),i=t.getUint32(e+6,!0);return this._createShader(n,s,i),e+10}case f.CREATE_RENDER_PIPELINE:{let n=t.getUint16(e,!0),s=t.getUint32(e+2,!0),i=t.getUint32(e+6,!0);return this._createRenderPipeline(n,s,i),e+10}case f.CREATE_COMPUTE_PIPELINE:{let n=t.getUint16(e,!0),s=t.getUint32(e+2,!0),i=t.getUint32(e+6,!0);return this._createComputePipeline(n,s,i),e+10}case f.CREATE_BIND_GROUP:{let n=t.getUint16(e,!0),s=t.getUint16(e+2,!0),i=t.getUint32(e+4,!0),o=t.getUint32(e+8,!0);return this._createBindGroup(n,s,i,o),e+12}case f.CREATE_TEXTURE:{let n=t.getUint16(e,!0),s=t.getUint32(e+2,!0),i=t.getUint32(e+6,!0);return this._createTexture(n,s,i),e+10}case f.CREATE_SAMPLER:{let n=t.getUint16(e,!0),s=t.getUint32(e+2,!0),i=t.getUint32(e+6,!0);return this._createSampler(n,s,i),e+10}case f.CREATE_TEXTURE_VIEW:{let n=t.getUint16(e,!0),s=t.getUint16(e+2,!0),i=t.getUint32(e+4,!0),o=t.getUint32(e+8,!0);return this._createTextureView(n,s,i,o),e+12}case f.CREATE_QUERY_SET:{let n=t.getUint16(e,!0),s=t.getUint32(e+2,!0),i=t.getUint32(e+6,!0);return this._createQuerySet(n,s,i),e+10}case f.CREATE_BIND_GROUP_LAYOUT:{let n=t.getUint16(e,!0),s=t.getUint32(e+2,!0),i=t.getUint32(e+6,!0);return this._createBindGroupLayout(n,s,i),e+10}case f.CREATE_PIPELINE_LAYOUT:{let n=t.getUint16(e,!0),s=t.getUint32(e+2,!0),i=t.getUint32(e+6,!0);return this._createPipelineLayout(n,s,i),e+10}case f.CREATE_RENDER_BUNDLE:{let n=t.getUint16(e,!0),s=t.getUint32(e+2,!0),i=t.getUint32(e+6,!0);return this._createRenderBundle(n,s,i),e+10}case f.BEGIN_RENDER_PASS:{let n=t.getUint16(e,!0),s=t.getUint8(e+2),i=t.getUint8(e+3),o=t.getUint16(e+4,!0);return this._beginRenderPass(n,s,i,o),e+6}case f.BEGIN_COMPUTE_PASS:return this._beginComputePass(),e;case f.SET_PIPELINE:{let n=t.getUint16(e,!0),s=this.pipelines.get(n);return this.debug&&console.log(`[GPU] setPipeline(id=${n}, pipeline=${s?"OK":"MISSING"})`),this.pass?.setPipeline(s),e+2}case f.SET_BIND_GROUP:{let n=t.getUint8(e),s=t.getUint16(e+1,!0),i=this.bindGroups.get(s);return this.debug&&console.log(`[GPU] setBindGroup(slot=${n}, id=${s}, bg=${i?"OK":"MISSING"})`),this.pass?.setBindGroup(n,i),e+3}case f.SET_VERTEX_BUFFER:{let n=t.getUint8(e),s=t.getUint16(e+1,!0),i=this.buffers.get(s);return this.debug&&console.log(`[GPU] setVertexBuffer(slot=${n}, id=${s}, buf=${i?"OK":"MISSING"})`),this.pass?.setVertexBuffer(n,i),e+3}case f.SET_INDEX_BUFFER:{let n=t.getUint16(e,!0),i=t.getUint8(e+2)===1?"uint32":"uint16";return this.pass?.setIndexBuffer(this.buffers.get(n),i),e+3}case f.EXECUTE_BUNDLES:{let n=t.getUint8(e),s=[];for(let i=0;i<n;i++){let o=t.getUint16(e+1+i*2,!0),c=this.renderBundles.get(o);c&&s.push(c)}return this.pass?.executeBundles(s),e+1+n*2}case f.DRAW:{let n=t.getUint32(e,!0),s=t.getUint32(e+4,!0),i=t.getUint32(e+8,!0),o=t.getUint32(e+12,!0);return this.debug&&console.log(`[GPU] draw(vtx=${n}, inst=${s}, firstVtx=${i}, firstInst=${o})`),this.pass?.draw(n,s,i,o),e+16}case f.DRAW_INDEXED:{let n=t.getUint32(e,!0),s=t.getUint32(e+4,!0),i=t.getUint32(e+8,!0),o=t.getInt32(e+12,!0),c=t.getUint32(e+16,!0);return this.pass?.drawIndexed(n,s,i,o,c),e+20}case f.DISPATCH:{let n=t.getUint32(e,!0),s=t.getUint32(e+4,!0),i=t.getUint32(e+8,!0);return this.debug&&console.log(`[GPU] dispatch(${n}, ${s}, ${i})`),this.pass?.dispatchWorkgroups(n,s,i),e+12}case f.END_PASS:return this.debug&&console.log(`[GPU] endPass(pass=${this.pass?"OK":"NULL"})`),this.pass?.end(),this.pass=null,e;case f.WRITE_BUFFER:{let n=t.getUint16(e,!0),s=t.getUint32(e+2,!0),i=t.getUint32(e+6,!0),o=t.getUint32(e+10,!0);return this._writeBuffer(n,s,i,o),e+14}case f.WRITE_TIME_UNIFORM:{let n=t.getUint16(e,!0),s=t.getUint32(e+2,!0),i=t.getUint16(e+6,!0);return this._writeTimeUniform(n,s,i),e+8}case f.CREATE_IMAGE_BITMAP:{let n=t.getUint16(e,!0),s=t.getUint32(e+2,!0),i=t.getUint32(e+6,!0);return this._createImageBitmap(n,s,i),e+10}case f.COPY_EXTERNAL_IMAGE_TO_TEXTURE:{let n=t.getUint16(e,!0),s=t.getUint16(e+2,!0),i=t.getUint8(e+4),o=t.getUint16(e+5,!0),c=t.getUint16(e+7,!0),a=e+9;return this._copyExternalImageToTexture(n,s,i,o,c).then(()=>a)}case f.COPY_BUFFER_TO_BUFFER:{let n=t.getUint16(e,!0),s=t.getUint32(e+2,!0),i=t.getUint16(e+6,!0),o=t.getUint32(e+8,!0),c=t.getUint32(e+12,!0);return this._copyBufferToBuffer(n,s,i,o,c),e+16}case f.COPY_TEXTURE_TO_TEXTURE:{let n=t.getUint16(e,!0),s=t.getUint16(e+2,!0),i=t.getUint16(e+4,!0),o=t.getUint16(e+6,!0);return this._copyTextureToTexture(n,s,i,o),e+8}case f.WRITE_BUFFER_FROM_WASM:{let n=t.getUint16(e,!0),s=t.getUint32(e+2,!0),i=t.getUint32(e+6,!0),o=t.getUint32(e+10,!0);return this._writeBufferFromWasm(n,s,i,o),e+14}case f.INIT_WASM_MODULE:{let n=t.getUint16(e,!0),s=t.getUint32(e+2,!0),i=t.getUint32(e+6,!0);return this._initWasmModule(n,s,i),e+10}case f.CALL_WASM_FUNC:{let n=t.getUint16(e,!0),s=t.getUint16(e+2,!0),i=t.getUint32(e+4,!0),o=t.getUint32(e+8,!0),c=t.getUint8(e+12),a=new Uint8Array(this.memory.buffer,e+13,c).slice(),l=e+13+c;return this._callWasmFunc(n,s,i,o,a).then(()=>l)}case f.CREATE_TYPED_ARRAY:{let n=t.getUint16(e,!0),s=t.getUint8(e+2),i=t.getUint32(e+3,!0);return this._createTypedArray(n,s,i),e+7}case f.FILL_RANDOM:{let n=t.getUint16(e,!0),s=t.getUint32(e+2,!0),i=t.getUint32(e+6,!0),o=t.getUint8(e+10),c=t.getUint32(e+11,!0);return this._fillRandom(n,s,i,o,c),e+15}case f.FILL_EXPRESSION:{let n=t.getUint16(e,!0),s=t.getUint32(e+2,!0),i=t.getUint32(e+6,!0),o=t.getUint8(e+10),c=t.getUint32(e+11,!0),a=t.getUint16(e+15,!0);return this._fillExpression(n,s,i,o,c,a),e+17}case f.FILL_CONSTANT:{let n=t.getUint16(e,!0),s=t.getUint32(e+2,!0),i=t.getUint32(e+6,!0),o=t.getUint8(e+10),c=t.getUint32(e+11,!0);return this._fillConstant(n,s,i,o,c),e+15}case f.WRITE_BUFFER_FROM_ARRAY:{let n=t.getUint16(e,!0),s=t.getUint32(e+2,!0),i=t.getUint16(e+6,!0);return this._writeBufferFromArray(n,s,i),e+8}case f.SUBMIT:return this.debug&&console.log(`[GPU] submit(encoder=${this.encoder?"OK":"NULL"})`),this.encoder&&(this.device.queue.submit([this.encoder.finish()]),this.encoder=null),e;case f.END:return e;default:return console.warn(`Unknown command: 0x${r.toString(16)}`),e}}_createBuffer(r,t,e){if(this.buffers.has(r))return;let n=this._translateUsage(e);this.debug&&console.log(`[GPU] createBuffer(id=${r}, size=${t}, usage=0x${e.toString(16)})`),this.buffers.set(r,this.device.createBuffer({size:t,usage:n}))}_translateUsage(r){let t=0;return r&T.MAP_READ&&(t|=GPUBufferUsage.MAP_READ),r&T.MAP_WRITE&&(t|=GPUBufferUsage.MAP_WRITE),r&T.COPY_SRC&&(t|=GPUBufferUsage.COPY_SRC),r&T.COPY_DST&&(t|=GPUBufferUsage.COPY_DST),r&T.INDEX&&(t|=GPUBufferUsage.INDEX),r&T.VERTEX&&(t|=GPUBufferUsage.VERTEX),r&T.UNIFORM&&(t|=GPUBufferUsage.UNIFORM),r&T.STORAGE&&(t|=GPUBufferUsage.STORAGE),t||GPUBufferUsage.COPY_DST}_createShader(r,t,e){if(this.shaders.has(r))return;let n=this._readString(t,e);this.debug&&console.log(`[GPU] createShader(id=${r}, len=${e}, first50chars="${n.slice(0,50)}")`),this.shaders.set(r,this.device.createShaderModule({code:n}))}_createRenderPipeline(r,t,e){if(this.pipelines.has(r))return;let n=this._readString(t,e);if(!n||n.length===0){console.error(`[GPU] Empty pipeline descriptor for id=${r}, ptr=${t}, len=${e}`);return}let s=JSON.parse(n);this.debug&&(console.log(`[GPU] createRenderPipeline(id=${r})`),console.log("[GPU]   vertex=",JSON.stringify(s.vertex)),console.log("[GPU]   fragment=",JSON.stringify(s.fragment)),console.log("[GPU]   primitive=",JSON.stringify(s.primitive)),console.log("[GPU]   depthStencil=",JSON.stringify(s.depthStencil)),console.log("[GPU]   full json=",n));let i=this._buildRenderPipeline(s);this.pipelines.set(r,i),this.bindGroupLayouts.set(r,i.getBindGroupLayout(0))}_buildRenderPipeline(r){let t=navigator.gpu.getPreferredCanvasFormat();return this.device.createRenderPipeline({layout:"auto",vertex:{module:this.shaders.get(r.vertex?.shader??0),entryPoint:r.vertex?.entryPoint??"vs_main",buffers:r.vertex?.buffers??[]},fragment:{module:this.shaders.get(r.fragment?.shader??r.vertex?.shader??0),entryPoint:r.fragment?.entryPoint??"fs_main",targets:[{format:t}]},primitive:r.primitive??{topology:"triangle-list"},depthStencil:r.depthStencil})}_createComputePipeline(r,t,e){if(this.pipelines.has(r))return;let n=this._readString(t,e);if(!n||n.length===0){console.error(`[GPU] Empty compute pipeline descriptor for id=${r}, ptr=${t}, len=${e}`);return}let s=JSON.parse(n),i="auto";s.layout&&s.layout!=="auto"&&(i=this.pipelineLayouts.get(s.layout)??"auto");let o=this.device.createComputePipeline({layout:i,compute:{module:this.shaders.get(s.compute?.shader??0),entryPoint:s.compute?.entryPoint??"main"}});this.pipelines.set(r,o),i==="auto"&&this.bindGroupLayouts.set(r,o.getBindGroupLayout(0))}_createBindGroup(r,t,e,n){if(this.bindGroups.has(r))return;let s=new Uint8Array(this.memory.buffer,e,n),i=this._decodeBindGroupDescriptor(s);if(this.debug){console.log(`[GPU] createBindGroup(id=${r}, layoutId=${t})`),console.log(`[GPU]   groupIndex=${i.groupIndex}, entries=${i.entries.length}`);for(let a of i.entries)console.log(`[GPU]   entry: binding=${a.binding}, resourceType=${a.resourceType}, resourceId=${a.resourceId}, offset=${a.offset}, size=${a.size}`)}i.layoutId=t,this.bindGroupDescriptors.set(r,i);let o=this.pipelines.get(t);if(!o){console.error(`[GPU] Pipeline ${t} not found for bind group ${r}`);return}let c=i.entries.map(a=>{let l={binding:a.binding};if(a.resourceType===0){let d=this.buffers.get(a.resourceId);this.debug&&console.log(`[GPU]   resolving buffer resourceId=${a.resourceId} -> ${d?"OK":"MISSING"}`);let g={buffer:d};a.offset&&(g.offset=a.offset),a.size&&(g.size=a.size),l.resource=g}else a.resourceType===1?l.resource=this.textures.get(a.resourceId)?.createView():a.resourceType===2&&(l.resource=this.samplers.get(a.resourceId));return l});this.debug&&console.log("[GPU]   gpuEntries:",JSON.stringify(c.map(a=>({binding:a.binding,hasResource:!!a.resource}))));try{let a=o.getBindGroupLayout(i.groupIndex);this.debug&&console.log(`[GPU]   layout from pipeline.getBindGroupLayout(${i.groupIndex}): ${a?"OK":"NULL"}`),this.bindGroups.set(r,this.device.createBindGroup({layout:a,entries:c})),this.debug&&console.log("[GPU]   bind group created successfully")}catch(a){console.error(`[GPU] Failed to create bind group ${r}:`,a)}}_decodeBindGroupDescriptor(r){let t=new DataView(r.buffer,r.byteOffset,r.byteLength),e=0,n=r[e++];if(n!==3)return console.error(`[GPU] Invalid bind group descriptor type tag: ${n}`),{groupIndex:0,entries:[]};let s=r[e++],i=0,o=[],c=1,a=2,l=3,d=7;for(let g=0;g<s;g++){let U=r[e++],m=r[e++];if(U===c&&m===d)i=r[e++];else if(U===a&&m===l){let D=r[e++];for(let I=0;I<D;I++){let y=r[e++],b=r[e++],x=t.getUint16(e,!0);e+=2;let B={binding:y,resourceType:b,resourceId:x};b===0&&(B.offset=t.getUint32(e,!0),e+=4,B.size=t.getUint32(e,!0),e+=4),o.push(B)}}}return{groupIndex:i,entries:o}}_createTexture(r,t,e){if(this.textures.has(r))return;let n=new Uint8Array(this.memory.buffer,t,e),s=this._decodeTextureDescriptor(n);this.debug&&console.log(`[GPU] createTexture(id=${r}, format=${s.format}, size=${s.size}, usage=${s.usage})`),this.textureDescriptors.set(r,{format:s.format,usage:s.usage}),this.textures.set(r,this.device.createTexture(s))}_createSampler(r,t,e){if(this.samplers.has(r))return;let n=new Uint8Array(this.memory.buffer,t,e),s=this._decodeSamplerDescriptor(n);this.samplers.set(r,this.device.createSampler(s))}_decodeTextureDescriptor(r){let t=new DataView(r.buffer,r.byteOffset,r.byteLength),e=0,n=r[e++];if(n!==1)return console.error(`[GPU] Invalid texture descriptor type tag: ${n}`),{size:[256,256],format:"rgba8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT};let s=r[e++],i={size:[this.canvasWidth||512,this.canvasHeight||512],format:navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT,sampleCount:1},o=1,c=2,a=5,l=7,d=8,g=10,U=0,m=6,D=7;for(let I=0;I<s;I++){let y=r[e++],b=r[e++];if(b===U){let x=t.getUint32(e,!0);e+=4,y===o?i.size[0]=x:y===c?i.size[1]=x:y===a&&(i.sampleCount=x)}else if(b===m){let x=t.getUint16(e,!0);e+=2,y===g&&(i.size=[1,1],i.imageBitmapId=x)}else if(b===D){let x=r[e++];y===l?i.format=this._decodeTextureFormat(x):y===d&&(i.usage=this._decodeTextureUsage(x))}}return i}_decodeSamplerDescriptor(r){let t=0,e=r[t++];if(e!==2)return console.error(`[GPU] Invalid sampler descriptor type tag: ${e}`),{};let n=r[t++],s={magFilter:"linear",minFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"},i=1,o=2,c=4,a=5,l=7;for(let d=0;d<n;d++){let g=r[t++];if(r[t++]===l){let m=r[t++];g===c?s.magFilter=m===0?"nearest":"linear":g===a?s.minFilter=m===0?"nearest":"linear":g===i?s.addressModeU=["clamp-to-edge","repeat","mirror-repeat"][m]||"clamp-to-edge":g===o&&(s.addressModeV=["clamp-to-edge","repeat","mirror-repeat"][m]||"clamp-to-edge")}}return s}_decodeTextureFormat(r){return{0:"rgba8unorm",1:"rgba8snorm",2:"rgba8uint",3:"rgba8sint",4:"bgra8unorm",5:"rgba16float",6:"rgba32float",16:"depth24plus",17:"depth24plus-stencil8",18:"depth32float"}[r]||navigator.gpu.getPreferredCanvasFormat()}_decodeTextureUsage(r){let t=0;return r&1&&(t|=GPUTextureUsage.COPY_SRC),r&2&&(t|=GPUTextureUsage.COPY_DST),r&4&&(t|=GPUTextureUsage.TEXTURE_BINDING),r&8&&(t|=GPUTextureUsage.STORAGE_BINDING),r&16&&(t|=GPUTextureUsage.RENDER_ATTACHMENT),t||GPUTextureUsage.RENDER_ATTACHMENT}_beginRenderPass(r,t,e,n){this.encoder||(this.encoder=this.device.createCommandEncoder());let s=65534,i;if(r===s){let l=this.context.getCurrentTexture();i=l.createView(),this.debug&&console.log(`[GPU] canvas texture: ${l.width}x${l.height}, format=${l.format}`)}else i=this.textures.get(r)?.createView();this.debug&&console.log(`[GPU] beginRenderPass(colorId=${r}, canvas=${r===s}, view=${i?"OK":"MISSING"}, depthId=${n})`);let a={colorAttachments:[{view:i,loadOp:t===1?"clear":"load",storeOp:e===0?"store":"discard",clearValue:{r:0,g:0,b:0,a:1}}]};if(n!==65535){let l=this.textures.get(n);this.debug&&console.log(`[GPU] depthTexture(id=${n}, tex=${l?"OK":"MISSING"})`);let d=l?.createView();d?a.depthStencilAttachment={view:d,depthLoadOp:"clear",depthStoreOp:"store",depthClearValue:1}:this.debug&&console.log(`[GPU] WARNING: depth texture ${n} not found, skipping depth attachment`)}this.pass=this.encoder.beginRenderPass(a)}_beginComputePass(){this.encoder||(this.encoder=this.device.createCommandEncoder()),this.pass=this.encoder.beginComputePass()}_writeBuffer(r,t,e,n){let s=this.buffers.get(r);if(this.debug&&console.log(`[GPU] writeBuffer(id=${r}, offset=${t}, len=${n}, buffer=${s?"OK":"MISSING"})`),!s)return;let i=new Uint8Array(this.memory.buffer,e,n);if(this.debug&&n<=48){let o=new Float32Array(i.buffer,i.byteOffset,n/4);console.log("[GPU]   data floats:",Array.from(o))}this.device.queue.writeBuffer(s,t,i)}_writeTimeUniform(r,t,e){let n=this.buffers.get(r);if(!n)return;let s=new Float32Array([this.time,this.canvasWidth,this.canvasHeight,this.canvasWidth/(this.canvasHeight||1)]),i=Math.min(e,16);this.debug&&console.log(`[GPU] writeTimeUniform(id=${r}, time=${this.time}, w=${this.canvasWidth}, h=${this.canvasHeight}, size=${e}, writeSize=${i})`),this.debug&&console.log("[GPU]   actual floats:",Array.from(s.slice(0,Math.ceil(i/4))));let o=new Uint8Array(s.buffer,0,i);this.device.queue.writeBuffer(n,t,o)}_readString(r,t){let e=new Uint8Array(this.memory.buffer,r,t);return new TextDecoder().decode(e)}_createImageBitmap(r,t,e){if(this.imageBitmaps.has(r))return;let n=new Uint8Array(this.memory.buffer,t,e),s=n[0],i=n.slice(1,1+s),o=new TextDecoder().decode(i),c=n.slice(1+s),a=new Blob([c],{type:o}),l=globalThis.createImageBitmap(a);this.imageBitmaps.set(r,l)}async _copyExternalImageToTexture(r,t,e,n,s){let i=this.imageBitmaps.get(r);if(!i){console.error(`[GPU] ImageBitmap ${r} not found`);return}i instanceof Promise&&(i=await i,this.imageBitmaps.set(r,i));let o=this.textures.get(t);if(!o){console.error(`[GPU] Texture ${t} not found`);return}if(o.width!==i.width||o.height!==i.height){o.destroy();let c=this.textureDescriptors.get(t)||{format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT};o=this.device.createTexture({size:[i.width,i.height],format:c.format,usage:c.usage}),this.textures.set(t,o),this._recreateBindGroupsForTexture(t)}this.device.queue.copyExternalImageToTexture({source:i},{texture:o,mipLevel:e,origin:{x:n,y:s}},{width:i.width,height:i.height})}_recreateBindGroupsForTexture(r){for(let[t,e]of this.bindGroupDescriptors.entries())e.entries.some(s=>s.resourceType===1&&s.resourceId===r)&&(this.bindGroups.delete(t),this._recreateBindGroup(t,e))}_recreateBindGroup(r,t){let e=this.pipelines.get(t.layoutId);if(!e)return;let n=t.entries.map(s=>{let i={binding:s.binding};if(s.resourceType===0){let o={buffer:this.buffers.get(s.resourceId)};s.offset&&(o.offset=s.offset),s.size&&(o.size=s.size),i.resource=o}else s.resourceType===1?i.resource=this.textures.get(s.resourceId)?.createView():s.resourceType===2&&(i.resource=this.samplers.get(s.resourceId));return i});this.bindGroups.set(r,this.device.createBindGroup({layout:e.getBindGroupLayout(t.groupIndex),entries:n}))}_createTextureView(r,t,e,n){if(this.textureViews.has(r))return;let s=this.textures.get(t);s&&this.textureViews.set(r,s.createView())}_createQuerySet(r,t,e){this.querySets.has(r)}_createBindGroupLayout(r,t,e){this.bindGroupLayouts.has(r)}_createPipelineLayout(r,t,e){this.pipelineLayouts.has(r)}_createRenderBundle(r,t,e){this.renderBundles.has(r)}_copyBufferToBuffer(r,t,e,n,s){let i=this.buffers.get(r),o=this.buffers.get(e);if(!i||!o)return;let c=this.encoder||this.device.createCommandEncoder();c.copyBufferToBuffer(i,t,o,n,s),this.encoder||this.device.queue.submit([c.finish()])}_copyTextureToTexture(r,t,e,n){let s=this.textures.get(r),i=this.textures.get(t);if(!s||!i)return;let o=this.encoder||this.device.createCommandEncoder();o.copyTextureToTexture({texture:s},{texture:i},{width:e,height:n}),this.encoder||this.device.queue.submit([o.finish()])}_writeBufferFromWasm(r,t,e,n){let s=this.buffers.get(r);if(!s)return;let i=this.wasmCallResults.get(e);if(i){this.debug&&console.log(`[GPU] writeBufferFromWasm from call result ${e}`);let{memory:c,resultValue:a}=i;if(typeof a=="number"&&c){let l=new Uint8Array(c.buffer,a,n);if(this.debug&&n===64){let d=new Float32Array(c.buffer,a,16);console.log("[GPU]   matrix values:",Array.from(d))}this.device.queue.writeBuffer(s,t,l)}else if(typeof a=="number"){let l=new Float32Array([a]);this.device.queue.writeBuffer(s,t,new Uint8Array(l.buffer,0,Math.min(n,4)))}this.wasmCallResults.delete(e);return}let o=new Uint8Array(this.memory.buffer,e,n);this.device.queue.writeBuffer(s,t,o)}_initWasmModule(r,t,e){if(this.wasmModules.has(r))return;let n=new Uint8Array(this.memory.buffer,t,e).slice();this.debug&&console.log(`[GPU] initWasmModule(id=${r}, size=${e})`);let s={env:{abort:(o,c,a,l)=>{console.error(`[GPU] WASM abort at ${c}:${a}:${l}: ${o}`)}}},i=WebAssembly.instantiate(n,s).then(o=>{let c=o.instance,a=c.exports.memory;return this.debug&&console.log(`[GPU] WASM module ${r} loaded, exports:`,Object.keys(c.exports)),{instance:c,memory:a}}).catch(o=>(console.error(`[GPU] Failed to load WASM module ${r}:`,o),null));this.wasmModules.set(r,i)}async _callWasmFunc(r,t,e,n,s){let i=this._readString(e,n);this.debug&&console.log(`[GPU] callWasmFunc(callId=${r}, moduleId=${t}, func="${i}")`);let o=this.wasmModules.get(t);if(!o){console.error(`[GPU] WASM module ${t} not found`);return}if(o instanceof Promise){if(o=await o,!o)return;this.wasmModules.set(t,o)}let{instance:c,memory:a}=o,l=c.exports[i];if(!l){console.error(`[GPU] WASM function "${i}" not found in module ${t}`);return}this.debug&&console.log(`[GPU]   argsBytes.length=${s.length}`),this.debug&&s.length>0&&console.log("[GPU]   raw args bytes:",Array.from(s));let d=this._decodeWasmArgs(s);this.debug&&console.log("[GPU]   decoded args:",d);let g=l(...d);if(this.debug&&console.log("[GPU]   result (pointer):",g),this.debug&&typeof g=="number"&&a)try{let U=new Float32Array(a.buffer,g,16);console.log(`[GPU]   matrix at ptr ${g}:`,Array.from(U).map(m=>m.toFixed(4)))}catch(U){console.log("[GPU]   failed to read matrix:",U.message)}g!==void 0&&a&&this.wasmCallResults.set(r,{moduleId:t,memory:a,resultValue:g})}_decodeWasmArgs(r){if(r.length===0)return[];let t=r,e=new DataView(t.buffer,t.byteOffset,t.byteLength),n=[],s=t.length,i=0,o=t[i++];for(let c=0;c<o&&i<s;c++){let a=t[i++];switch(a){case 0:n.push(e.getFloat32(i,!0)),i+=4;break;case 1:n.push(this.canvasWidth);break;case 2:n.push(this.canvasHeight);break;case 3:n.push(this.time);break;case 4:n.push(e.getInt32(i,!0)),i+=4;break;case 5:n.push(e.getUint32(i,!0)),i+=4;break;case 6:n.push(1/60);break;default:console.warn(`[GPU] Unknown WASM arg type: 0x${a.toString(16)}`)}}return n}_createTypedArray(r,t,e){if(this.typedArrays.has(r))return;let s=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array][t]||Float32Array,i=new s(e);this.debug&&console.log(`[GPU] createTypedArray(id=${r}, type=${t}/${s.name}, size=${e}, byteLength=${i.byteLength})`),this.typedArrays.set(r,i)}_fillRandom(r,t,e,n,s){let i=this.typedArrays.get(r);if(!i){console.error(`[GPU] fillRandom: array ${r} not found`);return}let o=new Float32Array(this.memory.buffer,s,e);this.debug&&console.log(`[GPU] fillRandom(array=${r}, offset=${t}, count=${e}, stride=${n}, dataPtr=${s})`);for(let c=0;c<e;c++){let a=t+c*n;a<i.length&&(i[a]=o[c])}}_fillExpression(r,t,e,n,s,i){let o=this.typedArrays.get(r);if(!o){console.error(`[GPU] fillExpression: array ${r} not found`);return}let c=this._readString(s,i);if(this.debug&&console.log(`[GPU] fillExpression(array=${r}, offset=${t}, count=${e}, stride=${n}, expr="${c}")`),!!c)try{let a=c.replace(/NUM_PARTICLES/g,String(e)).replace(/PI/g,"Math.PI").replace(/random\\(\\)/g,"Math.random()").replace(/sin\\(/g,"Math.sin(").replace(/cos\\(/g,"Math.cos(").replace(/sqrt\\(/g,"Math.sqrt(").replace(/ceil\\(/g,"Math.ceil(").replace(/floor\\(/g,"Math.floor(").replace(/abs\\(/g,"Math.abs("),l=new Function("ELEMENT_ID",`return ${a};`);for(let d=0;d<e;d++){let g=d*n+t;o[g]=l(d)}}catch(a){console.error(`[GPU] Error evaluating expression "${c}":`,a)}}_fillConstant(r,t,e,n,s){let i=this.typedArrays.get(r);if(!i)return;let c=new Float32Array(this.memory.buffer,s,1)[0];for(let a=0;a<e;a++){let l=a*n+t;i[l]=c}}_writeBufferFromArray(r,t,e){let n=this.typedArrays.get(e),s=this.buffers.get(r);if(!n||!s){console.error(`[GPU] writeBufferFromArray: missing array ${e} or buffer ${r}`);return}if(this.debug){console.log(`[GPU] writeBufferFromArray(buffer=${r}, offset=${t}, array=${e}, type=${n.constructor.name}, byteLen=${n.byteLength})`);let i=n instanceof Float32Array?n:new Float32Array(n.buffer,n.byteOffset,Math.min(8,n.byteLength/4));console.log(`[GPU]   first values: [${Array.from(i.slice(0,8)).join(", ")}]`)}this.device.queue.writeBuffer(s,t,n)}destroy(){for(let r of this.buffers.values())r.destroy?.();for(let r of this.textures.values())r.destroy?.();for(let r of this.imageBitmaps.values())r instanceof ImageBitmap&&r.close?.();this.buffers.clear(),this.textures.clear(),this.textureViews.clear(),this.samplers.clear(),this.shaders.clear(),this.pipelines.clear(),this.bindGroups.clear(),this.bindGroupLayouts.clear(),this.pipelineLayouts.clear(),this.querySets.clear(),this.renderBundles.clear(),this.imageBitmaps.clear(),this.wasmModules.clear(),this.wasmCallResults.clear(),this.typedArrays.clear(),this.bindGroupDescriptors.clear(),this.textureDescriptors.clear()}};var W=[80,78,71,66],N=0,C=40,V=1,Y=2,X=1,z=2,H=4,k=8,q=16,K=32;function O(u){if(u.length<C)throw new Error("Invalid PNGB: too short");if(!W.every((e,n)=>u[n]===e))throw new Error("Invalid PNGB: bad magic");let r=new DataView(u.buffer,u.byteOffset,u.byteLength),t=r.getUint16(4,!0);if(t!==N)throw new Error(`Unsupported PNGB version: ${t}`);return j(u,r)}function j(u,r){let t=r.getUint16(6,!0),e=u[8],n=r.getUint32(12,!0),s=r.getUint32(16,!0),i=r.getUint32(20,!0),o=r.getUint32(24,!0),c=r.getUint32(28,!0),a=r.getUint32(32,!0),l=r.getUint32(36,!0),d=(t&V)!==0,g=(t&Y)!==0,U=d?n+s:C,m=i-U;return{version:N,hasEmbeddedExecutor:d,hasAnimationTable:g,plugins:J(e),executor:d?u.subarray(n,n+s):null,bytecode:u.subarray(U,U+m),payload:u,offsets:{executor:d?n:0,executorLength:s,bytecode:U,bytecodeLength:m,stringTable:i,data:o,wgsl:c,uniform:a,animation:l}}}function J(u){return{core:(u&X)!==0,render:(u&z)!==0,compute:(u&H)!==0,wasm:(u&k)!==0,animation:(u&q)!==0,texture:(u&K)!==0}}function F(u={}){return{env:{log:u.log||((r,t)=>{}),wasmInstantiate:u.wasmInstantiate||((r,t,e)=>{}),wasmCall:u.wasmCall||((r,t,e,n,s,i)=>{}),wasmGetResult:u.wasmGetResult||((r,t,e)=>0)}}}var E,A,L,h,_,P,R=!1,S=!1,$=0,p={INIT:"init",DRAW:"draw",LOAD:"load",DESTROY:"destroy",READY:"ready",ERROR:"error"};onmessage=async u=>{let{type:r,...t}=u.data;try{switch(r){case p.INIT:await Q(t);break;case p.DRAW:v(t);break;case p.LOAD:await Z(t);break;case p.DESTROY:ee();break;default:throw new Error(`Unknown message: ${r}`)}}catch(e){postMessage({type:p.ERROR,message:e.message})}};async function Q(u){if(R)throw new Error("Already initialized");E=u.canvas;let r=await navigator.gpu?.requestAdapter();if(!r)throw new Error("WebGPU not supported");A=await r.requestDevice(),L=E.getContext("webgpu");let t=navigator.gpu.getPreferredCanvasFormat();L.configure({device:A,format:t,alphaMode:"premultiplied"}),h=new G(A,L),h.setDebug(u.debug),h.setCanvasSize(E.width,E.height);let e=!1,n=null;if(u.bytecode)try{let s=new Uint8Array(u.bytecode);n=O(s),e=n.hasEmbeddedExecutor}catch(s){u.debug&&console.log("[Worker] Bytecode parse failed, using shared executor:",s.message)}if(e&&n.executor){u.debug&&console.log("[Worker] Using embedded executor from payload");let s=F({log:(o,c)=>{if(u.debug){let a=new TextDecoder().decode(new Uint8Array(P.buffer,o,c));console.log("[Executor]",a)}}}),{instance:i}=await WebAssembly.instantiate(n.executor,s);_=i.exports,P=_.memory,h.setMemory(P),R=!0,await M(n.payload)}else{if(!u.wasmUrl)throw new Error("wasmUrl required (no embedded executor)");let s=await fetch(u.wasmUrl);if(!s.ok)throw new Error(`Failed to fetch WASM: ${s.status}`);let{instance:i}=await WebAssembly.instantiateStreaming(s,te());_=i.exports,P=_.memory,h.setMemory(P),R=!0,u.bytecode&&await M(u.bytecode)}postMessage({type:p.READY,width:E.width,height:E.height,frameCount:$})}async function Z(u){if(!R)throw new Error("Not initialized");await M(u.bytecode),postMessage({type:p.READY,frameCount:$})}async function M(u){if(S){let i=h.debug;h.destroy(),h=new G(A,L),h.setDebug(i),h.setMemory(P),h.setCanvasSize(E.width,E.height),S=!1}let r=_.getBytecodePtr(),t=u instanceof Uint8Array?u:new Uint8Array(u);new Uint8Array(P.buffer,r,t.length).set(t),_.setBytecodeLen(t.length);let e=_.init();if(e!==0)throw new Error(`Init failed: ${e}`);let n=_.getCommandPtr(),s=_.getCommandLen();n&&s>0&&await h.execute(n),S=!0,$=1,w(0,E.width,E.height)}function w(u,r,t){h.setTime(u);let e=_.frame(u,r,t);if(e!==0){console.warn("[Worker] frame() returned non-zero:",e);return}let n=_.getCommandPtr(),s=_.getCommandLen();!n||s===0||h.execute(n)}function v(u){!R||!S||w(u.time??0,E.width,E.height)}function ee(){S=!1,h?.destroy(),A&&(A.destroy(),A=null),R=!1}function te(){return{env:{log:(u,r)=>{let t=new TextDecoder().decode(new Uint8Array(P.buffer,u,r));console.log("[Executor]",t)}}}}\n';function B(){let e=new Blob([S],{type:"application/javascript"});return URL.createObjectURL(e)}var $=[137,80,78,71,13,10,26,10],w=[112,78,71,98],A=e=>e.length>=8&&$.every((t,r)=>e[r]===t),C=e=>e.length>=4&&e[0]===80&&e[1]===75&&(e[2]===3||e[2]===5),N=e=>e.length>=4&&e[0]===80&&e[1]===78&&e[2]===71&&e[3]===66;function M(e){return C(e)?"zip":A(e)?"png":N(e)?"pngb":null}async function P(e){let t=e instanceof Uint8Array?e:new Uint8Array(e),r=M(t);if(r==="pngb")return t;if(r==="png")return L(t);if(r==="zip")return O(t);throw new Error("Unknown format")}async function L(e){if(!A(e))throw new Error("Invalid PNG");let t=8;for(;t+12<=e.length;){let r=D(e,t),n=e.subarray(t+4,t+8);if(n[0]===w[0]&&n[1]===w[1]&&n[2]===w[2]&&n[3]===w[3]){let i=e.subarray(t+8,t+8+r);return v(i)}t+=12+r}throw new Error("No pNGb chunk found")}async function v(e){if(e.length<2)throw new Error("Invalid pNGb chunk");let t=e[0],r=e[1],n=e.subarray(2);if(t!==1)throw new Error(`Unsupported pNGb version: ${t}`);return r&1?x(n):new Uint8Array(n)}async function O(e){let t=-1;for(let o=22;o<=Math.min(e.length,65557);o++){let a=e.length-o;if(d(e,a)===101010256){t=a;break}}if(t===-1)throw new Error("Invalid ZIP");let r=l(e,t+10),n=d(e,t+16),i=null,s=null;for(let o=0;o<r&&d(e,n)===33639248;o++){let a=l(e,n+10),u=d(e,n+20),f=d(e,n+24),g=l(e,n+28),c=l(e,n+30),U=l(e,n+32),h=d(e,n+42),m=new TextDecoder().decode(e.subarray(n+46,n+46+g)),E=l(e,h+28),_=h+30+g+E,y={name:m,compression:a,compSize:u,uncompSize:f,dataOff:_};m==="manifest.json"?i=y:m.endsWith(".pngb")&&!s&&(s=y),n+=46+g+c+U}if(i){let o=JSON.parse(new TextDecoder().decode(await T(e,i)));if(o.entry){n=d(e,t+16);for(let a=0;a<r&&d(e,n)===33639248;a++){let u=l(e,n+28);if(new TextDecoder().decode(e.subarray(n+46,n+46+u))===o.entry){let g=l(e,n+10),c=d(e,n+20),U=d(e,n+24),h=l(e,n+30),m=l(e,n+32),E=d(e,n+42),_=l(e,E+28),y=E+30+u+_;return T(e,{compression:g,compSize:c,uncompSize:U,dataOff:y})}n+=46+u+l(e,n+30)+l(e,n+32)}}}if(s)return T(e,s);throw new Error("No bytecode found in ZIP")}async function T(e,t){let r=e.subarray(t.dataOff,t.dataOff+t.compSize);if(t.compression===0)return new Uint8Array(r);if(t.compression===8)return x(r);throw new Error(`Unsupported compression: ${t.compression}`)}async function x(e){let t=new DecompressionStream("deflate-raw"),r=t.writable.getWriter(),n=t.readable.getReader();r.write(e),r.close();let i=[],s=0;for(;;){let{done:u,value:f}=await n.read();if(u)break;i.push(f),s+=f.length}let o=new Uint8Array(s),a=0;for(let u of i)o.set(u,a),a+=u.length;return o}var l=(e,t)=>e[t]|e[t+1]<<8,d=(e,t)=>(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0,D=(e,t)=>(e[t]<<24|e[t+1]<<16|e[t+2]<<8|e[t+3])>>>0,F=[80,78,71,66],R=0,I=40,W=1,k=2,V=1,z=2,Y=4,X=8,H=16,q=32;function Q(e){if(e.length<I)throw new Error("Invalid PNGB: too short");if(!F.every((n,i)=>e[i]===n))throw new Error("Invalid PNGB: bad magic");let t=new DataView(e.buffer,e.byteOffset,e.byteLength),r=t.getUint16(4,!0);if(r!==R)throw new Error(`Unsupported PNGB version: ${r}`);return K(e,t)}function K(e,t){let r=t.getUint16(6,!0),n=e[8],i=t.getUint32(12,!0),s=t.getUint32(16,!0),o=t.getUint32(20,!0),a=t.getUint32(24,!0),u=t.getUint32(28,!0),f=t.getUint32(32,!0),g=t.getUint32(36,!0),c=(r&W)!==0,U=(r&k)!==0,h=c?i+s:I,m=o-h;return{version:R,hasEmbeddedExecutor:c,hasAnimationTable:U,plugins:J(n),executor:c?e.subarray(i,i+s):null,bytecode:e.subarray(h,h+m),payload:e,offsets:{executor:c?i:0,executorLength:s,bytecode:h,bytecodeLength:m,stringTable:o,data:a,wgsl:u,uniform:f,animation:g}}}function J(e){return{core:(e&V)!==0,render:(e&z)!==0,compute:(e&Y)!==0,wasm:(e&X)!==0,animation:(e&H)!==0,texture:(e&q)!==0}}function ee(e={}){return{env:{log:e.log||((t,r)=>{}),wasmInstantiate:e.wasmInstantiate||((t,r,n)=>{}),wasmCall:e.wasmCall||((t,r,n,i,s,o)=>{}),wasmGetResult:e.wasmGetResult||((t,r,n)=>0)}}}async function te(e,t={}){let{instance:r}=await WebAssembly.instantiate(e,t),n=r.exports,i=n.memory;return{instance:r,memory:i,exports:n,getBytecodePtr(){return n.getBytecodePtr?.()||0},setBytecodeLen(s){n.setBytecodeLen?.(s)},getDataPtr(){return n.getDataPtr?.()||0},setDataLen(s){n.setDataLen?.(s)},init(){n.init?.()},frame(s,o,a){n.frame?.(s,o,a)},getCommandPtr(){return n.getCommandPtr?.()||0},getCommandLen(){return n.getCommandLen?.()||0}}}function re(e){let t=["core"];return e.render&&t.push("render"),e.compute&&t.push("compute"),e.wasm&&t.push("wasm"),e.animation&&t.push("anim"),e.texture&&t.push("texture"),t.join("-")}function G(e,t){if(!e||e.length===0)return null;for(let r of e)if(t>=r.startMs&&t<r.endMs)return r;return e[e.length-1]}function p(e,t={}){let r=e._;if(!r)throw new Error("Pngine destroyed");if(!r.ready)throw new Error("Not initialized");let n=t.time??r.time,i=t.frame??null;if(i===null&&r.animation&&r.animation.scenes.length>0){let s=G(r.animation.scenes,n*1e3);s&&(i=s.frame,s!==r.currentScene&&(r.currentScene=s,r.currentFrame=s.frame))}r.worker.postMessage({type:"draw",time:n,frame:i,uniforms:t.uniforms??null}),t.time!==void 0&&(r.time=t.time)}function ne(e){let t=e._;if(!t||t.playing)return e;t.playing=!0,t.startTime=performance.now()-t.time*1e3;let r=()=>{if(!t.playing)return;let n=performance.now(),i=(n-t.startTime)/1e3;if(t.animation){let s=t.animation.duration/1e3;if(i>=s)switch(t.animation.endBehavior){case"loop":case"restart":t.startTime=n,i=0;break;case"stop":t.playing=!1,t.time=s,p(e,{time:s});return;case"hold":default:i=s;break}let o=G(t.animation.scenes,i*1e3);o&&o!==t.currentScene&&(t.currentScene=o,t.currentFrame=o.frame)}t.time=i,p(e,{time:t.time,frame:t.currentFrame}),t.animationId=requestAnimationFrame(r)};return t.animationId=requestAnimationFrame(r),e}function j(e){let t=e._;return!t||!t.playing||(t.playing=!1,t.time=(performance.now()-t.startTime)/1e3,t.animationId&&(cancelAnimationFrame(t.animationId),t.animationId=null)),e}function ie(e){j(e);let t=e._;return t&&(t.time=0,t.startTime=performance.now(),p(e,{time:0})),e}function se(e,t){let r=e._;return r&&(r.time=t,r.playing&&(r.startTime=performance.now()-t*1e3),p(e,{time:t})),e}function oe(e,t){let r=e._;return r&&(r.currentFrame=t,p(e,{time:r.time,frame:t})),e}function ae(e,t,r,n=!0){let i=e._;return i&&(i.uniforms||(i.uniforms={}),i.uniforms[t]=r,n&&p(e,{time:i.time,uniforms:{[t]:r}})),e}function ue(e,t,r=!0){let n=e._;return n&&(n.uniforms||(n.uniforms={}),Object.assign(n.uniforms,t),r&&p(e,{time:n.time,uniforms:t})),e}async function ce(e,t={}){let r,n;if(typeof e=="string")if(e.startsWith("#")||e.startsWith(".")&&!e.startsWith("./")&&!e.startsWith("..")){let u=document.querySelector(e);if(!u)throw new Error(`Element not found: ${e}`);if(u instanceof HTMLImageElement)({canvas:r,bytecode:n}=await b(u,t));else throw u instanceof HTMLCanvasElement?(r=u,new Error("Canvas source requires URL or data")):new Error("Invalid element type")}else{if(r=t.canvas,!r)throw new Error("Canvas required for URL source");let u=await fetch(e);if(!u.ok)throw new Error(`Fetch failed: ${u.status}`);n=await P(await u.arrayBuffer())}else if(e instanceof HTMLImageElement)({canvas:r,bytecode:n}=await b(e,t));else if(e instanceof ArrayBuffer||e instanceof Uint8Array||e instanceof Blob){if(r=t.canvas,!r)throw new Error("Canvas required for data source");let a=e instanceof Blob?await e.arrayBuffer():e;n=await P(a)}else throw new Error("Invalid source type");let i=r.transferControlToOffscreen(),s=new Worker(B()),o=await new Promise((a,u)=>{let f=setTimeout(()=>u(new Error("Worker init timeout")),15e3);s.onmessage=c=>{c.data.type==="ready"?(clearTimeout(f),a(c.data)):c.data.type==="error"&&(clearTimeout(f),u(new Error(c.data.message)))},s.onerror=c=>{clearTimeout(f),u(new Error(c.message||"Worker error"))};let g=t.wasmUrl?new URL(t.wasmUrl,window.location.href).href:new URL("pngine.wasm",import.meta.url).href;s.postMessage({type:"init",canvas:i,bytecode:n,wasmUrl:g,debug:t.debug||!1},[i,n.buffer])});return s.onmessage=a=>{a.data.type==="error"&&t.onError&&t.onError(new Error(a.data.message))},Z({canvas:r,worker:s,width:o.width,height:o.height,frameCount:o.frameCount,animation:o.animation||null,currentScene:null,currentFrame:null,ready:!0,playing:!1,time:0,startTime:0,animationId:null})}async function b(e,t){e.complete||await new Promise((a,u)=>{e.onload=a,e.onerror=u});let{naturalWidth:r,naturalHeight:n}=e;if(r===0||n===0)throw new Error("Image has no dimensions");let i=t.canvas||document.createElement("canvas");if(i.width=r,i.height=n,!t.canvas){let a=e.parentElement;a&&getComputedStyle(a).position==="static"&&(a.style.position="relative"),Object.assign(i.style,{position:"absolute",top:e.offsetTop+"px",left:e.offsetLeft+"px",width:e.offsetWidth+"px",height:e.offsetHeight+"px",pointerEvents:"none"}),a&&a.appendChild(i)}let s=await fetch(e.src);if(!s.ok)throw new Error(`Failed to fetch image: ${s.status}`);let o=await P(await s.arrayBuffer());return{canvas:i,bytecode:o}}function Z(e){return{get width(){return e.width},get height(){return e.height},get isPlaying(){return e.playing},get time(){return e.time},get frameCount(){return e.frameCount},get animation(){return e.animation},get currentScene(){return e.currentScene},get currentFrame(){return e.currentFrame},get duration(){return e.animation?e.animation.duration/1e3:0},_:e}}function le(e){let t=e._;return t&&(t.animationId&&cancelAnimationFrame(t.animationId),t.worker.postMessage({type:"destroy"}),t.worker.terminate(),e._=null),e}export{te as createExecutor,le as destroy,M as detectFormat,p as draw,P as extractBytecode,ee as getExecutorImports,re as getExecutorVariantName,A as isPng,N as isPngb,C as isZip,Q as parsePayload,j as pause,ne as play,ce as pngine,se as seek,oe as setFrame,ae as setUniform,ue as setUniforms,ie as stop};
