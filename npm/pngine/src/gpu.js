/**
 * Minimal GPU Command Dispatcher
 *
 * Executes command buffers generated by WASM.
 * Replaces the 2000-line pngine-gpu.js with a ~200-line switch.
 */

// Command opcodes (must match command_buffer.zig)
const CMD = {
  // Resource Creation (0x01-0x0F)
  CREATE_BUFFER: 0x01,
  CREATE_TEXTURE: 0x02,
  CREATE_SAMPLER: 0x03,
  CREATE_SHADER: 0x04,
  CREATE_RENDER_PIPELINE: 0x05,
  CREATE_COMPUTE_PIPELINE: 0x06,
  CREATE_BIND_GROUP: 0x07,
  CREATE_TEXTURE_VIEW: 0x08,
  CREATE_QUERY_SET: 0x09,
  CREATE_BIND_GROUP_LAYOUT: 0x0a,
  CREATE_IMAGE_BITMAP: 0x0b,
  CREATE_PIPELINE_LAYOUT: 0x0c,
  CREATE_RENDER_BUNDLE: 0x0d,

  // Pass Operations (0x10-0x1F)
  BEGIN_RENDER_PASS: 0x10,
  BEGIN_COMPUTE_PASS: 0x11,
  SET_PIPELINE: 0x12,
  SET_BIND_GROUP: 0x13,
  SET_VERTEX_BUFFER: 0x14,
  DRAW: 0x15,
  DRAW_INDEXED: 0x16,
  END_PASS: 0x17,
  DISPATCH: 0x18,
  SET_INDEX_BUFFER: 0x19,
  EXECUTE_BUNDLES: 0x1a,

  // Queue Operations (0x20-0x2F)
  WRITE_BUFFER: 0x20,
  WRITE_TIME_UNIFORM: 0x21,
  COPY_BUFFER_TO_BUFFER: 0x22,
  COPY_TEXTURE_TO_TEXTURE: 0x23,
  WRITE_BUFFER_FROM_WASM: 0x24,
  COPY_EXTERNAL_IMAGE_TO_TEXTURE: 0x25,

  // WASM Module Operations (0x30-0x3F)
  INIT_WASM_MODULE: 0x30,
  CALL_WASM_FUNC: 0x31,

  // Utility Operations (0x40-0x4F)
  CREATE_TYPED_ARRAY: 0x40,
  FILL_RANDOM: 0x41,
  FILL_EXPRESSION: 0x42,
  FILL_CONSTANT: 0x43,
  WRITE_BUFFER_FROM_ARRAY: 0x44,

  // Control (0xF0-0xFF)
  SUBMIT: 0xf0,
  END: 0xff,
};

// Usage flags (match opcodes.zig BufferUsage packed struct)
// bit 0: map_read, bit 1: map_write, bit 2: copy_src, bit 3: copy_dst
// bit 4: index, bit 5: vertex, bit 6: uniform, bit 7: storage
const USAGE = {
  MAP_READ: 0x01,
  MAP_WRITE: 0x02,
  COPY_SRC: 0x04,
  COPY_DST: 0x08,
  INDEX: 0x10,
  VERTEX: 0x20,
  UNIFORM: 0x40,
  STORAGE: 0x80,
};

export class CommandDispatcher {
  constructor(device, context) {
    this.device = device;
    this.context = context;
    this.memory = null;
    this.debug = false;

    // Resource tables
    this.buffers = new Map();
    this.textures = new Map();
    this.textureViews = new Map();
    this.samplers = new Map();
    this.shaders = new Map();
    this.pipelines = new Map();
    this.bindGroups = new Map();
    this.bindGroupLayouts = new Map();
    this.pipelineLayouts = new Map();
    this.querySets = new Map();
    this.renderBundles = new Map();
    this.imageBitmaps = new Map();  // ImageBitmap ID → ImageBitmap (or Promise)
    this.wasmModules = new Map();   // Embedded WASM modules (moduleId → {instance, memory})
    this.wasmCallResults = new Map(); // WASM call results (callId → Uint8Array)
    this.typedArrays = new Map();   // TypedArrays for data manipulation
    this.bindGroupDescriptors = new Map();  // For recreating bind groups after texture resize
    this.textureDescriptors = new Map();  // For recreating textures with correct format/usage

    // Render state
    this.encoder = null;
    this.pass = null;
    this.time = 0;
    this.canvasWidth = 0;
    this.canvasHeight = 0;
  }

  setDebug(enabled) {
    this.debug = enabled;
  }

  setMemory(memory) {
    this.memory = memory;
  }

  setTime(time) {
    this.time = time;
  }

  setCanvasSize(w, h) {
    this.canvasWidth = w;
    this.canvasHeight = h;
  }

  /**
   * Execute command buffer from WASM memory.
   * @param {number} ptr - Pointer to command buffer in WASM memory
   * @returns {Promise<void>} Resolves when all commands (including async) complete
   */
  async execute(ptr) {
    // Create fresh DataView - may need to recreate after async ops if memory grows
    let view = new DataView(this.memory.buffer);
    const totalLen = view.getUint32(ptr, true);
    const cmdCount = view.getUint16(ptr + 4, true);

    if (this.debug) console.log(`[GPU] Execute: ${cmdCount} commands, ${totalLen} bytes`);

    let pos = ptr + 8; // Skip header
    const end = ptr + totalLen;

    for (let i = 0; i < cmdCount && pos < end; i++) {
      const cmd = view.getUint8(pos++);
      if (this.debug) console.log(`[GPU] Cmd ${i}: 0x${cmd.toString(16)}`);
      const result = this._dispatch(cmd, view, pos);

      // Handle async commands (returns Promise with new position)
      if (result instanceof Promise) {
        pos = await result;
        // Recreate DataView after async - WASM memory may have grown/detached
        view = new DataView(this.memory.buffer);
      } else {
        pos = result;
      }
    }
  }

  _dispatch(cmd, view, pos) {
    switch (cmd) {
      case CMD.CREATE_BUFFER: {
        const id = view.getUint16(pos, true);
        const size = view.getUint32(pos + 2, true);
        const usage = view.getUint8(pos + 6);
        this._createBuffer(id, size, usage);
        return pos + 7;
      }

      case CMD.CREATE_SHADER: {
        const id = view.getUint16(pos, true);
        const codePtr = view.getUint32(pos + 2, true);
        const codeLen = view.getUint32(pos + 6, true);
        this._createShader(id, codePtr, codeLen);
        return pos + 10;
      }

      case CMD.CREATE_RENDER_PIPELINE: {
        const id = view.getUint16(pos, true);
        const descPtr = view.getUint32(pos + 2, true);
        const descLen = view.getUint32(pos + 6, true);
        this._createRenderPipeline(id, descPtr, descLen);
        return pos + 10;
      }

      case CMD.CREATE_COMPUTE_PIPELINE: {
        const id = view.getUint16(pos, true);
        const descPtr = view.getUint32(pos + 2, true);
        const descLen = view.getUint32(pos + 6, true);
        this._createComputePipeline(id, descPtr, descLen);
        return pos + 10;
      }

      case CMD.CREATE_BIND_GROUP: {
        const id = view.getUint16(pos, true);
        const layoutId = view.getUint16(pos + 2, true);
        const entriesPtr = view.getUint32(pos + 4, true);
        const entriesLen = view.getUint32(pos + 8, true);
        this._createBindGroup(id, layoutId, entriesPtr, entriesLen);
        return pos + 12;
      }

      case CMD.CREATE_TEXTURE: {
        const id = view.getUint16(pos, true);
        const descPtr = view.getUint32(pos + 2, true);
        const descLen = view.getUint32(pos + 6, true);
        this._createTexture(id, descPtr, descLen);
        return pos + 10;
      }

      case CMD.CREATE_SAMPLER: {
        const id = view.getUint16(pos, true);
        const descPtr = view.getUint32(pos + 2, true);
        const descLen = view.getUint32(pos + 6, true);
        this._createSampler(id, descPtr, descLen);
        return pos + 10;
      }

      case CMD.CREATE_TEXTURE_VIEW: {
        const id = view.getUint16(pos, true);
        const textureId = view.getUint16(pos + 2, true);
        const descPtr = view.getUint32(pos + 4, true);
        const descLen = view.getUint32(pos + 8, true);
        this._createTextureView(id, textureId, descPtr, descLen);
        return pos + 12;
      }

      case CMD.CREATE_QUERY_SET: {
        const id = view.getUint16(pos, true);
        const descPtr = view.getUint32(pos + 2, true);
        const descLen = view.getUint32(pos + 6, true);
        this._createQuerySet(id, descPtr, descLen);
        return pos + 10;
      }

      case CMD.CREATE_BIND_GROUP_LAYOUT: {
        const id = view.getUint16(pos, true);
        const descPtr = view.getUint32(pos + 2, true);
        const descLen = view.getUint32(pos + 6, true);
        this._createBindGroupLayout(id, descPtr, descLen);
        return pos + 10;
      }

      case CMD.CREATE_PIPELINE_LAYOUT: {
        const id = view.getUint16(pos, true);
        const descPtr = view.getUint32(pos + 2, true);
        const descLen = view.getUint32(pos + 6, true);
        this._createPipelineLayout(id, descPtr, descLen);
        return pos + 10;
      }

      case CMD.CREATE_RENDER_BUNDLE: {
        const id = view.getUint16(pos, true);
        const descPtr = view.getUint32(pos + 2, true);
        const descLen = view.getUint32(pos + 6, true);
        this._createRenderBundle(id, descPtr, descLen);
        return pos + 10;
      }

      case CMD.BEGIN_RENDER_PASS: {
        const colorId = view.getUint16(pos, true);
        const loadOp = view.getUint8(pos + 2);
        const storeOp = view.getUint8(pos + 3);
        const depthId = view.getUint16(pos + 4, true);
        this._beginRenderPass(colorId, loadOp, storeOp, depthId);
        return pos + 6;
      }

      case CMD.BEGIN_COMPUTE_PASS: {
        this._beginComputePass();
        return pos;
      }

      case CMD.SET_PIPELINE: {
        const id = view.getUint16(pos, true);
        this.pass?.setPipeline(this.pipelines.get(id));
        return pos + 2;
      }

      case CMD.SET_BIND_GROUP: {
        const slot = view.getUint8(pos);
        const id = view.getUint16(pos + 1, true);
        this.pass?.setBindGroup(slot, this.bindGroups.get(id));
        return pos + 3;
      }

      case CMD.SET_VERTEX_BUFFER: {
        const slot = view.getUint8(pos);
        const id = view.getUint16(pos + 1, true);
        this.pass?.setVertexBuffer(slot, this.buffers.get(id));
        return pos + 3;
      }

      case CMD.SET_INDEX_BUFFER: {
        const id = view.getUint16(pos, true);
        const format = view.getUint8(pos + 2);
        const fmt = format === 1 ? "uint32" : "uint16";
        this.pass?.setIndexBuffer(this.buffers.get(id), fmt);
        return pos + 3;
      }

      case CMD.EXECUTE_BUNDLES: {
        const count = view.getUint8(pos);
        const bundles = [];
        for (let i = 0; i < count; i++) {
          const bundleId = view.getUint16(pos + 1 + i * 2, true);
          const bundle = this.renderBundles.get(bundleId);
          if (bundle) bundles.push(bundle);
        }
        this.pass?.executeBundles(bundles);
        return pos + 1 + count * 2;
      }

      case CMD.DRAW: {
        const vtx = view.getUint32(pos, true);
        const inst = view.getUint32(pos + 4, true);
        const firstVtx = view.getUint32(pos + 8, true);
        const firstInst = view.getUint32(pos + 12, true);
        if (this.debug) console.log(`[GPU] draw(vtx=${vtx}, inst=${inst}, firstVtx=${firstVtx}, firstInst=${firstInst})`);
        this.pass?.draw(vtx, inst, firstVtx, firstInst);
        return pos + 16;
      }

      case CMD.DRAW_INDEXED: {
        const idx = view.getUint32(pos, true);
        const inst = view.getUint32(pos + 4, true);
        const firstIdx = view.getUint32(pos + 8, true);
        const baseVtx = view.getInt32(pos + 12, true);
        const firstInst = view.getUint32(pos + 16, true);
        this.pass?.drawIndexed(idx, inst, firstIdx, baseVtx, firstInst);
        return pos + 20;
      }

      case CMD.DISPATCH: {
        const x = view.getUint32(pos, true);
        const y = view.getUint32(pos + 4, true);
        const z = view.getUint32(pos + 8, true);
        if (this.debug) console.log(`[GPU] dispatch(${x}, ${y}, ${z})`);
        this.pass?.dispatchWorkgroups(x, y, z);
        return pos + 12;
      }

      case CMD.END_PASS: {
        this.pass?.end();
        this.pass = null;
        return pos;
      }

      case CMD.WRITE_BUFFER: {
        const id = view.getUint16(pos, true);
        const offset = view.getUint32(pos + 2, true);
        const dataPtr = view.getUint32(pos + 6, true);
        const dataLen = view.getUint32(pos + 10, true);
        this._writeBuffer(id, offset, dataPtr, dataLen);
        return pos + 14;
      }

      case CMD.WRITE_TIME_UNIFORM: {
        const id = view.getUint16(pos, true);
        const offset = view.getUint32(pos + 2, true);
        const size = view.getUint16(pos + 6, true);
        this._writeTimeUniform(id, offset, size);
        return pos + 8;
      }

      case CMD.CREATE_IMAGE_BITMAP: {
        const id = view.getUint16(pos, true);
        const dataPtr = view.getUint32(pos + 2, true);
        const dataLen = view.getUint32(pos + 6, true);
        this._createImageBitmap(id, dataPtr, dataLen);
        return pos + 10;
      }

      case CMD.COPY_EXTERNAL_IMAGE_TO_TEXTURE: {
        const bitmapId = view.getUint16(pos, true);
        const textureId = view.getUint16(pos + 2, true);
        const mipLevel = view.getUint8(pos + 4);
        const originX = view.getUint16(pos + 5, true);
        const originY = view.getUint16(pos + 7, true);
        const nextPos = pos + 9;
        // Return Promise that resolves to next position after async op completes
        return this._copyExternalImageToTexture(
          bitmapId,
          textureId,
          mipLevel,
          originX,
          originY
        ).then(() => nextPos);
      }

      case CMD.COPY_BUFFER_TO_BUFFER: {
        const srcId = view.getUint16(pos, true);
        const srcOffset = view.getUint32(pos + 2, true);
        const dstId = view.getUint16(pos + 6, true);
        const dstOffset = view.getUint32(pos + 8, true);
        const size = view.getUint32(pos + 12, true);
        this._copyBufferToBuffer(srcId, srcOffset, dstId, dstOffset, size);
        return pos + 16;
      }

      case CMD.COPY_TEXTURE_TO_TEXTURE: {
        const srcId = view.getUint16(pos, true);
        const dstId = view.getUint16(pos + 2, true);
        const width = view.getUint16(pos + 4, true);
        const height = view.getUint16(pos + 6, true);
        this._copyTextureToTexture(srcId, dstId, width, height);
        return pos + 8;
      }

      case CMD.WRITE_BUFFER_FROM_WASM: {
        const bufferId = view.getUint16(pos, true);
        const bufferOffset = view.getUint32(pos + 2, true);
        const wasmPtr = view.getUint32(pos + 6, true);
        const size = view.getUint32(pos + 10, true);
        this._writeBufferFromWasm(bufferId, bufferOffset, wasmPtr, size);
        return pos + 14;
      }

      case CMD.INIT_WASM_MODULE: {
        const moduleId = view.getUint16(pos, true);
        const dataPtr = view.getUint32(pos + 2, true);
        const dataLen = view.getUint32(pos + 6, true);
        this._initWasmModule(moduleId, dataPtr, dataLen);
        return pos + 10;
      }

      case CMD.CALL_WASM_FUNC: {
        const callId = view.getUint16(pos, true);
        const moduleId = view.getUint16(pos + 2, true);
        const namePtr = view.getUint32(pos + 4, true);
        const nameLen = view.getUint32(pos + 8, true);
        const argsPtr = view.getUint32(pos + 12, true);
        const argsLen = view.getUint32(pos + 16, true);
        const nextPos = pos + 20;
        // Return Promise that resolves to next position after async call completes
        return this._callWasmFunc(callId, moduleId, namePtr, nameLen, argsPtr, argsLen)
          .then(() => nextPos);
      }

      case CMD.CREATE_TYPED_ARRAY: {
        const id = view.getUint16(pos, true);
        const arrayType = view.getUint8(pos + 2);
        const size = view.getUint32(pos + 3, true);
        this._createTypedArray(id, arrayType, size);
        return pos + 7;
      }

      case CMD.FILL_RANDOM: {
        // Format: array_id, offset, count, stride, data_ptr (pre-generated f32 values)
        const arrayId = view.getUint16(pos, true);
        const offset = view.getUint32(pos + 2, true);
        const count = view.getUint32(pos + 6, true);
        const stride = view.getUint8(pos + 10);
        const dataPtr = view.getUint32(pos + 11, true);
        this._fillRandom(arrayId, offset, count, stride, dataPtr);
        return pos + 15;
      }

      case CMD.FILL_EXPRESSION: {
        const arrayId = view.getUint16(pos, true);
        const offset = view.getUint32(pos + 2, true);
        const count = view.getUint32(pos + 6, true);
        const stride = view.getUint8(pos + 10);
        const exprPtr = view.getUint32(pos + 11, true);
        const exprLen = view.getUint16(pos + 15, true);
        this._fillExpression(arrayId, offset, count, stride, exprPtr, exprLen);
        return pos + 17;
      }

      case CMD.FILL_CONSTANT: {
        const arrayId = view.getUint16(pos, true);
        const offset = view.getUint32(pos + 2, true);
        const count = view.getUint32(pos + 6, true);
        const stride = view.getUint8(pos + 10);
        const valuePtr = view.getUint32(pos + 11, true);
        this._fillConstant(arrayId, offset, count, stride, valuePtr);
        return pos + 15;
      }

      case CMD.WRITE_BUFFER_FROM_ARRAY: {
        const bufferId = view.getUint16(pos, true);
        const bufferOffset = view.getUint32(pos + 2, true);
        const arrayId = view.getUint16(pos + 6, true);
        this._writeBufferFromArray(bufferId, bufferOffset, arrayId);
        return pos + 8;
      }

      case CMD.SUBMIT: {
        if (this.encoder) {
          this.device.queue.submit([this.encoder.finish()]);
          this.encoder = null;
        }
        return pos;
      }

      case CMD.END: {
        return pos;
      }

      default:
        console.warn(`Unknown command: 0x${cmd.toString(16)}`);
        return pos;
    }
  }

  // Resource creation
  _createBuffer(id, size, usage) {
    if (this.buffers.has(id)) return;
    const gpuUsage = this._translateUsage(usage);
    this.buffers.set(
      id,
      this.device.createBuffer({ size, usage: gpuUsage })
    );
  }

  _translateUsage(usage) {
    let result = 0;
    if (usage & USAGE.MAP_READ) result |= GPUBufferUsage.MAP_READ;
    if (usage & USAGE.MAP_WRITE) result |= GPUBufferUsage.MAP_WRITE;
    if (usage & USAGE.COPY_SRC) result |= GPUBufferUsage.COPY_SRC;
    if (usage & USAGE.COPY_DST) result |= GPUBufferUsage.COPY_DST;
    if (usage & USAGE.INDEX) result |= GPUBufferUsage.INDEX;
    if (usage & USAGE.VERTEX) result |= GPUBufferUsage.VERTEX;
    if (usage & USAGE.UNIFORM) result |= GPUBufferUsage.UNIFORM;
    if (usage & USAGE.STORAGE) result |= GPUBufferUsage.STORAGE;
    return result || GPUBufferUsage.COPY_DST;
  }

  _createShader(id, codePtr, codeLen) {
    if (this.shaders.has(id)) return;
    const code = this._readString(codePtr, codeLen);
    this.shaders.set(id, this.device.createShaderModule({ code }));
  }

  _createRenderPipeline(id, descPtr, descLen) {
    if (this.pipelines.has(id)) return;
    const json = this._readString(descPtr, descLen);
    if (!json || json.length === 0) {
      console.error(`[GPU] Empty pipeline descriptor for id=${id}, ptr=${descPtr}, len=${descLen}`);
      return;
    }
    const desc = JSON.parse(json);
    const pipeline = this._buildRenderPipeline(desc);
    this.pipelines.set(id, pipeline);
    // Store layout for bind group creation
    this.bindGroupLayouts.set(id, pipeline.getBindGroupLayout(0));
  }

  _buildRenderPipeline(desc) {
    const format = navigator.gpu.getPreferredCanvasFormat();
    // Always use "auto" layout - explicit layouts not yet supported
    return this.device.createRenderPipeline({
      layout: "auto",
      vertex: {
        module: this.shaders.get(desc.vertex?.shader ?? 0),
        entryPoint: desc.vertex?.entryPoint ?? "vs_main",
        buffers: desc.vertex?.buffers ?? [],
      },
      fragment: {
        module: this.shaders.get(desc.fragment?.shader ?? desc.vertex?.shader ?? 0),
        entryPoint: desc.fragment?.entryPoint ?? "fs_main",
        targets: [{ format }],
      },
      primitive: desc.primitive ?? { topology: "triangle-list" },
      depthStencil: desc.depthStencil,
    });
  }

  _createComputePipeline(id, descPtr, descLen) {
    if (this.pipelines.has(id)) return;
    const json = this._readString(descPtr, descLen);
    if (!json || json.length === 0) {
      console.error(`[GPU] Empty compute pipeline descriptor for id=${id}, ptr=${descPtr}, len=${descLen}`);
      return;
    }
    const desc = JSON.parse(json);
    // Determine layout: "auto", explicit pipeline layout, or default to "auto"
    let layout = "auto";
    if (desc.layout && desc.layout !== "auto") {
      layout = this.pipelineLayouts.get(desc.layout) ?? "auto";
    }
    const pipeline = this.device.createComputePipeline({
      layout,
      compute: {
        module: this.shaders.get(desc.compute?.shader ?? 0),
        entryPoint: desc.compute?.entryPoint ?? "main",
      },
    });
    this.pipelines.set(id, pipeline);
    if (layout === "auto") {
      this.bindGroupLayouts.set(id, pipeline.getBindGroupLayout(0));
    }
  }

  _createBindGroup(id, layoutId, entriesPtr, entriesLen) {
    if (this.bindGroups.has(id)) return;
    const bytes = new Uint8Array(this.memory.buffer, entriesPtr, entriesLen);
    const desc = this._decodeBindGroupDescriptor(bytes);

    // Store descriptor for later recreation if textures are resized
    desc.layoutId = layoutId;
    this.bindGroupDescriptors.set(id, desc);

    // Get layout from pipeline (layoutId is pipeline ID in this context)
    const pipeline = this.pipelines.get(layoutId);
    if (!pipeline) {
      console.error(`[GPU] Pipeline ${layoutId} not found for bind group ${id}`);
      return;
    }

    const gpuEntries = desc.entries.map((e) => {
      const entry = { binding: e.binding };
      if (e.resourceType === 0) { // buffer
        const bufRes = { buffer: this.buffers.get(e.resourceId) };
        if (e.offset) bufRes.offset = e.offset;
        if (e.size) bufRes.size = e.size;
        entry.resource = bufRes;
      } else if (e.resourceType === 1) { // texture_view
        entry.resource = this.textures.get(e.resourceId)?.createView();
      } else if (e.resourceType === 2) { // sampler
        entry.resource = this.samplers.get(e.resourceId);
      }
      return entry;
    });

    this.bindGroups.set(
      id,
      this.device.createBindGroup({
        layout: pipeline.getBindGroupLayout(desc.groupIndex),
        entries: gpuEntries,
      })
    );
  }

  _decodeBindGroupDescriptor(bytes) {
    const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    let offset = 0;

    const typeTag = bytes[offset++];
    if (typeTag !== 0x03) {
      console.error(`[GPU] Invalid bind group descriptor type tag: ${typeTag}`);
      return { groupIndex: 0, entries: [] };
    }

    const fieldCount = bytes[offset++];
    let groupIndex = 0;
    const entries = [];

    const FIELD_LAYOUT = 0x01, FIELD_ENTRIES = 0x02;
    const VALUE_ARRAY = 0x03, VALUE_ENUM = 0x07;

    for (let i = 0; i < fieldCount; i++) {
      const fieldId = bytes[offset++];
      const valueType = bytes[offset++];

      if (fieldId === FIELD_LAYOUT && valueType === VALUE_ENUM) {
        groupIndex = bytes[offset++];
      } else if (fieldId === FIELD_ENTRIES && valueType === VALUE_ARRAY) {
        const entryCount = bytes[offset++];
        for (let j = 0; j < entryCount; j++) {
          const binding = bytes[offset++];
          const resourceType = bytes[offset++];
          const resourceId = view.getUint16(offset, true);
          offset += 2;

          const entry = { binding, resourceType, resourceId };
          if (resourceType === 0) { // buffer has offset/size
            entry.offset = view.getUint32(offset, true);
            offset += 4;
            entry.size = view.getUint32(offset, true);
            offset += 4;
          }
          entries.push(entry);
        }
      }
    }
    return { groupIndex, entries };
  }

  _createTexture(id, descPtr, descLen) {
    if (this.textures.has(id)) return;
    const bytes = new Uint8Array(this.memory.buffer, descPtr, descLen);
    const desc = this._decodeTextureDescriptor(bytes);
    // Store descriptor for potential recreation with correct format/usage
    this.textureDescriptors.set(id, { format: desc.format, usage: desc.usage });
    this.textures.set(id, this.device.createTexture(desc));
  }

  _createSampler(id, descPtr, descLen) {
    if (this.samplers.has(id)) return;
    const bytes = new Uint8Array(this.memory.buffer, descPtr, descLen);
    const desc = this._decodeSamplerDescriptor(bytes);
    this.samplers.set(id, this.device.createSampler(desc));
  }

  // Binary descriptor decoders (match DescriptorEncoder.zig format)
  _decodeTextureDescriptor(bytes) {
    const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    let offset = 0;

    const typeTag = bytes[offset++];
    if (typeTag !== 0x01) {
      console.error(`[GPU] Invalid texture descriptor type tag: ${typeTag}`);
      return { size: [256, 256], format: "rgba8unorm", usage: GPUTextureUsage.RENDER_ATTACHMENT };
    }

    const fieldCount = bytes[offset++];
    const desc = {
      size: [this.canvasWidth || 512, this.canvasHeight || 512],
      format: navigator.gpu.getPreferredCanvasFormat(),
      usage: GPUTextureUsage.RENDER_ATTACHMENT,
      sampleCount: 1,
    };

    const FIELD_WIDTH = 0x01, FIELD_HEIGHT = 0x02, FIELD_SAMPLE_COUNT = 0x05;
    const FIELD_FORMAT = 0x07, FIELD_USAGE = 0x08;
    const FIELD_SIZE_FROM_IMAGE_BITMAP = 0x0a;
    const VALUE_U32 = 0x00, VALUE_U16 = 0x06, VALUE_ENUM = 0x07;

    for (let i = 0; i < fieldCount; i++) {
      const fieldId = bytes[offset++];
      const valueType = bytes[offset++];

      if (valueType === VALUE_U32) {
        const value = view.getUint32(offset, true);
        offset += 4;
        if (fieldId === FIELD_WIDTH) desc.size[0] = value;
        else if (fieldId === FIELD_HEIGHT) desc.size[1] = value;
        else if (fieldId === FIELD_SAMPLE_COUNT) desc.sampleCount = value;
      } else if (valueType === VALUE_U16) {
        const value = view.getUint16(offset, true);
        offset += 2;
        if (fieldId === FIELD_SIZE_FROM_IMAGE_BITMAP) {
          // Size will be determined from ImageBitmap when copyExternalImageToTexture runs
          // Use placeholder size (1x1) - will be resized when bitmap is decoded
          desc.size = [1, 1];
          desc.imageBitmapId = value;
        }
      } else if (valueType === VALUE_ENUM) {
        const value = bytes[offset++];
        if (fieldId === FIELD_FORMAT) desc.format = this._decodeTextureFormat(value);
        else if (fieldId === FIELD_USAGE) desc.usage = this._decodeTextureUsage(value);
      }
    }
    return desc;
  }

  _decodeSamplerDescriptor(bytes) {
    let offset = 0;
    const typeTag = bytes[offset++];
    if (typeTag !== 0x02) {
      console.error(`[GPU] Invalid sampler descriptor type tag: ${typeTag}`);
      return {};
    }

    const fieldCount = bytes[offset++];
    const desc = {
      magFilter: "linear",
      minFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge",
    };

    const FIELD_ADDRESS_U = 0x01, FIELD_ADDRESS_V = 0x02;
    const FIELD_MAG_FILTER = 0x04, FIELD_MIN_FILTER = 0x05;
    const VALUE_ENUM = 0x07;

    for (let i = 0; i < fieldCount; i++) {
      const fieldId = bytes[offset++];
      const valueType = bytes[offset++];

      if (valueType === VALUE_ENUM) {
        const value = bytes[offset++];
        if (fieldId === FIELD_MAG_FILTER) desc.magFilter = value === 0 ? "nearest" : "linear";
        else if (fieldId === FIELD_MIN_FILTER) desc.minFilter = value === 0 ? "nearest" : "linear";
        else if (fieldId === FIELD_ADDRESS_U) desc.addressModeU = ["clamp-to-edge", "repeat", "mirror-repeat"][value] || "clamp-to-edge";
        else if (fieldId === FIELD_ADDRESS_V) desc.addressModeV = ["clamp-to-edge", "repeat", "mirror-repeat"][value] || "clamp-to-edge";
      }
    }
    return desc;
  }

  _decodeTextureFormat(value) {
    const formats = {
      0x00: "rgba8unorm", 0x01: "rgba8snorm", 0x02: "rgba8uint", 0x03: "rgba8sint",
      0x04: "bgra8unorm", 0x05: "rgba16float", 0x06: "rgba32float",
      0x10: "depth24plus", 0x11: "depth24plus-stencil8", 0x12: "depth32float",
    };
    return formats[value] || navigator.gpu.getPreferredCanvasFormat();
  }

  _decodeTextureUsage(value) {
    let usage = 0;
    if (value & 0x01) usage |= GPUTextureUsage.COPY_SRC;
    if (value & 0x02) usage |= GPUTextureUsage.COPY_DST;
    if (value & 0x04) usage |= GPUTextureUsage.TEXTURE_BINDING;
    if (value & 0x08) usage |= GPUTextureUsage.STORAGE_BINDING;
    if (value & 0x10) usage |= GPUTextureUsage.RENDER_ATTACHMENT;
    return usage || GPUTextureUsage.RENDER_ATTACHMENT;
  }

  _beginRenderPass(colorId, loadOp, storeOp, depthId) {
    if (!this.encoder) {
      this.encoder = this.device.createCommandEncoder();
    }

    // 0xFFFE (65534) = use canvas, else use texture
    const CANVAS_TEXTURE_ID = 0xfffe;
    const colorView =
      colorId === CANVAS_TEXTURE_ID
        ? this.context.getCurrentTexture().createView()
        : this.textures.get(colorId)?.createView();

    // loadOp: 0=load, 1=clear
    // storeOp: 0=store, 1=discard
    const loadOpStr = loadOp === 1 ? "clear" : "load";
    const storeOpStr = storeOp === 0 ? "store" : "discard";

    const passDesc = {
      colorAttachments: [
        {
          view: colorView,
          loadOp: loadOpStr,
          storeOp: storeOpStr,
          clearValue: { r: 0, g: 0, b: 0, a: 1 },
        },
      ],
    };

    if (depthId !== 0xffff) {
      const depthView = this.textures.get(depthId)?.createView();
      if (depthView) {
        passDesc.depthStencilAttachment = {
          view: depthView,
          depthLoadOp: "clear",
          depthStoreOp: "store",
          depthClearValue: 1.0,
        };
      }
    }

    this.pass = this.encoder.beginRenderPass(passDesc);
  }

  _beginComputePass() {
    if (!this.encoder) {
      this.encoder = this.device.createCommandEncoder();
    }
    this.pass = this.encoder.beginComputePass();
  }

  _writeBuffer(id, offset, dataPtr, dataLen) {
    const buffer = this.buffers.get(id);
    if (!buffer) return;
    const data = new Uint8Array(this.memory.buffer, dataPtr, dataLen);
    this.device.queue.writeBuffer(buffer, offset, data);
  }

  _writeTimeUniform(id, offset, size) {
    const buffer = this.buffers.get(id);
    if (!buffer) return;
    // pngineInputs: time, width, height, aspect
    const data = new Float32Array([
      this.time,
      this.canvasWidth,
      this.canvasHeight,
      this.canvasWidth / (this.canvasHeight || 1),
    ]);
    const bytes = new Uint8Array(data.buffer, 0, Math.min(size, 16));
    this.device.queue.writeBuffer(buffer, offset, bytes);
  }

  _readString(ptr, len) {
    const bytes = new Uint8Array(this.memory.buffer, ptr, len);
    return new TextDecoder().decode(bytes);
  }

  /**
   * Create ImageBitmap from blob data.
   * Format: [mime_len:u8][mime:bytes][data:bytes]
   */
  _createImageBitmap(id, dataPtr, dataLen) {
    if (this.imageBitmaps.has(id)) return;

    const bytes = new Uint8Array(this.memory.buffer, dataPtr, dataLen);

    // Parse blob format: [mime_len:u8][mime:bytes][data:bytes]
    const mimeLen = bytes[0];
    const mimeBytes = bytes.slice(1, 1 + mimeLen);
    const mimeType = new TextDecoder().decode(mimeBytes);
    const imageData = bytes.slice(1 + mimeLen);

    // Create Blob and decode to ImageBitmap (async)
    const blob = new Blob([imageData], { type: mimeType });
    const bitmapPromise = globalThis.createImageBitmap(blob);

    // Store the promise - will be awaited when copying to texture
    this.imageBitmaps.set(id, bitmapPromise);
  }

  /**
   * Copy ImageBitmap to texture.
   * Handles async bitmap resolution and texture resizing.
   */
  async _copyExternalImageToTexture(bitmapId, textureId, mipLevel, originX, originY) {
    // Get the ImageBitmap (may need to await promise)
    let bitmap = this.imageBitmaps.get(bitmapId);
    if (!bitmap) {
      console.error(`[GPU] ImageBitmap ${bitmapId} not found`);
      return;
    }

    // If it's a promise, await it
    if (bitmap instanceof Promise) {
      bitmap = await bitmap;
      this.imageBitmaps.set(bitmapId, bitmap);
    }

    let texture = this.textures.get(textureId);
    if (!texture) {
      console.error(`[GPU] Texture ${textureId} not found`);
      return;
    }

    // Check if texture needs to be recreated with correct dimensions
    if (texture.width !== bitmap.width || texture.height !== bitmap.height) {
      // Destroy old texture
      texture.destroy();

      // Get original format/usage from stored descriptor
      const texDesc = this.textureDescriptors.get(textureId) || {
        format: "rgba8unorm",
        usage:
          GPUTextureUsage.TEXTURE_BINDING |
          GPUTextureUsage.COPY_DST |
          GPUTextureUsage.RENDER_ATTACHMENT,
      };

      // Create new texture with correct dimensions and original format/usage
      texture = this.device.createTexture({
        size: [bitmap.width, bitmap.height],
        format: texDesc.format,
        usage: texDesc.usage,
      });
      this.textures.set(textureId, texture);

      // Recreate any bind groups that reference this texture
      this._recreateBindGroupsForTexture(textureId);
    }

    // Copy ImageBitmap to texture
    this.device.queue.copyExternalImageToTexture(
      { source: bitmap },
      { texture, mipLevel, origin: { x: originX, y: originY } },
      { width: bitmap.width, height: bitmap.height }
    );
  }

  /**
   * Recreate bind groups that reference a resized texture.
   */
  _recreateBindGroupsForTexture(textureId) {
    for (const [bindGroupId, desc] of this.bindGroupDescriptors.entries()) {
      // Check if any entry references this texture
      const referencesTexture = desc.entries.some(
        (e) => e.resourceType === 1 && e.resourceId === textureId
      );
      if (referencesTexture) {
        // Delete old bind group and recreate
        this.bindGroups.delete(bindGroupId);
        this._recreateBindGroup(bindGroupId, desc);
      }
    }
  }

  /**
   * Recreate a bind group from stored descriptor.
   */
  _recreateBindGroup(id, desc) {
    const pipeline = this.pipelines.get(desc.layoutId);
    if (!pipeline) return;

    const gpuEntries = desc.entries.map((e) => {
      const entry = { binding: e.binding };
      if (e.resourceType === 0) {
        const bufRes = { buffer: this.buffers.get(e.resourceId) };
        if (e.offset) bufRes.offset = e.offset;
        if (e.size) bufRes.size = e.size;
        entry.resource = bufRes;
      } else if (e.resourceType === 1) {
        entry.resource = this.textures.get(e.resourceId)?.createView();
      } else if (e.resourceType === 2) {
        entry.resource = this.samplers.get(e.resourceId);
      }
      return entry;
    });

    this.bindGroups.set(
      id,
      this.device.createBindGroup({
        layout: pipeline.getBindGroupLayout(desc.groupIndex),
        entries: gpuEntries,
      })
    );
  }

  // New resource creation methods
  _createTextureView(id, textureId, descPtr, descLen) {
    if (this.textureViews.has(id)) return;
    const texture = this.textures.get(textureId);
    if (!texture) return;
    // TODO: decode descriptor for view options
    this.textureViews.set(id, texture.createView());
  }

  _createQuerySet(id, descPtr, descLen) {
    if (this.querySets.has(id)) return;
    // TODO: decode descriptor
    // const bytes = new Uint8Array(this.memory.buffer, descPtr, descLen);
    // this.querySets.set(id, this.device.createQuerySet({...}));
  }

  _createBindGroupLayout(id, descPtr, descLen) {
    if (this.bindGroupLayouts.has(id)) return;
    // TODO: decode descriptor
    // const bytes = new Uint8Array(this.memory.buffer, descPtr, descLen);
    // this.bindGroupLayouts.set(id, this.device.createBindGroupLayout({...}));
  }

  _createPipelineLayout(id, descPtr, descLen) {
    if (this.pipelineLayouts.has(id)) return;
    // TODO: decode descriptor
    // const bytes = new Uint8Array(this.memory.buffer, descPtr, descLen);
    // this.pipelineLayouts.set(id, this.device.createPipelineLayout({...}));
  }

  _createRenderBundle(id, descPtr, descLen) {
    if (this.renderBundles.has(id)) return;
    // TODO: decode descriptor and record bundle
    // const bytes = new Uint8Array(this.memory.buffer, descPtr, descLen);
  }

  // Copy operations
  _copyBufferToBuffer(srcId, srcOffset, dstId, dstOffset, size) {
    const src = this.buffers.get(srcId);
    const dst = this.buffers.get(dstId);
    if (!src || !dst) return;

    const encoder = this.encoder || this.device.createCommandEncoder();
    encoder.copyBufferToBuffer(src, srcOffset, dst, dstOffset, size);
    if (!this.encoder) {
      this.device.queue.submit([encoder.finish()]);
    }
  }

  _copyTextureToTexture(srcId, dstId, width, height) {
    const src = this.textures.get(srcId);
    const dst = this.textures.get(dstId);
    if (!src || !dst) return;

    const encoder = this.encoder || this.device.createCommandEncoder();
    encoder.copyTextureToTexture(
      { texture: src },
      { texture: dst },
      { width, height }
    );
    if (!this.encoder) {
      this.device.queue.submit([encoder.finish()]);
    }
  }

  /**
   * Write data to a GPU buffer from WASM memory or call result.
   *
   * This function handles two cases:
   * 1. Direct memory pointer: wasmPtr is a pointer in executor WASM memory
   * 2. Call result: wasmPtr is a callId from a previous _callWasmFunc
   *
   * We check wasmCallResults first to see if this is a call result reference.
   */
  _writeBufferFromWasm(bufferId, bufferOffset, wasmPtr, size) {
    const buffer = this.buffers.get(bufferId);
    if (!buffer) return;

    // Check if wasmPtr is actually a callId with stored results
    const callResult = this.wasmCallResults.get(wasmPtr);
    if (callResult) {
      if (this.debug) console.log(`[GPU] writeBufferFromWasm from call result ${wasmPtr}`);

      // The result could be:
      // 1. A pointer to the nested module's memory
      // 2. A direct value (for simple return types)
      const { memory, resultValue } = callResult;

      if (typeof resultValue === 'number' && memory) {
        // resultValue is a pointer into the nested module's memory
        const data = new Uint8Array(memory.buffer, resultValue, size);
        this.device.queue.writeBuffer(buffer, bufferOffset, data);
      } else if (typeof resultValue === 'number') {
        // Direct numeric return - convert to bytes
        // Assume f32 for single value returns
        const data = new Float32Array([resultValue]);
        this.device.queue.writeBuffer(buffer, bufferOffset, new Uint8Array(data.buffer, 0, Math.min(size, 4)));
      }

      // Clear the result after use
      this.wasmCallResults.delete(wasmPtr);
      return;
    }

    // Fallback: wasmPtr is a direct pointer to executor memory
    const data = new Uint8Array(this.memory.buffer, wasmPtr, size);
    this.device.queue.writeBuffer(buffer, bufferOffset, data);
  }

  // WASM module operations

  /**
   * Initialize an embedded WASM module.
   * Compiles and instantiates the WASM bytes, storing the instance for later calls.
   *
   * Note: This is synchronous but stores a Promise. The call will be awaited
   * when the module is first used in _callWasmFunc.
   */
  _initWasmModule(moduleId, dataPtr, dataLen) {
    if (this.wasmModules.has(moduleId)) return;

    // Read WASM bytes from executor memory
    const wasmBytes = new Uint8Array(this.memory.buffer, dataPtr, dataLen).slice();

    if (this.debug) console.log(`[GPU] initWasmModule(id=${moduleId}, size=${dataLen})`);

    // Create minimal imports for the nested WASM module
    const imports = {
      env: {
        // Provide memory if the module doesn't have its own
        // Note: Most modules export their own memory
      }
    };

    // Start async compilation (store Promise, will be awaited on first use)
    const modulePromise = WebAssembly.instantiate(wasmBytes, imports)
      .then(result => {
        const instance = result.instance;
        const memory = instance.exports.memory;
        if (this.debug) console.log(`[GPU] WASM module ${moduleId} loaded, exports:`, Object.keys(instance.exports));
        return { instance, memory };
      })
      .catch(err => {
        console.error(`[GPU] Failed to load WASM module ${moduleId}:`, err);
        return null;
      });

    this.wasmModules.set(moduleId, modulePromise);
  }

  /**
   * Call a function on an embedded WASM module.
   * Decodes arguments and stores the result for later use by write_buffer_from_wasm.
   *
   * Argument encoding format (from opcodes.zig WasmArgType):
   * - [arg_count:u8][arg_type:u8][value?:0-4 bytes]...
   *
   * Arg types:
   * - 0x00: literal_f32 (4 bytes follow)
   * - 0x01: canvas_width (runtime, 0 bytes)
   * - 0x02: canvas_height (runtime, 0 bytes)
   * - 0x03: time_total (runtime, 0 bytes)
   * - 0x04: literal_i32 (4 bytes follow)
   * - 0x05: literal_u32 (4 bytes follow)
   * - 0x06: time_delta (runtime, 0 bytes)
   */
  async _callWasmFunc(callId, moduleId, namePtr, nameLen, argsPtr, argsLen) {
    const funcName = this._readString(namePtr, nameLen);
    if (this.debug) console.log(`[GPU] callWasmFunc(callId=${callId}, moduleId=${moduleId}, func="${funcName}")`);

    // Get the module (may need to await if still loading)
    let moduleData = this.wasmModules.get(moduleId);
    if (!moduleData) {
      console.error(`[GPU] WASM module ${moduleId} not found`);
      return;
    }

    // Await if it's still a Promise
    if (moduleData instanceof Promise) {
      moduleData = await moduleData;
      if (!moduleData) return; // Loading failed
      this.wasmModules.set(moduleId, moduleData);
    }

    const { instance, memory } = moduleData;
    const fn = instance.exports[funcName];
    if (!fn) {
      console.error(`[GPU] WASM function "${funcName}" not found in module ${moduleId}`);
      return;
    }

    // Decode arguments
    const args = this._decodeWasmArgs(argsPtr, argsLen);
    if (this.debug) console.log(`[GPU]   args:`, args);

    // Call the function
    const result = fn(...args);
    if (this.debug) console.log(`[GPU]   result:`, result);

    // If the function returns data (e.g., a pointer to memory), store it
    // For functions that write to their own memory, we store a reference to that memory region
    // The result type handling depends on the function signature
    if (result !== undefined && memory) {
      // For functions that return a pointer, the bytes are in the module's memory
      // Store a marker that this call has results in the module's memory
      this.wasmCallResults.set(callId, {
        moduleId,
        memory,
        resultValue: result
      });
    }
  }

  /**
   * Decode WASM function arguments from encoded bytes.
   * Format: [arg_count:u8][arg_type:u8][value?:0-4 bytes]...
   */
  _decodeWasmArgs(argsPtr, argsLen) {
    if (argsLen === 0) return [];

    const bytes = new Uint8Array(this.memory.buffer, argsPtr, argsLen);
    const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    const args = [];

    let offset = 0;
    const argCount = bytes[offset++];

    for (let i = 0; i < argCount && offset < argsLen; i++) {
      const argType = bytes[offset++];

      switch (argType) {
        case 0x00: // literal_f32
          args.push(view.getFloat32(offset, true));
          offset += 4;
          break;
        case 0x01: // canvas_width
          args.push(this.canvasWidth);
          break;
        case 0x02: // canvas_height
          args.push(this.canvasHeight);
          break;
        case 0x03: // time_total
          args.push(this.time);
          break;
        case 0x04: // literal_i32
          args.push(view.getInt32(offset, true));
          offset += 4;
          break;
        case 0x05: // literal_u32
          args.push(view.getUint32(offset, true));
          offset += 4;
          break;
        case 0x06: // time_delta
          // Delta time not tracked in gpu.js, default to 1/60
          args.push(1/60);
          break;
        default:
          console.warn(`[GPU] Unknown WASM arg type: 0x${argType.toString(16)}`);
      }
    }

    return args;
  }

  // Utility operations
  _createTypedArray(id, arrayType, size) {
    if (this.typedArrays.has(id)) return;
    const ArrayTypes = [
      Int8Array, Uint8Array, Int16Array, Uint16Array,
      Int32Array, Uint32Array, Float32Array, Float64Array
    ];
    const ArrayType = ArrayTypes[arrayType] || Float32Array;
    const array = new ArrayType(size);
    if (this.debug) console.log(`[GPU] createTypedArray(id=${id}, type=${arrayType}/${ArrayType.name}, size=${size}, byteLength=${array.byteLength})`);
    this.typedArrays.set(id, array);
  }

  _fillRandom(arrayId, offset, count, stride, dataPtr) {
    const array = this.typedArrays.get(arrayId);
    if (!array) {
      console.error(`[GPU] fillRandom: array ${arrayId} not found`);
      return;
    }

    // Read pre-generated f32 values from WASM memory
    // Random generation happens in Zig using xoroshiro128 PRNG
    const wasmData = new Float32Array(this.memory.buffer, dataPtr, count);

    if (this.debug) console.log(`[GPU] fillRandom(array=${arrayId}, offset=${offset}, count=${count}, stride=${stride}, dataPtr=${dataPtr})`);

    // Copy values to array at offset with stride
    for (let i = 0; i < count; i++) {
      const idx = offset + i * stride;
      if (idx < array.length) {
        array[idx] = wasmData[i];
      }
    }
  }

  _fillExpression(arrayId, offset, count, stride, exprPtr, exprLen) {
    const entry = this.typedArrays.get(arrayId);
    if (!entry) {
      console.error(`[GPU] fillExpression: array ${arrayId} not found`);
      return;
    }

    // Read expression string from WASM memory
    const expr = this._readString(exprPtr, exprLen);
    if (this.debug) console.log(`[GPU] fillExpression(array=${arrayId}, offset=${offset}, count=${count}, stride=${stride}, expr="${expr}")`);
    if (!expr) return;

    try {
      // Transform expression into JS function body
      const jsExpr = expr
        .replace(/NUM_PARTICLES/g, String(count))
        .replace(/PI/g, 'Math.PI')
        .replace(/random\(\)/g, 'Math.random()')
        .replace(/sin\(/g, 'Math.sin(')
        .replace(/cos\(/g, 'Math.cos(')
        .replace(/sqrt\(/g, 'Math.sqrt(')
        .replace(/ceil\(/g, 'Math.ceil(')
        .replace(/floor\(/g, 'Math.floor(')
        .replace(/abs\(/g, 'Math.abs(');

      // Compile the expression into a function
      const fn = new Function('ELEMENT_ID', `return ${jsExpr};`);

      // Execute for each element
      for (let i = 0; i < count; i++) {
        const idx = i * stride + offset;
        entry[idx] = fn(i);
      }
    } catch (e) {
      console.error(`[GPU] Error evaluating expression "${expr}":`, e);
    }
  }

  _fillConstant(arrayId, offset, count, stride, valuePtr) {
    const entry = this.typedArrays.get(arrayId);
    if (!entry) return;

    // Read f32 value from WASM memory
    const valueView = new Float32Array(this.memory.buffer, valuePtr, 1);
    const value = valueView[0];

    for (let i = 0; i < count; i++) {
      const idx = i * stride + offset;
      entry[idx] = value;
    }
  }

  _writeBufferFromArray(bufferId, bufferOffset, arrayId) {
    const array = this.typedArrays.get(arrayId);
    const buffer = this.buffers.get(bufferId);

    if (!array || !buffer) {
      console.error(`[GPU] writeBufferFromArray: missing array ${arrayId} or buffer ${bufferId}`);
      return;
    }

    if (this.debug) {
      console.log(`[GPU] writeBufferFromArray(buffer=${bufferId}, offset=${bufferOffset}, array=${arrayId}, type=${array.constructor.name}, byteLen=${array.byteLength})`);
      const view = array instanceof Float32Array ? array : new Float32Array(array.buffer, array.byteOffset, Math.min(8, array.byteLength / 4));
      console.log(`[GPU]   first values: [${Array.from(view.slice(0, 8)).join(', ')}]`);
    }
    this.device.queue.writeBuffer(buffer, bufferOffset, array);
  }

  // Clean up resources
  destroy() {
    for (const buf of this.buffers.values()) buf.destroy?.();
    for (const tex of this.textures.values()) tex.destroy?.();
    for (const bitmap of this.imageBitmaps.values()) {
      if (bitmap instanceof ImageBitmap) bitmap.close?.();
    }
    this.buffers.clear();
    this.textures.clear();
    this.textureViews.clear();
    this.samplers.clear();
    this.shaders.clear();
    this.pipelines.clear();
    this.bindGroups.clear();
    this.bindGroupLayouts.clear();
    this.pipelineLayouts.clear();
    this.querySets.clear();
    this.renderBundles.clear();
    this.imageBitmaps.clear();
    this.wasmModules.clear();
    this.wasmCallResults.clear();
    this.typedArrays.clear();
    this.bindGroupDescriptors.clear();
    this.textureDescriptors.clear();
  }
}
