/**
 * Minimal GPU Command Dispatcher
 *
 * Executes command buffers generated by WASM.
 * Replaces the 2000-line pngine-gpu.js with a ~200-line switch.
 */

// Command opcodes (must match command_buffer.zig)
const CMD = {
  CREATE_BUFFER: 0x01,
  CREATE_TEXTURE: 0x02,
  CREATE_SAMPLER: 0x03,
  CREATE_SHADER: 0x04,
  CREATE_RENDER_PIPELINE: 0x05,
  CREATE_COMPUTE_PIPELINE: 0x06,
  CREATE_BIND_GROUP: 0x07,
  BEGIN_RENDER_PASS: 0x10,
  BEGIN_COMPUTE_PASS: 0x11,
  SET_PIPELINE: 0x12,
  SET_BIND_GROUP: 0x13,
  SET_VERTEX_BUFFER: 0x14,
  DRAW: 0x15,
  DRAW_INDEXED: 0x16,
  END_PASS: 0x17,
  DISPATCH: 0x18,
  SET_INDEX_BUFFER: 0x19,
  WRITE_BUFFER: 0x20,
  WRITE_TIME_UNIFORM: 0x21,
  SUBMIT: 0xf0,
  END: 0xff,
};

// Usage flags (match opcodes.zig BufferUsage packed struct)
// bit 0: map_read, bit 1: map_write, bit 2: copy_src, bit 3: copy_dst
// bit 4: index, bit 5: vertex, bit 6: uniform, bit 7: storage
const USAGE = {
  MAP_READ: 0x01,
  MAP_WRITE: 0x02,
  COPY_SRC: 0x04,
  COPY_DST: 0x08,
  INDEX: 0x10,
  VERTEX: 0x20,
  UNIFORM: 0x40,
  STORAGE: 0x80,
};

export class CommandDispatcher {
  constructor(device, context) {
    this.device = device;
    this.context = context;
    this.memory = null;

    // Resource tables
    this.buffers = new Map();
    this.textures = new Map();
    this.samplers = new Map();
    this.shaders = new Map();
    this.pipelines = new Map();
    this.bindGroups = new Map();
    this.bindGroupLayouts = new Map();

    // Render state
    this.encoder = null;
    this.pass = null;
    this.time = 0;
    this.canvasWidth = 0;
    this.canvasHeight = 0;
  }

  setMemory(memory) {
    this.memory = memory;
  }

  setTime(time) {
    this.time = time;
  }

  setCanvasSize(w, h) {
    this.canvasWidth = w;
    this.canvasHeight = h;
  }

  /**
   * Execute command buffer from WASM memory.
   * @param {number} ptr - Pointer to command buffer in WASM memory
   */
  execute(ptr) {
    const view = new DataView(this.memory.buffer);
    const totalLen = view.getUint32(ptr, true);
    const cmdCount = view.getUint16(ptr + 4, true);

    let pos = ptr + 8; // Skip header
    const end = ptr + totalLen;

    for (let i = 0; i < cmdCount && pos < end; i++) {
      const cmd = view.getUint8(pos++);
      pos = this._dispatch(cmd, view, pos);
    }
  }

  _dispatch(cmd, view, pos) {
    switch (cmd) {
      case CMD.CREATE_BUFFER: {
        const id = view.getUint16(pos, true);
        const size = view.getUint32(pos + 2, true);
        const usage = view.getUint8(pos + 6);
        this._createBuffer(id, size, usage);
        return pos + 7;
      }

      case CMD.CREATE_SHADER: {
        const id = view.getUint16(pos, true);
        const codePtr = view.getUint32(pos + 2, true);
        const codeLen = view.getUint32(pos + 6, true);
        this._createShader(id, codePtr, codeLen);
        return pos + 10;
      }

      case CMD.CREATE_RENDER_PIPELINE: {
        const id = view.getUint16(pos, true);
        const descPtr = view.getUint32(pos + 2, true);
        const descLen = view.getUint32(pos + 6, true);
        this._createRenderPipeline(id, descPtr, descLen);
        return pos + 10;
      }

      case CMD.CREATE_COMPUTE_PIPELINE: {
        const id = view.getUint16(pos, true);
        const descPtr = view.getUint32(pos + 2, true);
        const descLen = view.getUint32(pos + 6, true);
        this._createComputePipeline(id, descPtr, descLen);
        return pos + 10;
      }

      case CMD.CREATE_BIND_GROUP: {
        const id = view.getUint16(pos, true);
        const layoutId = view.getUint16(pos + 2, true);
        const entriesPtr = view.getUint32(pos + 4, true);
        const entriesLen = view.getUint32(pos + 8, true);
        this._createBindGroup(id, layoutId, entriesPtr, entriesLen);
        return pos + 12;
      }

      case CMD.CREATE_TEXTURE: {
        const id = view.getUint16(pos, true);
        const descPtr = view.getUint32(pos + 2, true);
        const descLen = view.getUint32(pos + 6, true);
        this._createTexture(id, descPtr, descLen);
        return pos + 10;
      }

      case CMD.CREATE_SAMPLER: {
        const id = view.getUint16(pos, true);
        const descPtr = view.getUint32(pos + 2, true);
        const descLen = view.getUint32(pos + 6, true);
        this._createSampler(id, descPtr, descLen);
        return pos + 10;
      }

      case CMD.BEGIN_RENDER_PASS: {
        const colorId = view.getUint16(pos, true);
        const loadOp = view.getUint8(pos + 2);
        const storeOp = view.getUint8(pos + 3);
        const depthId = view.getUint16(pos + 4, true);
        this._beginRenderPass(colorId, loadOp, storeOp, depthId);
        return pos + 6;
      }

      case CMD.BEGIN_COMPUTE_PASS: {
        this._beginComputePass();
        return pos;
      }

      case CMD.SET_PIPELINE: {
        const id = view.getUint16(pos, true);
        this.pass?.setPipeline(this.pipelines.get(id));
        return pos + 2;
      }

      case CMD.SET_BIND_GROUP: {
        const slot = view.getUint8(pos);
        const id = view.getUint16(pos + 1, true);
        this.pass?.setBindGroup(slot, this.bindGroups.get(id));
        return pos + 3;
      }

      case CMD.SET_VERTEX_BUFFER: {
        const slot = view.getUint8(pos);
        const id = view.getUint16(pos + 1, true);
        this.pass?.setVertexBuffer(slot, this.buffers.get(id));
        return pos + 3;
      }

      case CMD.SET_INDEX_BUFFER: {
        const id = view.getUint16(pos, true);
        const format = view.getUint8(pos + 2);
        const fmt = format === 1 ? "uint32" : "uint16";
        this.pass?.setIndexBuffer(this.buffers.get(id), fmt);
        return pos + 3;
      }

      case CMD.DRAW: {
        const vtx = view.getUint32(pos, true);
        const inst = view.getUint32(pos + 4, true);
        const firstVtx = view.getUint32(pos + 8, true);
        const firstInst = view.getUint32(pos + 12, true);
        this.pass?.draw(vtx, inst, firstVtx, firstInst);
        return pos + 16;
      }

      case CMD.DRAW_INDEXED: {
        const idx = view.getUint32(pos, true);
        const inst = view.getUint32(pos + 4, true);
        const firstIdx = view.getUint32(pos + 8, true);
        const baseVtx = view.getInt32(pos + 12, true);
        const firstInst = view.getUint32(pos + 16, true);
        this.pass?.drawIndexed(idx, inst, firstIdx, baseVtx, firstInst);
        return pos + 20;
      }

      case CMD.DISPATCH: {
        const x = view.getUint32(pos, true);
        const y = view.getUint32(pos + 4, true);
        const z = view.getUint32(pos + 8, true);
        this.pass?.dispatchWorkgroups(x, y, z);
        return pos + 12;
      }

      case CMD.END_PASS: {
        this.pass?.end();
        this.pass = null;
        return pos;
      }

      case CMD.WRITE_BUFFER: {
        const id = view.getUint16(pos, true);
        const offset = view.getUint32(pos + 2, true);
        const dataPtr = view.getUint32(pos + 6, true);
        const dataLen = view.getUint32(pos + 10, true);
        this._writeBuffer(id, offset, dataPtr, dataLen);
        return pos + 14;
      }

      case CMD.WRITE_TIME_UNIFORM: {
        const id = view.getUint16(pos, true);
        const offset = view.getUint32(pos + 2, true);
        const size = view.getUint16(pos + 6, true);
        this._writeTimeUniform(id, offset, size);
        return pos + 8;
      }

      case CMD.SUBMIT: {
        if (this.encoder) {
          this.device.queue.submit([this.encoder.finish()]);
          this.encoder = null;
        }
        return pos;
      }

      case CMD.END: {
        return pos;
      }

      default:
        console.warn(`Unknown command: 0x${cmd.toString(16)}`);
        return pos;
    }
  }

  // Resource creation
  _createBuffer(id, size, usage) {
    if (this.buffers.has(id)) return;
    const gpuUsage = this._translateUsage(usage);
    this.buffers.set(
      id,
      this.device.createBuffer({ size, usage: gpuUsage })
    );
  }

  _translateUsage(usage) {
    let result = 0;
    if (usage & USAGE.MAP_READ) result |= GPUBufferUsage.MAP_READ;
    if (usage & USAGE.MAP_WRITE) result |= GPUBufferUsage.MAP_WRITE;
    if (usage & USAGE.COPY_SRC) result |= GPUBufferUsage.COPY_SRC;
    if (usage & USAGE.COPY_DST) result |= GPUBufferUsage.COPY_DST;
    if (usage & USAGE.INDEX) result |= GPUBufferUsage.INDEX;
    if (usage & USAGE.VERTEX) result |= GPUBufferUsage.VERTEX;
    if (usage & USAGE.UNIFORM) result |= GPUBufferUsage.UNIFORM;
    if (usage & USAGE.STORAGE) result |= GPUBufferUsage.STORAGE;
    return result || GPUBufferUsage.COPY_DST;
  }

  _createShader(id, codePtr, codeLen) {
    if (this.shaders.has(id)) return;
    const code = this._readString(codePtr, codeLen);
    this.shaders.set(id, this.device.createShaderModule({ code }));
  }

  _createRenderPipeline(id, descPtr, descLen) {
    if (this.pipelines.has(id)) return;
    const json = this._readString(descPtr, descLen);
    if (!json || json.length === 0) {
      console.error(`[GPU] Empty pipeline descriptor for id=${id}, ptr=${descPtr}, len=${descLen}`);
      return;
    }
    const desc = JSON.parse(json);
    const pipeline = this._buildRenderPipeline(desc);
    this.pipelines.set(id, pipeline);
    // Store layout for bind group creation
    this.bindGroupLayouts.set(id, pipeline.getBindGroupLayout(0));
  }

  _buildRenderPipeline(desc) {
    const format = navigator.gpu.getPreferredCanvasFormat();
    // Always use "auto" layout - explicit layouts not yet supported
    return this.device.createRenderPipeline({
      layout: "auto",
      vertex: {
        module: this.shaders.get(desc.vertex?.shader ?? 0),
        entryPoint: desc.vertex?.entryPoint ?? "vs_main",
        buffers: desc.vertex?.buffers ?? [],
      },
      fragment: {
        module: this.shaders.get(desc.fragment?.shader ?? desc.vertex?.shader ?? 0),
        entryPoint: desc.fragment?.entryPoint ?? "fs_main",
        targets: [{ format }],
      },
      primitive: desc.primitive ?? { topology: "triangle-list" },
      depthStencil: desc.depthStencil,
    });
  }

  _createComputePipeline(id, descPtr, descLen) {
    if (this.pipelines.has(id)) return;
    const json = this._readString(descPtr, descLen);
    if (!json || json.length === 0) {
      console.error(`[GPU] Empty compute pipeline descriptor for id=${id}, ptr=${descPtr}, len=${descLen}`);
      return;
    }
    const desc = JSON.parse(json);
    const pipeline = this.device.createComputePipeline({
      layout: desc.layout === "auto" ? "auto" : undefined,
      compute: {
        module: this.shaders.get(desc.compute?.shader ?? 0),
        entryPoint: desc.compute?.entryPoint ?? "main",
      },
    });
    this.pipelines.set(id, pipeline);
    if (desc.layout === "auto") {
      this.bindGroupLayouts.set(id, pipeline.getBindGroupLayout(0));
    }
  }

  _createBindGroup(id, layoutId, entriesPtr, entriesLen) {
    if (this.bindGroups.has(id)) return;
    const bytes = new Uint8Array(this.memory.buffer, entriesPtr, entriesLen);
    const desc = this._decodeBindGroupDescriptor(bytes);

    // Get layout from pipeline (layoutId is pipeline ID in this context)
    const pipeline = this.pipelines.get(layoutId);
    if (!pipeline) {
      console.error(`[GPU] Pipeline ${layoutId} not found for bind group ${id}`);
      return;
    }

    const gpuEntries = desc.entries.map((e) => {
      const entry = { binding: e.binding };
      if (e.resourceType === 0) { // buffer
        const bufRes = { buffer: this.buffers.get(e.resourceId) };
        if (e.offset) bufRes.offset = e.offset;
        if (e.size) bufRes.size = e.size;
        entry.resource = bufRes;
      } else if (e.resourceType === 1) { // texture_view
        entry.resource = this.textures.get(e.resourceId)?.createView();
      } else if (e.resourceType === 2) { // sampler
        entry.resource = this.samplers.get(e.resourceId);
      }
      return entry;
    });

    this.bindGroups.set(
      id,
      this.device.createBindGroup({
        layout: pipeline.getBindGroupLayout(desc.groupIndex),
        entries: gpuEntries,
      })
    );
  }

  _decodeBindGroupDescriptor(bytes) {
    const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    let offset = 0;

    const typeTag = bytes[offset++];
    if (typeTag !== 0x03) {
      console.error(`[GPU] Invalid bind group descriptor type tag: ${typeTag}`);
      return { groupIndex: 0, entries: [] };
    }

    const fieldCount = bytes[offset++];
    let groupIndex = 0;
    const entries = [];

    const FIELD_LAYOUT = 0x01, FIELD_ENTRIES = 0x02;
    const VALUE_ARRAY = 0x03, VALUE_ENUM = 0x07;

    for (let i = 0; i < fieldCount; i++) {
      const fieldId = bytes[offset++];
      const valueType = bytes[offset++];

      if (fieldId === FIELD_LAYOUT && valueType === VALUE_ENUM) {
        groupIndex = bytes[offset++];
      } else if (fieldId === FIELD_ENTRIES && valueType === VALUE_ARRAY) {
        const entryCount = bytes[offset++];
        for (let j = 0; j < entryCount; j++) {
          const binding = bytes[offset++];
          const resourceType = bytes[offset++];
          const resourceId = view.getUint16(offset, true);
          offset += 2;

          const entry = { binding, resourceType, resourceId };
          if (resourceType === 0) { // buffer has offset/size
            entry.offset = view.getUint32(offset, true);
            offset += 4;
            entry.size = view.getUint32(offset, true);
            offset += 4;
          }
          entries.push(entry);
        }
      }
    }
    return { groupIndex, entries };
  }

  _createTexture(id, descPtr, descLen) {
    if (this.textures.has(id)) return;
    const bytes = new Uint8Array(this.memory.buffer, descPtr, descLen);
    const desc = this._decodeTextureDescriptor(bytes);
    this.textures.set(id, this.device.createTexture(desc));
  }

  _createSampler(id, descPtr, descLen) {
    if (this.samplers.has(id)) return;
    const bytes = new Uint8Array(this.memory.buffer, descPtr, descLen);
    const desc = this._decodeSamplerDescriptor(bytes);
    this.samplers.set(id, this.device.createSampler(desc));
  }

  // Binary descriptor decoders (match DescriptorEncoder.zig format)
  _decodeTextureDescriptor(bytes) {
    const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    let offset = 0;

    const typeTag = bytes[offset++];
    if (typeTag !== 0x01) {
      console.error(`[GPU] Invalid texture descriptor type tag: ${typeTag}`);
      return { size: [256, 256], format: "rgba8unorm", usage: GPUTextureUsage.RENDER_ATTACHMENT };
    }

    const fieldCount = bytes[offset++];
    const desc = {
      size: [this.canvasWidth || 512, this.canvasHeight || 512],
      format: navigator.gpu.getPreferredCanvasFormat(),
      usage: GPUTextureUsage.RENDER_ATTACHMENT,
      sampleCount: 1,
    };

    const FIELD_WIDTH = 0x01, FIELD_HEIGHT = 0x02, FIELD_SAMPLE_COUNT = 0x05;
    const FIELD_FORMAT = 0x07, FIELD_USAGE = 0x08;
    const VALUE_U32 = 0x00, VALUE_ENUM = 0x07;

    for (let i = 0; i < fieldCount; i++) {
      const fieldId = bytes[offset++];
      const valueType = bytes[offset++];

      if (valueType === VALUE_U32) {
        const value = view.getUint32(offset, true);
        offset += 4;
        if (fieldId === FIELD_WIDTH) desc.size[0] = value;
        else if (fieldId === FIELD_HEIGHT) desc.size[1] = value;
        else if (fieldId === FIELD_SAMPLE_COUNT) desc.sampleCount = value;
      } else if (valueType === VALUE_ENUM) {
        const value = bytes[offset++];
        if (fieldId === FIELD_FORMAT) desc.format = this._decodeTextureFormat(value);
        else if (fieldId === FIELD_USAGE) desc.usage = this._decodeTextureUsage(value);
      }
    }
    return desc;
  }

  _decodeSamplerDescriptor(bytes) {
    let offset = 0;
    const typeTag = bytes[offset++];
    if (typeTag !== 0x02) {
      console.error(`[GPU] Invalid sampler descriptor type tag: ${typeTag}`);
      return {};
    }

    const fieldCount = bytes[offset++];
    const desc = {
      magFilter: "linear",
      minFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge",
    };

    const FIELD_ADDRESS_U = 0x01, FIELD_ADDRESS_V = 0x02;
    const FIELD_MAG_FILTER = 0x04, FIELD_MIN_FILTER = 0x05;
    const VALUE_ENUM = 0x07;

    for (let i = 0; i < fieldCount; i++) {
      const fieldId = bytes[offset++];
      const valueType = bytes[offset++];

      if (valueType === VALUE_ENUM) {
        const value = bytes[offset++];
        if (fieldId === FIELD_MAG_FILTER) desc.magFilter = value === 0 ? "nearest" : "linear";
        else if (fieldId === FIELD_MIN_FILTER) desc.minFilter = value === 0 ? "nearest" : "linear";
        else if (fieldId === FIELD_ADDRESS_U) desc.addressModeU = ["clamp-to-edge", "repeat", "mirror-repeat"][value] || "clamp-to-edge";
        else if (fieldId === FIELD_ADDRESS_V) desc.addressModeV = ["clamp-to-edge", "repeat", "mirror-repeat"][value] || "clamp-to-edge";
      }
    }
    return desc;
  }

  _decodeTextureFormat(value) {
    const formats = {
      0x00: "rgba8unorm", 0x01: "rgba8snorm", 0x02: "rgba8uint", 0x03: "rgba8sint",
      0x04: "bgra8unorm", 0x05: "rgba16float", 0x06: "rgba32float",
      0x10: "depth24plus", 0x11: "depth24plus-stencil8", 0x12: "depth32float",
    };
    return formats[value] || navigator.gpu.getPreferredCanvasFormat();
  }

  _decodeTextureUsage(value) {
    let usage = 0;
    if (value & 0x01) usage |= GPUTextureUsage.COPY_SRC;
    if (value & 0x02) usage |= GPUTextureUsage.COPY_DST;
    if (value & 0x04) usage |= GPUTextureUsage.TEXTURE_BINDING;
    if (value & 0x08) usage |= GPUTextureUsage.STORAGE_BINDING;
    if (value & 0x10) usage |= GPUTextureUsage.RENDER_ATTACHMENT;
    return usage || GPUTextureUsage.RENDER_ATTACHMENT;
  }

  _beginRenderPass(colorId, loadOp, storeOp, depthId) {
    if (!this.encoder) {
      this.encoder = this.device.createCommandEncoder();
    }

    // 0xFFFE (65534) = use canvas, else use texture
    const CANVAS_TEXTURE_ID = 0xfffe;
    const colorView =
      colorId === CANVAS_TEXTURE_ID
        ? this.context.getCurrentTexture().createView()
        : this.textures.get(colorId)?.createView();

    // loadOp: 0=load, 1=clear
    // storeOp: 0=store, 1=discard
    const loadOpStr = loadOp === 1 ? "clear" : "load";
    const storeOpStr = storeOp === 0 ? "store" : "discard";

    const passDesc = {
      colorAttachments: [
        {
          view: colorView,
          loadOp: loadOpStr,
          storeOp: storeOpStr,
          clearValue: { r: 0, g: 0, b: 0, a: 1 },
        },
      ],
    };

    if (depthId !== 0xffff) {
      const depthView = this.textures.get(depthId)?.createView();
      if (depthView) {
        passDesc.depthStencilAttachment = {
          view: depthView,
          depthLoadOp: "clear",
          depthStoreOp: "store",
          depthClearValue: 1.0,
        };
      }
    }

    this.pass = this.encoder.beginRenderPass(passDesc);
  }

  _beginComputePass() {
    if (!this.encoder) {
      this.encoder = this.device.createCommandEncoder();
    }
    this.pass = this.encoder.beginComputePass();
  }

  _writeBuffer(id, offset, dataPtr, dataLen) {
    const buffer = this.buffers.get(id);
    if (!buffer) return;
    const data = new Uint8Array(this.memory.buffer, dataPtr, dataLen);
    this.device.queue.writeBuffer(buffer, offset, data);
  }

  _writeTimeUniform(id, offset, size) {
    const buffer = this.buffers.get(id);
    if (!buffer) return;
    // pngineInputs: time, width, height, aspect
    const data = new Float32Array([
      this.time,
      this.canvasWidth,
      this.canvasHeight,
      this.canvasWidth / (this.canvasHeight || 1),
    ]);
    const bytes = new Uint8Array(data.buffer, 0, Math.min(size, 16));
    this.device.queue.writeBuffer(buffer, offset, bytes);
  }

  _readString(ptr, len) {
    const bytes = new Uint8Array(this.memory.buffer, ptr, len);
    return new TextDecoder().decode(bytes);
  }

  // Clean up resources
  destroy() {
    for (const buf of this.buffers.values()) buf.destroy?.();
    for (const tex of this.textures.values()) tex.destroy?.();
    this.buffers.clear();
    this.textures.clear();
    this.samplers.clear();
    this.shaders.clear();
    this.pipelines.clear();
    this.bindGroups.clear();
    this.bindGroupLayouts.clear();
  }
}
